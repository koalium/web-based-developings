<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>8-Ball Pool AAA – Enhanced Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
html,body{
  margin:0;
  background:#04070a;
  overflow:hidden;
  touch-action:none;
  font-family:system-ui;
  user-select:none;
}
#hud{
  position:fixed;
  bottom:14px;
  left:50%;
  transform:translateX(-50%);
  padding:10px 18px;
  border-radius:16px;
  background:rgba(0,0,0,.45);
  backdrop-filter:blur(12px);
  color:#fff;
  font-size:13px;
  z-index:100;
  transition:opacity 0.3s;
}
#powerBar{
  position:fixed;
  bottom:60px;
  left:50%;
  transform:translateX(-50%);
  width:200px;
  height:8px;
  background:rgba(255,255,255,.1);
  border-radius:4px;
  overflow:hidden;
  opacity:0;
  transition:opacity 0.3s;
}
#powerFill{
  height:100%;
  width:0%;
  background:linear-gradient(90deg,#4CAF50,#FF9800,#FF5722);
  border-radius:4px;
  transition:width 0.1s;
}
#score{
  position:fixed;
  top:20px;
  left:20px;
  color:#fff;
  font-size:16px;
  background:rgba(0,0,0,.3);
  padding:10px 20px;
  border-radius:12px;
  backdrop-filter:blur(8px);
}
#controls{
  position:fixed;
  top:20px;
  right:20px;
  display:flex;
  gap:10px;
  z-index:100;
}
.control-btn{
  width:44px;
  height:44px;
  background:rgba(0,0,0,.5);
  border:none;
  border-radius:50%;
  color:white;
  font-size:20px;
  cursor:pointer;
  backdrop-filter:blur(8px);
  transition:background 0.2s;
}
.control-btn:hover{
  background:rgba(0,0,0,.7);
}
#gameOver{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  background:rgba(0,0,0,.85);
  color:white;
  padding:40px;
  border-radius:24px;
  text-align:center;
  display:none;
  backdrop-filter:blur(20px);
  z-index:1000;
}
#resetBtn{
  margin-top:20px;
  padding:12px 30px;
  background:#4CAF50;
  color:white;
  border:none;
  border-radius:12px;
  font-size:16px;
  cursor:pointer;
}
</style>
</head>

<body>
<div id="hud">Drag to Aim • Release to Shoot</div>
<div id="powerBar"><div id="powerFill"></div></div>
<div id="score">Balls: 15</div>
<div id="controls">
  <button class="control-btn" id="resetBtnSmall">↺</button>
  <button class="control-btn" id="viewBtn">👁</button>
</div>
<div id="gameOver">
  <h2>Game Over!</h2>
  <p id="gameOverText"></p>
  <button id="resetBtn">Play Again</button>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/* ---------- GAME STATE ---------- */
let scene,camera,renderer,world,raycaster,mouse;
let balls=[],cueBall,cue;
let aiming=false,start={x:0,y:0},power=0;
let cameraMode='follow'; // 'follow', 'free', 'top'
let cameraDistance=10;
let cameraAngleX=0.5;
let cameraAngleY=0.8;
let isDraggingCamera=false;
let lastTouchDistance=0;
let score=15;
let gameActive=true;
let pockets=[];
let pocketedBalls=[];

/* ---------- INIT ---------- */
init();
animate();

function init(){
  scene=new THREE.Scene();
  scene.fog=new THREE.Fog(0x04070a,6,25);
  
  camera=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,.1,100);
  updateCameraPosition();
  
  renderer=new THREE.WebGLRenderer({
    antialias:true,
    alpha:true,
    powerPreference:'high-performance'
  });
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.VSMShadowMap;
  renderer.outputEncoding=THREE.sRGBEncoding;
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=1.2;
  document.body.appendChild(renderer.domElement);
  
  window.addEventListener('resize',resize);
  
  raycaster=new THREE.Raycaster();
  mouse=new THREE.Vector2();
  
  enhancedLights();
  physics();
  createTableWithBorders();
  ballsCreate();
  cueCreate();
  createPockets();
  setupInput();
  setupUI();
}

/* ---------- ENHANCED LIGHTING ---------- */
function enhancedLights(){
  // Ambient light
  scene.add(new THREE.AmbientLight(0xffffff,0.25));
  
  // Main directional light (sun)
  const sunLight=new THREE.DirectionalLight(0xfff4e6,1);
  sunLight.position.set(10,20,10);
  sunLight.castShadow=true;
  sunLight.shadow.mapSize.set(4096,4096);
  sunLight.shadow.camera.left=-15;
  sunLight.shadow.camera.right=15;
  sunLight.shadow.camera.top=15;
  sunLight.shadow.camera.bottom=-15;
  sunLight.shadow.bias=-0.0001;
  scene.add(sunLight);
  
  // Fill light
  const fillLight=new THREE.DirectionalLight(0x6688ff,0.3);
  fillLight.position.set(-10,10,-10);
  scene.add(fillLight);
  
  // Rim light
  const rimLight=new THREE.DirectionalLight(0xff8866,0.2);
  rimLight.position.set(0,5,-15);
  scene.add(rimLight);
  
  // Table lights
  const tableLight1=new THREE.PointLight(0x44ff88,0.8,12);
  tableLight1.position.set(2,3,1);
  scene.add(tableLight1);
  
  const tableLight2=new THREE.PointLight(0x4488ff,0.6,12);
  tableLight2.position.set(-2,3,-1);
  scene.add(tableLight2);
  
  // Ball highlight
  const ballLight=new THREE.SpotLight(0xffffff,1,20,Math.PI/6,0.5,1);
  ballLight.position.set(0,8,0);
  ballLight.target.position.set(0,0,0);
  scene.add(ballLight);
  scene.add(ballLight.target);
}

/* ---------- PHYSICS ---------- */
function physics(){
  world=new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
  world.defaultContactMaterial.friction=.015;
  world.defaultContactMaterial.restitution=0.85;
}

/* ---------- TABLE WITH BORDERS ---------- */
function createTableWithBorders(){
  // Table surface (felt)
  const feltMat=new THREE.MeshStandardMaterial({
    color:0x0a6b46,
    roughness:.85,
    metalness:0,
    side:THREE.DoubleSide
  });
  
  const felt=new THREE.Mesh(
    new THREE.BoxGeometry(6,0.1,3),
    feltMat
  );
  felt.position.y=-0.05;
  felt.receiveShadow=true;
  scene.add(felt);
  
  // Table base (wood)
  const woodMat=new THREE.MeshStandardMaterial({
    color:0x5d4037,
    roughness:0.8,
    metalness:0.1
  });
  
  const tableBase=new THREE.Mesh(
    new THREE.BoxGeometry(6.4,0.4,3.4),
    woodMat
  );
  tableBase.position.y=-0.3;
  tableBase.receiveShadow=true;
  scene.add(tableBase);
  
  // Create borders (wooden rails)
  const borderHeight=0.4;
  const borderThickness=0.15;
  const borderMat=new THREE.MeshStandardMaterial({
    color:0x8b4513,
    roughness:0.7,
    metalness:0.2
  });
  
  // Top border
  const topBorder=new THREE.Mesh(
    new THREE.BoxGeometry(6,borderHeight,borderThickness),
    borderMat
  );
  topBorder.position.set(0,borderHeight/2,1.5+borderThickness/2);
  topBorder.castShadow=true;
  scene.add(topBorder);
  
  // Bottom border
  const bottomBorder=new THREE.Mesh(
    new THREE.BoxGeometry(6,borderHeight,borderThickness),
    borderMat
  );
  bottomBorder.position.set(0,borderHeight/2,-1.5-borderThickness/2);
  bottomBorder.castShadow=true;
  scene.add(bottomBorder);
  
  // Left border
  const leftBorder=new THREE.Mesh(
    new THREE.BoxGeometry(borderThickness,borderHeight,3),
    borderMat
  );
  leftBorder.position.set(-3-borderThickness/2,borderHeight/2,0);
  leftBorder.castShadow=true;
  scene.add(leftBorder);
  
  // Right border
  const rightBorder=new THREE.Mesh(
    new THREE.BoxGeometry(borderThickness,borderHeight,3),
    borderMat
  );
  rightBorder.position.set(3+borderThickness/2,borderHeight/2,0);
  rightBorder.castShadow=true;
  scene.add(rightBorder);
  
  // Physics bodies for borders
  const groundBody=new CANNON.Body({mass:0});
  groundBody.addShape(new CANNON.Box(new CANNON.Vec3(3,0.05,1.5)));
  groundBody.position.set(0,-0.05,0);
  world.addBody(groundBody);
  
  // Add border physics
  const addBorderPhysics=(pos,size)=>{
    const body=new CANNON.Body({mass:0});
    body.addShape(new CANNON.Box(new CANNON.Vec3(size.x,size.y,size.z)));
    body.position.copy(pos);
    world.addBody(body);
  };
  
  addBorderPhysics(new CANNON.Vec3(0,0.2,1.55),new CANNON.Vec3(3,0.2,0.075));
  addBorderPhysics(new CANNON.Vec3(0,0.2,-1.55),new CANNON.Vec3(3,0.2,0.075));
  addBorderPhysics(new CANNON.Vec3(-3.075,0.2,0),new CANNON.Vec3(0.075,0.2,1.5));
  addBorderPhysics(new CANNON.Vec3(3.075,0.2,0),new CANNON.Vec3(0.075,0.2,1.5));
}

/* ---------- POCKETS ---------- */
function createPockets(){
  const pocketGeometry=new THREE.SphereGeometry(0.2,16,16);
  const pocketMaterial=new THREE.MeshBasicMaterial({
    color:0x000000,
    transparent:true,
    opacity:0.7
  });
  
  const pocketPositions=[
    new THREE.Vector3(-2.9,0.1,1.45),   // Top-left
    new THREE.Vector3(0,0.1,1.5),       // Top-middle
    new THREE.Vector3(2.9,0.1,1.45),    // Top-right
    new THREE.Vector3(-2.9,0.1,-1.45),  // Bottom-left
    new THREE.Vector3(0,0.1,-1.5),      // Bottom-middle
    new THREE.Vector3(2.9,0.1,-1.45)    // Bottom-right
  ];
  
  pocketPositions.forEach((pos,index)=>{
    const pocketMesh=new THREE.Mesh(pocketGeometry,pocketMaterial);
    pocketMesh.position.copy(pos);
    pocketMesh.userData.isPocket=true;
    scene.add(pocketMesh);
    
    const pocketBody=new CANNON.Body({
      mass:0,
      isTrigger:true,
      shape:new CANNON.Sphere(0.2),
      position:new CANNON.Vec3(pos.x,pos.y,pos.z)
    });
    pocketBody.userData={isPocket:true,index};
    world.addBody(pocketBody);
    pockets.push({mesh:pocketMesh,body:pocketBody});
  });
}

/* ---------- BALLS ---------- */
function ballsCreate(){
  const geo=new THREE.SphereGeometry(0.12,48,48);
  
  // Create cue ball
  cueBall=makeBall(geo,0xffffff,-1.6,0,true);
  balls.push(cueBall);
  
  // Create racked balls
  let id=1;
  const ballColors=[
    0xff0000,0x00ff00,0x0000ff,0xff8800,0x8800ff,
    0x008888,0x880000,0x000000,0x888800,0x880088,
    0x008800,0x000088,0x888888,0x884400,0x004488
  ];
  
  for(let r=0;r<5;r++){
    for(let c=0;c<=r;c++){
      const color=id===8?0x000000:ballColors[id-1];
      const ball=makeBall(geo,color,1+r*0.22,(c-r/2)*0.26);
      ball.userData={id,type:id===8?'8ball':id<=7?'solid':'stripe'};
      balls.push(ball);
      id++;
    }
  }
}

function makeBall(geo,color,x,z,isCue){
  const mat=new THREE.MeshPhysicalMaterial({
    color,
    roughness:isCue?0.2:0.15,
    clearcoat:0.95,
    clearcoatRoughness:0.1,
    metalness:0.3,
    transmission:0.01,
    thickness:0.5
  });
  
  const mesh=new THREE.Mesh(geo,mat);
  mesh.castShadow=true;
  mesh.receiveShadow=true;
  mesh.position.set(x,0.12,z);
  scene.add(mesh);
  
  const body=new CANNON.Body({
    mass:1,
    shape:new CANNON.Sphere(0.12),
    position:new CANNON.Vec3(x,0.12,z),
    linearDamping:0.4,
    angularDamping:0.4
  });
  world.addBody(body);
  
  return{mesh,body,userData:{isCue:!!isCue}};
}

/* ---------- CUE ---------- */
function cueCreate(){
  const cueGroup=new THREE.Group();
  
  const shaftGeometry=new THREE.CylinderGeometry(0.015,0.025,2.5,24);
  const shaftMaterial=new THREE.MeshPhysicalMaterial({
    color:0xd4af37,
    roughness:0.3,
    metalness:0.8,
    clearcoat:1
  });
  const shaft=new THREE.Mesh(shaftGeometry,shaftMaterial);
  
  const tipGeometry=new THREE.SphereGeometry(0.022,24,24);
  const tipMaterial=new THREE.MeshStandardMaterial({
    color:0xffffff,
    roughness:0.1,
    metalness:0
  });
  const tip=new THREE.Mesh(tipGeometry,tipMaterial);
  tip.position.y=1.25;
  
  cueGroup.add(shaft);
  cueGroup.add(tip);
  cueGroup.castShadow=true;
  cueGroup.rotation.z=Math.PI/2;
  scene.add(cueGroup);
  
  cue=cueGroup;
}

/* ---------- INPUT SYSTEM ---------- */
function setupInput(){
  const canvas=renderer.domElement;
  
  // Mouse events
  canvas.addEventListener('mousedown',onMouseDown);
  canvas.addEventListener('mousemove',onMouseMove);
  canvas.addEventListener('mouseup',onMouseUp);
  
  // Touch events
  canvas.addEventListener('touchstart',onTouchStart,{passive:false});
  canvas.addEventListener('touchmove',onTouchMove,{passive:false});
  canvas.addEventListener('touchend',onTouchEnd);
  
  // Wheel for zoom
  canvas.addEventListener('wheel',onWheel);
  
  // Right click for camera
  canvas.addEventListener('contextmenu',(e)=>e.preventDefault());
  canvas.addEventListener('mousedown',(e)=>{
    if(e.button===2){
      isDraggingCamera=true;
      start.x=e.clientX;
      start.y=e.clientY;
    }
  });
  canvas.addEventListener('mousemove',(e)=>{
    if(isDraggingCamera){
      cameraAngleX+=(e.clientX-start.x)*0.01;
      cameraAngleY=Math.max(0.1,Math.min(Math.PI/2,cameraAngleY-(e.clientY-start.y)*0.01));
      start.x=e.clientX;
      start.y=e.clientY;
      updateCameraPosition();
    }
  });
  canvas.addEventListener('mouseup',(e)=>{
    if(e.button===2)isDraggingCamera=false;
  });
}

function onMouseDown(e){
  if(e.button!==0)return;
  aiming=true;
  start={x:e.clientX,y:e.clientY};
  document.getElementById('powerBar').style.opacity='1';
}

function onMouseMove(e){
  if(!aiming)return;
  const dx=e.clientX-start.x;
  const dy=e.clientY-start.y;
  power=Math.min(Math.sqrt(dx*dx+dy*dy)/150,1);
  document.getElementById('powerFill').style.width=`${power*100}%`;
}

function onMouseUp(e){
  if(!aiming||e.button!==0)return;
  shootBall(start.x-e.clientX,start.y-e.clientY);
}

function onTouchStart(e){
  e.preventDefault();
  if(e.touches.length===1){
    aiming=true;
    start={x:e.touches[0].clientX,y:e.touches[0].clientY};
    document.getElementById('powerBar').style.opacity='1';
  }else if(e.touches.length===2){
    isDraggingCamera=true;
    lastTouchDistance=getTouchDistance(e.touches);
  }
}

function onTouchMove(e){
  e.preventDefault();
  if(e.touches.length===1&&aiming){
    const dx=e.touches[0].clientX-start.x;
    const dy=e.touches[0].clientY-start.y;
    power=Math.min(Math.sqrt(dx*dx+dy*dy)/150,1);
    document.getElementById('powerFill').style.width=`${power*100}%`;
  }else if(e.touches.length===2){
    const touchDistance=getTouchDistance(e.touches);
    cameraDistance=Math.max(5,Math.min(20,cameraDistance+(lastTouchDistance-touchDistance)*0.01));
    lastTouchDistance=touchDistance;
    
    const touch1=e.touches[0];
    const touch2=e.touches[1];
    cameraAngleX+=(touch1.clientX-touch2.clientX)*0.001;
    cameraAngleY=Math.max(0.1,Math.min(Math.PI/2,cameraAngleY+(touch1.clientY-touch2.clientY)*0.001));
    updateCameraPosition();
  }
}

function onTouchEnd(e){
  if(aiming&&e.touches.length===0){
    shootBall(0,0);
  }
  if(e.touches.length<2){
    isDraggingCamera=false;
  }
}

function onWheel(e){
  e.preventDefault();
  cameraDistance=Math.max(5,Math.min(20,cameraDistance+e.deltaY*0.01));
  updateCameraPosition();
}

function getTouchDistance(touches){
  const dx=touches[0].clientX-touches[1].clientX;
  const dy=touches[0].clientY-touches[1].clientY;
  return Math.sqrt(dx*dx+dy*dy);
}

function shootBall(dx,dy){
  aiming=false;
  const forceX=dx*0.035*power;
  const forceZ=dy*0.035*power;
  
  cueBall.body.applyImpulse(
    new CANNON.Vec3(forceX,0,forceZ),
    cueBall.body.position
  );
  
  power=0;
  document.getElementById('powerFill').style.width='0%';
  document.getElementById('powerBar').style.opacity='0';
}

/* ---------- UI ---------- */
function setupUI(){
  document.getElementById('resetBtnSmall').addEventListener('click',resetGame);
  document.getElementById('viewBtn').addEventListener('click',toggleView);
  document.getElementById('resetBtn').addEventListener('click',resetGame);
}

function toggleView(){
  const views=['follow','free','top'];
  const currentIndex=views.indexOf(cameraMode);
  cameraMode=views[(currentIndex+1)%views.length];
  
  switch(cameraMode){
    case 'free':
      cameraAngleX=0.8;
      cameraAngleY=0.6;
      cameraDistance=12;
      break;
    case 'top':
      camera.position.set(0,15,0);
      camera.lookAt(0,0,0);
      break;
  }
  updateCameraPosition();
}

/* ---------- GAME LOGIC ---------- */
function checkPocketCollisions(){
  for(let i=balls.length-1;i>=0;i--){
    const ball=balls[i];
    const ballPos=ball.body.position;
    
    // Check if ball is below table (pocketed)
    if(ballPos.y<-0.5){
      pocketBall(i);
      continue;
    }
    
    // Check pocket collisions
    for(const pocket of pockets){
      const distance=ballPos.distanceTo(pocket.body.position);
      if(distance<0.25){ // Ball is in pocket
        pocketBall(i);
        break;
      }
    }
  }
}

function pocketBall(index){
  const ball=balls[index];
  
  // Add to pocketed balls
  pocketedBalls.push(ball);
  
  // Remove from scene and physics world
  scene.remove(ball.mesh);
  world.removeBody(ball.body);
  balls.splice(index,1);
  
  // Update score
  score--;
  document.getElementById('score').textContent=`Balls: ${score}`;
  
  // Check game over
  if(score<=0){
    endGame(true);
  }else if(ball.userData.isCue){
    endGame(false);
  }
}

function endGame(success){
  gameActive=false;
  const gameOverDiv=document.getElementById('gameOver');
  const gameOverText=document.getElementById('gameOverText');
  
  if(success){
    gameOverText.textContent="Congratulations! You pocketed all balls!";
  }else{
    gameOverText.textContent="Cue ball pocketed! Game Over!";
  }
  
  gameOverDiv.style.display='block';
}

function resetGame(){
  // Clear existing balls
  balls.forEach(ball=>{
    scene.remove(ball.mesh);
    world.removeBody(ball.body);
  });
  
  // Reset arrays
  balls=[];
  pocketedBalls=[];
  
  // Reset score
  score=15;
  document.getElementById('score').textContent=`Balls: ${score}`;
  
  // Create new balls
  ballsCreate();
  
  // Reset camera
  cameraMode='follow';
  cameraDistance=10;
  cameraAngleX=0.5;
  cameraAngleY=0.8;
  updateCameraPosition();
  
  // Hide game over screen
  document.getElementById('gameOver').style.display='none';
  gameActive=true;
}

/* ---------- CAMERA ---------- */
function updateCameraPosition(){
  switch(cameraMode){
    case 'follow':
      if(cueBall){
        const targetX=cueBall.mesh.position.x;
        const offsetX=Math.sin(cameraAngleX)*cameraDistance;
        const offsetZ=Math.cos(cameraAngleX)*cameraDistance;
        const offsetY=Math.sin(cameraAngleY)*cameraDistance;
        
        camera.position.set(
          targetX+offsetX,
          offsetY+3,
          offsetZ
        );
        camera.lookAt(targetX,0,0);
      }
      break;
    case 'free':
      const freeX=Math.sin(cameraAngleX)*cameraDistance;
      const freeZ=Math.cos(cameraAngleX)*cameraDistance;
      const freeY=Math.sin(cameraAngleY)*cameraDistance+3;
      
      camera.position.set(freeX,freeY,freeZ);
      camera.lookAt(0,0,0);
      break;
  }
}

function cameraFollow(){
  if(cameraMode==='follow'&&cueBall){
    updateCameraPosition();
  }
}

/* ---------- LOOP ---------- */
function animate(){
  if(!gameActive){
    requestAnimationFrame(animate);
    return;
  }
  
  requestAnimationFrame(animate);
  world.step(1/60);
  
  // Update ball positions
  balls.forEach(b=>{
    b.mesh.position.copy(b.body.position);
    b.mesh.quaternion.copy(b.body.quaternion);
  });
  
  // Update cue
  updateCue();
  
  // Update camera
  cameraFollow();
  
  // Check pocket collisions
  checkPocketCollisions();
  
  // Render
  renderer.render(scene,camera);
}

function updateCue(){
  if(!cueBall)return;
  
  cue.visible=aiming;
  if(!aiming)return;
  
  const direction=new THREE.Vector3(
    Math.sin(cueBall.body.rotation.y),
    0,
    Math.cos(cueBall.body.rotation.y)
  ).normalize();
  
  cue.position.copy(cueBall.mesh.position);
  cue.position.add(direction.multiplyScalar(-1.2-power*0.5));
  cue.position.y=0.15+power*0.05;
  
  cue.rotation.z=Math.PI/2;
  cue.rotation.y=-Math.atan2(direction.z,direction.x);
  cue.scale.set(1,1,1+power*0.2);
}

function resize(){
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>