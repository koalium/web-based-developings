<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fractal Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            padding: 15px;
            text-align: center;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid rgba(0, 150, 255, 0.3);
            z-index: 10;
            position: relative;
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #00a8ff, #00ffaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
        }
        
        .subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.4;
        }
        
        #container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #ui-overlay {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            padding: 0 15px;
        }
        
        #controls {
            background: rgba(0, 20, 40, 0.8);
            border-radius: 15px;
            padding: 15px;
            width: 100%;
            max-width: 500px;
            border: 1px solid rgba(0, 150, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: #00a8ff;
            display: flex;
            justify-content: space-between;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        .slider-value {
            min-width: 40px;
            text-align: right;
            font-size: 0.85rem;
            color: #00ffaa;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(0, 50, 100, 0.5);
            border-radius: 4px;
            outline: none;
            margin: 0 10px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00a8ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 168, 255, 0.8);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00a8ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 168, 255, 0.8);
        }
        
        #buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn {
            padding: 10px 15px;
            border-radius: 8px;
            border: none;
            background: linear-gradient(135deg, #0066cc, #00a8ff);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 140px;
            font-size: 0.9rem;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #00a8ff, #00ffaa);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 168, 255, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            max-width: 300px;
            border: 1px solid rgba(0, 150, 255, 0.3);
            backdrop-filter: blur(5px);
            z-index: 5;
        }
        
        #info-panel h3 {
            color: #00a8ff;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        #info-panel p {
            font-size: 0.85rem;
            line-height: 1.4;
            margin-bottom: 10px;
            opacity: 0.9;
        }
        
        #depth-indicator {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 150, 255, 0.3);
        }
        
        #depth-text {
            font-size: 1.2rem;
            color: #00ffaa;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 255, 170, 0.5);
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 168, 255, 0.3);
            border-radius: 50%;
            border-top-color: #00a8ff;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            max-width: 300px;
            border: 1px solid rgba(0, 150, 255, 0.3);
            backdrop-filter: blur(5px);
            z-index: 5;
            font-size: 0.85rem;
        }
        
        #instructions h3 {
            color: #00a8ff;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }
        
        #instructions ul {
            padding-left: 20px;
            opacity: 0.9;
        }
        
        #instructions li {
            margin-bottom: 5px;
        }
        
        .mobile-only {
            display: none;
        }
        
        @media (max-width: 768px) {
            #header {
                padding: 12px;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }
            
            #info-panel, #instructions {
                position: relative;
                top: auto;
                right: auto;
                bottom: auto;
                left: auto;
                max-width: 100%;
                margin: 10px 15px;
            }
            
            #ui-overlay {
                position: relative;
                bottom: auto;
                padding: 15px;
            }
            
            .mobile-only {
                display: block;
            }
            
            #controls {
                padding: 12px;
            }
            
            .btn {
                min-width: 120px;
                padding: 8px 12px;
                font-size: 0.85rem;
            }
            
            #buttons {
                gap: 8px;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.3rem;
            }
            
            #buttons {
                flex-direction: column;
            }
            
            .btn {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>3D Fractal Explorer</h1>
        <p class="subtitle">Explore infinite fractal geometry in 3D. Zoom deeper to reveal ever more complex structures. Use touch gestures or mouse to navigate.</p>
    </div>
    
    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="loading">
            <div class="spinner"></div>
            <p>Loading 3D Fractal World...</p>
        </div>
        
        <div id="info-panel">
            <h3>Fractal Information</h3>
            <p>This is a 3D Mandelbulb fractal, a three-dimensional extension of the Mandelbrot set.</p>
            <p>As you zoom in, you'll discover infinite self-similar patterns and intricate structures.</p>
            <div id="depth-indicator">
                <div>Zoom Depth:</div>
                <div id="depth-text">1x</div>
            </div>
        </div>
        
        <div id="instructions" class="mobile-only">
            <h3>Touch Controls</h3>
            <ul>
                <li>Pinch to zoom in/out</li>
                <li>Swipe to rotate view</li>
                <li>Two-finger drag to pan</li>
            </ul>
        </div>
        
        <div id="ui-overlay">
            <div id="controls">
                <div class="control-group">
                    <div class="control-title">
                        <span>Fractal Detail</span>
                        <span id="detail-value" class="slider-value">8</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="detail-slider" min="2" max="16" value="8" step="1">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">
                        <span>Animation Speed</span>
                        <span id="speed-value" class="slider-value">0.5</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="speed-slider" min="0" max="1" value="0.5" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">
                        <span>Color Intensity</span>
                        <span id="color-value" class="slider-value">1.0</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="color-slider" min="0.1" max="2" value="1.0" step="0.1">
                    </div>
                </div>
                
                <div id="buttons">
                    <button id="reset-btn" class="btn">Reset View</button>
                    <button id="auto-zoom-btn" class="btn">Auto-Zoom</button>
                    <button id="change-fractal-btn" class="btn">Change Fractal</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main Three.js variables
        let scene, camera, renderer, controls;
        let fractalMesh, fractalMaterial;
        let zoomDepth = 1;
        let autoZoom = false;
        let animationSpeed = 0.5;
        let fractalType = 'mandelbulb';
        let clock = new THREE.Clock();
        
        // UI Elements
        const detailSlider = document.getElementById('detail-slider');
        const detailValue = document.getElementById('detail-value');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const colorSlider = document.getElementById('color-slider');
        const colorValue = document.getElementById('color-value');
        const resetBtn = document.getElementById('reset-btn');
        const autoZoomBtn = document.getElementById('auto-zoom-btn');
        const changeFractalBtn = document.getElementById('change-fractal-btn');
        const depthText = document.getElementById('depth-text');
        const loadingScreen = document.getElementById('loading');
        
        // Initialize the 3D scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2, 2, 2);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add renderer to DOM
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.appendChild(renderer.domElement);
            
            // Add orbit controls for interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.5;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI;
            controls.rotateSpeed = 0.5;
            controls.panSpeed = 0.5;
            controls.zoomSpeed = 0.8;
            
            // Make controls touch-friendly
            controls.touchRotate = true;
            controls.touchZoom = true;
            controls.touchPan = true;
            
            // Create fractal geometry
            createFractal();
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add subtle fog for depth
            scene.fog = new THREE.Fog(0x000000, 5, 15);
            
            // Hide loading screen
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }, 1500);
            
            // Add window resize listener
            window.addEventListener('resize', onWindowResize);
            
            // Initialize UI event listeners
            initUI();
            
            // Start animation loop
            animate();
        }
        
        // Create the fractal geometry
        function createFractal() {
            // Remove existing fractal if present
            if (fractalMesh) {
                scene.remove(fractalMesh);
                fractalMesh.geometry.dispose();
                fractalMesh.material.dispose();
            }
            
            // Create geometry (sphere for ray marching)
            const geometry = new THREE.SphereGeometry(1.5, 128, 128);
            
            // Create custom shader material for fractal
            fractalMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    detail: { value: parseInt(detailSlider.value) },
                    colorIntensity: { value: parseFloat(colorSlider.value) },
                    zoom: { value: 1.0 },
                    fractalType: { value: fractalType === 'mandelbulb' ? 0 : 1 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform int detail;
                    uniform float colorIntensity;
                    uniform float zoom;
                    uniform int fractalType;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    // Mandelbulb distance estimator
                    float mandelbulbDE(vec3 pos, int iterations) {
                        vec3 z = pos;
                        float dr = 1.0;
                        float r = 0.0;
                        
                        for (int i = 0; i < 20; i++) {
                            if (i >= iterations) break;
                            
                            r = length(z);
                            if (r > 4.0) break;
                            
                            // Convert to polar coordinates
                            float theta = acos(z.z / r);
                            float phi = atan(z.y, z.x);
                            dr = pow(r, 8.0 - 1.0) * 8.0 * dr + 1.0;
                            
                            // Scale and rotate the point
                            float zr = pow(r, 8.0);
                            theta = theta * 8.0;
                            phi = phi * 8.0;
                            
                            // Convert back to Cartesian coordinates
                            z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                            z += pos;
                        }
                        
                        return 0.5 * log(r) * r / dr;
                    }
                    
                    // Julia set distance estimator
                    float juliaDE(vec3 pos, int iterations) {
                        vec3 c = vec3(0.4, 0.3, 0.2);
                        vec3 z = pos;
                        float dr = 1.0;
                        float r = 0.0;
                        
                        for (int i = 0; i < 20; i++) {
                            if (i >= iterations) break;
                            
                            r = length(z);
                            if (r > 4.0) break;
                            
                            // Convert to polar coordinates
                            float theta = acos(z.z / r);
                            float phi = atan(z.y, z.x);
                            dr = pow(r, 4.0 - 1.0) * 4.0 * dr + 1.0;
                            
                            // Scale and rotate the point
                            float zr = pow(r, 4.0);
                            theta = theta * 4.0;
                            phi = phi * 4.0;
                            
                            // Convert back to Cartesian coordinates
                            z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                            z += c;
                        }
                        
                        return 0.5 * log(r) * r / dr;
                    }
                    
                    // Main distance estimator
                    float map(vec3 pos, int iterations) {
                        if (fractalType == 0) {
                            return mandelbulbDE(pos, iterations);
                        } else {
                            return juliaDE(pos, iterations);
                        }
                    }
                    
                    // Calculate normal using gradient
                    vec3 calcNormal(vec3 pos, int iterations) {
                        const float eps = 0.001;
                        const vec2 h = vec2(eps, 0);
                        
                        return normalize(vec3(
                            map(pos + h.xyy, iterations) - map(pos - h.xyy, iterations),
                            map(pos + h.yxy, iterations) - map(pos - h.yxy, iterations),
                            map(pos + h.yyx, iterations) - map(pos - h.yyx, iterations)
                        ));
                    }
                    
                    // Color gradient
                    vec3 palette(float t) {
                        vec3 a = vec3(0.5, 0.5, 0.5);
                        vec3 b = vec3(0.5, 0.5, 0.5);
                        vec3 c = vec3(1.0, 1.0, 1.0);
                        vec3 d = vec3(0.0, 0.33, 0.67);
                        
                        return a + b * cos(6.28318 * (c * t + d));
                    }
                    
                    void main() {
                        // Ray direction from camera
                        vec3 rayDir = normalize(vPosition - cameraPosition);
                        vec3 rayOrigin = cameraPosition;
                        
                        // Apply zoom
                        rayOrigin *= zoom;
                        
                        // Ray marching
                        float totalDistance = 0.0;
                        vec3 pos = rayOrigin;
                        float distance = 0.0;
                        int steps;
                        
                        for (steps = 0; steps < 100; steps++) {
                            distance = map(pos, detail);
                            totalDistance += distance;
                            pos += rayDir * distance;
                            
                            if (distance < 0.001) break;
                            if (totalDistance > 20.0) break;
                        }
                        
                        // Calculate color based on distance and steps
                        float glow = 1.0 - float(steps) / 100.0;
                        vec3 normal = calcNormal(pos, detail);
                        
                        // Lighting
                        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                        float diffuse = max(dot(normal, lightDir), 0.1);
                        float specular = pow(max(dot(reflect(-lightDir, normal), -rayDir), 0.0), 32.0);
                        
                        // Base color
                        vec3 baseColor = palette(length(pos) * 0.2 + time * 0.1);
                        baseColor = mix(baseColor, vec3(0.2, 0.5, 1.0), 0.5);
                        
                        // Final color with lighting
                        vec3 color = baseColor * diffuse + vec3(1.0) * specular * 0.5;
                        color += baseColor * glow * 0.5;
                        color *= colorIntensity;
                        
                        // Fog
                        float fogFactor = exp(-totalDistance * 0.1);
                        color = mix(vec3(0.0), color, fogFactor);
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide // Render inside of sphere for ray marching
            });
            
            // Create mesh
            fractalMesh = new THREE.Mesh(geometry, fractalMaterial);
            scene.add(fractalMesh);
        }
        
        // Initialize UI event listeners
        function initUI() {
            // Detail slider
            detailSlider.addEventListener('input', function() {
                const value = this.value;
                detailValue.textContent = value;
                if (fractalMaterial) {
                    fractalMaterial.uniforms.detail.value = parseInt(value);
                }
                updateDepthText();
            });
            
            // Speed slider
            speedSlider.addEventListener('input', function() {
                const value = parseFloat(this.value).toFixed(1);
                speedValue.textContent = value;
                animationSpeed = parseFloat(value);
            });
            
            // Color slider
            colorSlider.addEventListener('input', function() {
                const value = parseFloat(this.value).toFixed(1);
                colorValue.textContent = value;
                if (fractalMaterial) {
                    fractalMaterial.uniforms.colorIntensity.value = parseFloat(value);
                }
            });
            
            // Reset button
            resetBtn.addEventListener('click', function() {
                controls.reset();
                zoomDepth = 1;
                if (fractalMaterial) {
                    fractalMaterial.uniforms.zoom.value = 1.0;
                }
                updateDepthText();
                autoZoom = false;
                autoZoomBtn.textContent = "Auto-Zoom";
            });
            
            // Auto-zoom button
            autoZoomBtn.addEventListener('click', function() {
                autoZoom = !autoZoom;
                this.textContent = autoZoom ? "Stop Auto-Zoom" : "Auto-Zoom";
            });
            
            // Change fractal button
            changeFractalBtn.addEventListener('click', function() {
                fractalType = fractalType === 'mandelbulb' ? 'julia' : 'mandelbulb';
                this.textContent = fractalType === 'mandelbulb' ? 'Julia Set' : 'Mandelbulb';
                createFractal();
                updateDepthText();
            });
            
            // Update zoom depth when user zooms manually
            controls.addEventListener('change', function() {
                if (!autoZoom) {
                    zoomDepth = Math.pow(2, (controls.maxDistance - controls.getDistance()) * 0.5);
                    if (fractalMaterial) {
                        fractalMaterial.uniforms.zoom.value = zoomDepth;
                    }
                    updateDepthText();
                }
            });
        }
        
        // Update depth indicator text
        function updateDepthText() {
            const depth = Math.max(1, Math.round(zoomDepth * 10) / 10);
            const detail = parseInt(detailSlider.value);
            depthText.textContent = `${depth.toFixed(1)}x (Detail: ${detail})`;
            
            // Change color based on depth
            const hue = (depth * 20) % 360;
            depthText.style.color = `hsl(${hue}, 100%, 65%)`;
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Update fractal material time uniform
            if (fractalMaterial) {
                fractalMaterial.uniforms.time.value = time * animationSpeed;
                
                // Auto-zoom if enabled
                if (autoZoom) {
                    zoomDepth = 1 + Math.sin(time * 0.2) * 10;
                    fractalMaterial.uniforms.zoom.value = zoomDepth;
                    
                    // Also move camera for auto-zoom effect
                    const zoomFactor = 1 + Math.sin(time * 0.1) * 0.5;
                    controls.minDistance = 0.5 / zoomFactor;
                    
                    updateDepthText();
                }
                
                // Rotate fractal slowly
                fractalMesh.rotation.y = time * 0.1;
                fractalMesh.rotation.x = time * 0.05;
            }
            
            // Update controls
            controls.update();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>