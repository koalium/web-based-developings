<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Fractal Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: #000;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #ui-overlay > * {
            pointer-events: auto;
        }
        
        #header {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            padding: 0 20px;
        }
        
        #title {
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 800;
            background: linear-gradient(45deg, #00ffcc, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }
        
        #subtitle {
            font-size: clamp(0.8rem, 2vw, 1rem);
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.4;
        }
        
        #control-panel {
            position: absolute;
            bottom: 120px;
            left: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(0, 255, 204, 0.2);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 20;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .control-section {
            margin-bottom: 25px;
        }
        
        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #00ffcc;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .control-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }
        
        .control-value {
            color: #0099ff;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        .slider-container {
            position: relative;
            height: 30px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #003366, #00ccff);
            border-radius: 3px;
            outline: none;
            margin: 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #00ffcc;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.8);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #00ffcc;
        }
        
        .button-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn {
            padding: 14px 24px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, rgba(0, 153, 255, 0.9), rgba(0, 255, 204, 0.9));
            color: white;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 153, 255, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 153, 255, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, rgba(40, 40, 60, 0.9), rgba(60, 60, 80, 0.9));
        }
        
        #status-bar {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 204, 0.2);
            z-index: 20;
            min-width: 200px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 0.9rem;
        }
        
        .status-label {
            color: #88ccff;
        }
        
        .status-value {
            color: #00ffcc;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        #fractal-selector {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 204, 0.2);
            z-index: 20;
            min-width: 200px;
        }
        
        .fractal-option {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: rgba(0, 60, 100, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .fractal-option:hover {
            background: rgba(0, 100, 160, 0.4);
            transform: translateX(5px);
        }
        
        .fractal-option.active {
            background: rgba(0, 150, 255, 0.3);
            border-color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        
        #touch-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            gap: 15px;
        }
        
        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        #auto-play {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
        }
        
        #play-btn {
            padding: 12px 24px;
            border-radius: 25px;
            border: none;
            background: linear-gradient(135deg, #00cc66, #00ff99);
            color: white;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 20px rgba(0, 204, 102, 0.4);
        }
        
        @media (max-width: 768px) {
            #control-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                padding: 20px;
            }
            
            #status-bar, #fractal-selector {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                width: 100%;
                margin-bottom: 15px;
            }
            
            #header {
                top: 10px;
            }
            
            #touch-controls {
                display: flex;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            .btn {
                padding: 12px 18px;
                font-size: 0.9rem;
            }
            
            .section-title {
                font-size: 1rem;
            }
            
            #control-panel {
                padding: 15px;
            }
        }
        
        .fps-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <div class="fps-display" id="fps">60 FPS</div>
        
        <div id="header">
            <div id="title">Quantum Fractal Explorer</div>
            <div id="subtitle">Real-time 3D fractal visualization with progressive detail loading</div>
        </div>
        
        <div id="auto-play">
            <button id="play-btn">
                <span id="play-icon">‚ñ∂</span>
                <span id="play-text">Auto Play</span>
            </button>
        </div>
        
        <div id="status-bar">
            <div class="status-item">
                <span class="status-label">Iterations:</span>
                <span class="status-value" id="iter-count">16</span>
            </div>
            <div class="status-item">
                <span class="status-label">Zoom Depth:</span>
                <span class="status-value" id="zoom-depth">1.0x</span>
            </div>
            <div class="status-item">
                <span class="status-label">Complexity:</span>
                <span class="status-value" id="complexity">Medium</span>
            </div>
            <div class="status-item">
                <span class="status-label">Rendering:</span>
                <span class="status-value" id="render-mode">Adaptive</span>
            </div>
        </div>
        
        <div id="fractal-selector">
            <div class="fractal-option active" data-type="mandelbulb">Mandelbulb 3D</div>
            <div class="fractal-option" data-type="julia">Julia Set 3D</div>
            <div class="fractal-option" data-type="menger">Menger Sponge</div>
            <div class="fractal-option" data-type="apollonian">Apollonian Sphere</div>
            <div class="fractal-option" data-type="quaternion">Quaternion Fractal</div>
            <div class="fractal-option" data-type="kleinian">Kleinian Limit</div>
        </div>
        
        <div id="control-panel">
            <div class="control-section">
                <div class="section-title">
                    <span>‚öôÔ∏è Fractal Controls</span>
                </div>
                <div class="control-grid">
                    <div class="control-item">
                        <div class="control-label">
                            <span>Detail Level</span>
                            <span class="control-value" id="detail-value">12</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="detail-slider" min="4" max="32" value="12" step="2">
                        </div>
                    </div>
                    <div class="control-item">
                        <div class="control-label">
                            <span>Zoom Speed</span>
                            <span class="control-value" id="zoom-value">1.0</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="zoom-slider" min="0.1" max="3" value="1.0" step="0.1">
                        </div>
                    </div>
                    <div class="control-item">
                        <div class="control-label">
                            <span>Animation Speed</span>
                            <span class="control-value" id="anim-value">0.5</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="anim-slider" min="0" max="1" value="0.5" step="0.1">
                        </div>
                    </div>
                    <div class="control-item">
                        <div class="control-label">
                            <span>Color Intensity</span>
                            <span class="control-value" id="color-value">1.0</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="color-slider" min="0.1" max="2" value="1.0" step="0.1">
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="btn" id="reset-btn">
                    <span>‚Ü∫</span> Reset View
                </button>
                <button class="btn" id="auto-zoom-btn">
                    <span>‚ö°</span> Auto Zoom
                </button>
                <button class="btn" id="screenshot-btn">
                    <span>üì∑</span> Screenshot
                </button>
                <button class="btn btn-secondary" id="performance-btn">
                    <span>‚öôÔ∏è</span> Performance
                </button>
                <button class="btn btn-secondary" id="help-btn">
                    <span>‚ùì</span> Help
                </button>
            </div>
        </div>
        
        <div id="touch-controls">
            <div class="touch-btn" id="zoom-in">+</div>
            <div class="touch-btn" id="zoom-out">-</div>
            <div class="touch-btn" id="rotate-btn">‚ü≥</div>
        </div>
    </div>

    <script>
        // Optimized Fractal Engine with Progressive Rendering
        'use strict';
        
        // Configuration
        const CONFIG = {
            MAX_ITERATIONS: 32,
            MIN_ITERATIONS: 4,
            AUTO_PLAY_SPEED: 0.02,
            TARGET_FPS: 60,
            ADAPTIVE_DETAIL: true,
            PROGRESSIVE_LOADING: true,
            MOBILE_OPTIMIZED: true
        };
        
        // Core Variables
        let scene, camera, renderer;
        let fractalMesh, fractalMaterial;
        let currentFractal = 'mandelbulb';
        let autoPlay = false;
        let autoZoom = false;
        let animationTime = 0;
        let zoomLevel = 1.0;
        let frameId = null;
        let lastTime = 0;
        let fps = 60;
        let frameCount = 0;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        let performanceMode = 'balanced';
        
        // Performance Monitoring
        const perf = {
            fps: 60,
            frameTime: 0,
            detailLevel: 12,
            maxDetail: 32,
            adaptiveScale: 1.0
        };
        
        // Initialize Scene
        function init() {
            // Create optimized scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.01, 1000);
            camera.position.set(0, 0.55, 5.5);
            
            // Create renderer with optimal settings
            renderer = new THREE.WebGLRenderer({
                antialias: !isMobile,
                alpha: false,
                powerPreference: 'high-performance',
                precision: isMobile ? 'mediump' : 'highp'
            });
            
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            renderer.autoClear = true;
            
            // Enable essential features only
            if (!isMobile) {
                renderer.shadowMap.enabled = false;
            }
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Initialize fractal
            createFractal();
            
            // Setup lighting
            setupLighting();
            
            // Initialize UI
            initUI();
            
            // Start animation loop
            animate();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize, { passive: true });
        }
        
        // Create fractal with optimized geometry
        function createFractal() {
            // Clean up previous fractal
            if (fractalMesh) {
                scene.remove(fractalMesh);
                if (fractalMesh.geometry) fractalMesh.geometry.dispose();
                if (fractalMesh.material) fractalMesh.material.dispose();
            }
            
            // Create optimized geometry
            const geometry = new THREE.SphereGeometry(1.8, 
                isMobile ? 64 : 96, 
                isMobile ? 32 : 48
            );
            
            // Create optimized shader material
            fractalMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    zoom: { value: 1.0 },
                    detail: { value: perf.detailLevel },
                    colorScale: { value: 1.0 },
                    fractalType: { value: getFractalTypeIndex(currentFractal) },
                    power: { value: getFractalPower(currentFractal) },
                    juliaC: { value: new THREE.Vector3(0.4, 0.3, 0.2) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: getFractalShader(currentFractal),
                side: THREE.BackSide,
                transparent: false
            });
            
            fractalMesh = new THREE.Mesh(geometry, fractalMaterial);
            scene.add(fractalMesh);
        }
        
        // Get optimized shader for fractal type
        function getFractalShader(type) {
            const shaders = {
                mandelbulb: `
                    precision highp float;
                    
                    uniform float time;
                    uniform float zoom;
                    uniform int detail;
                    uniform float colorScale;
                    uniform float power;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    // Optimized Mandelbulb DE
                    float mandelbulbDE(vec3 pos, int maxIter) {
                        vec3 z = pos;
                        float dr = 1.0;
                        float r = 0.0;
                        
                        for (int i = 0; i < 50; i++) {
                            if (i >= maxIter) break;
                            
                            r = length(z);
                            if (r > 2.0) break;
                            
                            // Spherical coordinates
                            float theta = acos(z.z / r);
                            float phi = atan(z.y, z.x);
                            dr = pow(r, power - 1.0) * power * dr + 1.0;
                            
                            float zr = pow(r, power);
                            theta = theta * power;
                            phi = phi * power;
                            
                            z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                            z += pos;
                        }
                        
                        return 0.5 * log(r) * r / dr;
                    }
                    
                    vec3 palette(float t) {
                        vec3 a = vec3(0.5, 0.5, 0.5);
                        vec3 b = vec3(0.5, 0.5, 0.5);
                        vec3 c = vec3(1.0, 1.0, 1.0);
                        vec3 d = vec3(0.0, 0.33, 0.67);
                        return a + b * cos(6.28318 * (c * t + d));
                    }
                    
                    void main() {
                        vec3 rayDir = normalize(vPosition);
                        vec3 rayOrigin = cameraPosition * zoom;
                        
                        float totalDist = 0.0;
                        vec3 pos = rayOrigin;
                        float dist = 0.0;
                        int steps = 0;
                        int maxSteps = detail * 2;
                        
                        for (int i = 0; i < 60; i++) {
                            if (i >= maxSteps) break;
                            steps = i;
                            dist = mandelbulbDE(pos, detail);
                            totalDist += dist;
                            pos += rayDir * dist;
                            
                            if (dist < 0.002) break;
                            if (totalDist > 15.0) break;
                        }
                        
                        // Simplified normal calculation
                        float eps = 0.001;
                        float d = mandelbulbDE(pos, detail);
                        vec3 normal = normalize(vec3(
                            mandelbulbDE(pos + vec3(eps, 0, 0), detail) - d,
                            mandelbulbDE(pos + vec3(0, eps, 0), detail) - d,
                            mandelbulbDE(pos + vec3(0, 0, eps), detail) - d
                        ));
                        
                        // Basic lighting
                        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                        float diffuse = max(dot(normal, lightDir), 0.1);
                        
                        // Color
                        float colorT = length(pos) * 0.3 + time * 0.1;
                        vec3 color = palette(colorT) * diffuse * colorScale;
                        
                        // Fog
                        float fog = exp(-totalDist * 0.1);
                        color = mix(vec3(0.0), color, fog);
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                
                menger: `
                    precision mediump float;
                    
                    uniform float time;
                    uniform float zoom;
                    uniform int detail;
                    uniform float colorScale;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    // Optimized Menger Sponge
                    float mengerDE(vec3 p, int iterations) {
                        p = abs(p);
                        if (p.x < p.y) p.xy = p.yx;
                        if (p.x < p.z) p.xz = p.zx;
                        if (p.y < p.z) p.yz = p.zy;
                        
                        p = p * 3.0 - vec3(2.0);
                        
                        float scale = 1.0;
                        for (int i = 0; i < 20; i++) {
                            if (i >= iterations) break;
                            
                            p = abs(p);
                            if (p.x < p.y) p.xy = p.yx;
                            if (p.x < p.z) p.xz = p.zx;
                            if (p.y < p.z) p.yz = p.zy;
                            
                            p = p * 3.0 - vec3(2.0);
                            scale *= 3.0;
                        }
                        
                        return length(p) / scale;
                    }
                    
                    void main() {
                        vec3 rayDir = normalize(vPosition);
                        vec3 rayOrigin = cameraPosition * zoom;
                        
                        float totalDist = 0.0;
                        vec3 pos = rayOrigin;
                        float dist = 0.0;
                        int steps = 0;
                        int maxSteps = detail;
                        
                        for (int i = 0; i < 40; i++) {
                            if (i >= maxSteps) break;
                            steps = i;
                            dist = mengerDE(pos, detail);
                            totalDist += dist;
                            pos += rayDir * dist;
                            
                            if (dist < 0.005) break;
                            if (totalDist > 10.0) break;
                        }
                        
                        vec3 color = vec3(1.0) * (1.0 - float(steps) / 40.0) * colorScale;
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                
                julia: `
                    precision highp float;
                    
                    uniform float time;
                    uniform float zoom;
                    uniform int detail;
                    uniform float colorScale;
                    uniform vec3 juliaC;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float juliaDE(vec3 pos, int maxIter) {
                        vec3 z = pos;
                        float dr = 1.0;
                        float r = 0.0;
                        vec3 c = juliaC + vec3(sin(time * 0.1) * 0.1, cos(time * 0.1) * 0.1, 0.0);
                        
                        for (int i = 0; i < 50; i++) {
                            if (i >= maxIter) break;
                            
                            r = length(z);
                            if (r > 2.0) break;
                            
                            float theta = acos(z.z / r);
                            float phi = atan(z.y, z.x);
                            dr = pow(r, 4.0 - 1.0) * 4.0 * dr + 1.0;
                            
                            float zr = pow(r, 4.0);
                            theta = theta * 4.0;
                            phi = phi * 4.0;
                            
                            z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                            z += c;
                        }
                        
                        return 0.5 * log(r) * r / dr;
                    }
                    
                    void main() {
                        vec3 rayDir = normalize(vPosition);
                        vec3 rayOrigin = cameraPosition * zoom;
                        
                        float totalDist = 0.0;
                        vec3 pos = rayOrigin;
                        float dist = 0.0;
                        int steps = 0;
                        int maxSteps = detail * 2;
                        
                        for (int i = 0; i < 60; i++) {
                            if (i >= maxSteps) break;
                            steps = i;
                            dist = juliaDE(pos, detail);
                            totalDist += dist;
                            pos += rayDir * dist;
                            
                            if (dist < 0.002) break;
                            if (totalDist > 15.0) break;
                        }
                        
                        vec3 color = vec3(
                            0.5 + 0.5 * cos(time + pos.x),
                            0.5 + 0.5 * cos(time + pos.y + 2.0),
                            0.5 + 0.5 * cos(time + pos.z + 4.0)
                        ) * colorScale * (1.0 - float(steps) / 60.0);
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                
                apollonian: `
                    precision mediump float;
                    
                    uniform float time;
                    uniform float zoom;
                    uniform int detail;
                    uniform float colorScale;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    float apollonianDE(vec3 p, int iterations) {
                        float scale = 2.0;
                        for (int i = 0; i < 20; i++) {
                            if (i >= iterations) break;
                            
                            p = 2.0 * clamp(p, -1.0, 1.0) - p;
                            float r2 = dot(p, p);
                            
                            if (r2 < 1.0) {
                                p /= r2;
                                scale *= r2;
                            }
                            
                            p = scale * p - vec3(1.5);
                        }
                        
                        return length(p) / abs(scale);
                    }
                    
                    void main() {
                        vec3 rayDir = normalize(vPosition);
                        vec3 rayOrigin = cameraPosition * zoom;
                        
                        float totalDist = 0.0;
                        vec3 pos = rayOrigin;
                        float dist = 0.0;
                        int steps = 0;
                        
                        for (int i = 0; i < 40; i++) {
                            if (i >= detail) break;
                            steps = i;
                            dist = apollonianDE(pos, detail);
                            totalDist += dist;
                            pos += rayDir * dist;
                            
                            if (dist < 0.005) break;
                            if (totalDist > 10.0) break;
                        }
                        
                        vec3 color = vec3(
                            0.7 + 0.3 * sin(time + pos.x * 5.0),
                            0.7 + 0.3 * sin(time + pos.y * 5.0 + 1.0),
                            0.7 + 0.3 * sin(time + pos.z * 5.0 + 2.0)
                        ) * colorScale;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            };
            
            return shaders[type] || shaders.mandelbulb;
        }
        
        function getFractalTypeIndex(type) {
            const types = ['mandelbulb', 'julia', 'menger', 'apollonian', 'quaternion', 'kleinian'];
            return types.indexOf(type);
        }
        
        function getFractalPower(type) {
            const powers = {
                mandelbulb: 8.0,
                julia: 4.0,
                menger: 3.0,
                apollonian: 2.0,
                quaternion: 8.0,
                kleinian: 4.0
            };
            return powers[type] || 8.0;
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
        }
        
        function initUI() {
            // Detail slider
            const detailSlider = document.getElementById('detail-slider');
            const detailValue = document.getElementById('detail-value');
            
            detailSlider.addEventListener('input', debounce(() => {
                const value = parseInt(detailSlider.value);
                detailValue.textContent = value;
                perf.detailLevel = value;
                
                if (fractalMaterial) {
                    fractalMaterial.uniforms.detail.value = value;
                }
                
                updateComplexity(value);
                updateIterationCount(value);
            }, 50));
            
            // Zoom slider
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValue = document.getElementById('zoom-value');
            
            zoomSlider.addEventListener('input', debounce(() => {
                const value = parseFloat(zoomSlider.value).toFixed(1);
                zoomValue.textContent = value;
            }, 50));
            
            // Animation slider
            const animSlider = document.getElementById('anim-slider');
            const animValue = document.getElementById('anim-value');
            
            animSlider.addEventListener('input', debounce(() => {
                const value = parseFloat(animSlider.value).toFixed(1);
                animValue.textContent = value;
            }, 50));
            
            // Color slider
            const colorSlider = document.getElementById('color-slider');
            const colorValue = document.getElementById('color-value');
            
            colorSlider.addEventListener('input', debounce(() => {
                const value = parseFloat(colorSlider.value).toFixed(1);
                colorValue.textContent = value;
                
                if (fractalMaterial) {
                    fractalMaterial.uniforms.colorScale.value = value;
                }
            }, 50));
            
            // Fractal selector
            document.querySelectorAll('.fractal-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.fractal-option').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    
                    currentFractal = option.dataset.type;
                    createFractal();
                    updateFractalType();
                });
            });
            
            // Play button
            const playBtn = document.getElementById('play-btn');
            playBtn.addEventListener('click', () => {
                autoPlay = !autoPlay;
                const icon = document.getElementById('play-icon');
                const text = document.getElementById('play-text');
                
                if (autoPlay) {
                    icon.textContent = '‚è∏';
                    text.textContent = 'Pause';
                } else {
                    icon.textContent = '‚ñ∂';
                    text.textContent = 'Auto Play';
                }
            });
            
            // Reset button
            document.getElementById('reset-btn').addEventListener('click', () => {
                zoomLevel = 1.0;
                animationTime = 0;
                
                if (fractalMaterial) {
                    fractalMaterial.uniforms.zoom.value = 1.0;
                }
                
                updateZoomDepth();
            });
            
            // Auto zoom button
            document.getElementById('auto-zoom-btn').addEventListener('click', () => {
                autoZoom = !autoZoom;
                const btn = document.getElementById('auto-zoom-btn');
                btn.innerHTML = autoZoom ? '<span>‚è∏</span> Stop Zoom' : '<span>‚ö°</span> Auto Zoom';
            });
            
            // Screenshot button
            document.getElementById('screenshot-btn').addEventListener('click', () => {
                renderer.domElement.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `fractal-${Date.now()}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            });
            
            // Performance button
            document.getElementById('performance-btn').addEventListener('click', () => {
                const modes = ['performance', 'balanced', 'quality'];
                const currentIndex = modes.indexOf(performanceMode);
                const nextIndex = (currentIndex + 1) % modes.length;
                performanceMode = modes[nextIndex];
                
                applyPerformanceMode();
                document.getElementById('render-mode').textContent = 
                    performanceMode.charAt(0).toUpperCase() + performanceMode.slice(1);
            });
            
            // Help button
            document.getElementById('help-btn').addEventListener('click', () => {
                alert(`Quantum Fractal Explorer Controls:
                
‚Ä¢ Click and drag to rotate view
‚Ä¢ Scroll or pinch to zoom
‚Ä¢ Auto Play: Automatically explores fractal
‚Ä¢ Use sliders to adjust detail and colors
‚Ä¢ Select different fractal types
‚Ä¢ Performance modes: Quality/Balanced/Performance
                
The system automatically adapts to your device for optimal performance.`);
            });
            
            // Touch controls for mobile
            if (isMobile) {
                document.getElementById('zoom-in').addEventListener('click', () => {
                    zoomLevel *= 0.9;
                    updateZoomDepth();
                });
                
                document.getElementById('zoom-out').addEventListener('click', () => {
                    zoomLevel *= 1.1;
                    updateZoomDepth();
                });
                
                document.getElementById('rotate-btn').addEventListener('click', () => {
                    if (fractalMesh) {
                        fractalMesh.rotation.y += 0.5;
                    }
                });
            }
        }
        
        function updateComplexity(detail) {
            const complexity = detail <= 8 ? 'Low' : detail <= 16 ? 'Medium' : 'High';
            document.getElementById('complexity').textContent = complexity;
        }
        
        function updateIterationCount(count) {
            document.getElementById('iter-count').textContent = count;
        }
        
        function updateZoomDepth() {
            document.getElementById('zoom-depth').textContent = zoomLevel.toFixed(1) + 'x';
            
            if (fractalMaterial) {
                fractalMaterial.uniforms.zoom.value = zoomLevel;
            }
        }
        
        function updateFractalType() {
            document.getElementById('iter-count').textContent = perf.detailLevel;
            
            // Update power if needed
            if (fractalMaterial && currentFractal === 'mandelbulb') {
                fractalMaterial.uniforms.power.value = getFractalPower(currentFractal);
            }
        }
        
        function applyPerformanceMode() {
            switch(performanceMode) {
                case 'performance':
                    perf.maxDetail = 16;
                    perf.adaptiveScale = 0.7;
                    if (fractalMesh && fractalMesh.geometry) {
                        fractalMesh.geometry.dispose();
                        fractalMesh.geometry = new THREE.SphereGeometry(1.8, 64, 32);
                    }
                    break;
                case 'balanced':
                    perf.maxDetail = 24;
                    perf.adaptiveScale = 1.0;
                    break;
                case 'quality':
                    perf.maxDetail = 32;
                    perf.adaptiveScale = 1.3;
                    break;
            }
            
            // Update detail slider max
            const detailSlider = document.getElementById('detail-slider');
            detailSlider.max = perf.maxDetail;
            
            if (parseInt(detailSlider.value) > perf.maxDetail) {
                detailSlider.value = perf.maxDetail;
                detailSlider.dispatchEvent(new Event('input'));
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Optimized animation loop with frame limiting
        function animate(currentTime = 0) {
            frameId = requestAnimationFrame(animate);
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = `${fps} FPS`;
            }
            
            // Adaptive performance adjustment
            if (CONFIG.ADAPTIVE_DETAIL && fps < 45) {
                perf.detailLevel = Math.max(4, perf.detailLevel - 2);
                if (fractalMaterial) {
                    fractalMaterial.uniforms.detail.value = perf.detailLevel;
                }
            } else if (CONFIG.ADAPTIVE_DETAIL && fps > 55 && perf.detailLevel < perf.maxDetail) {
                perf.detailLevel = Math.min(perf.maxDetail, perf.detailLevel + 1);
                if (fractalMaterial) {
                    fractalMaterial.uniforms.detail.value = perf.detailLevel;
                }
            }
            
            // Update animation time
            const delta = Math.min(0.1, (currentTime - lastTime) / 1000);
            animationTime += delta;
            
            // Update fractal uniforms
            if (fractalMaterial) {
                fractalMaterial.uniforms.time.value = animationTime;
                
                // Auto zoom
                if (autoZoom) {
                    zoomLevel = 1.0 + Math.sin(animationTime * 0.5) * 5;
                    updateZoomDepth();
                }
                
                // Auto play rotation
                if (autoPlay) {
                    fractalMesh.rotation.y += CONFIG.AUTO_PLAY_SPEED;
                    fractalMesh.rotation.x += CONFIG.AUTO_PLAY_SPEED * 0.5;
                }
            }
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Utility functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (frameId) {
                cancelAnimationFrame(frameId);
            }
            
            if (fractalMesh) {
                scene.remove(fractalMesh);
                fractalMesh.geometry.dispose();
                fractalMesh.material.dispose();
            }
            
            renderer.dispose();
        });
        
        // Prevent context menu on long press
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>