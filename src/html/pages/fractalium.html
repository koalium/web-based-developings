<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Fractal Evolution Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            --primary: #6a11cb;
            --secondary: #2575fc;
            --accent: #ff4e50;
            --success: #42e695;
            --warning: #ffb347;
            --danger: #ff416c;
            --bg-dark: #0a0e17;
            --bg-darker: #050811;
            --bg-light: #1a1f2e;
            --text-primary: #ffffff;
            --text-secondary: #a0aec0;
            --text-muted: #718096;
            --card-bg: rgba(26, 31, 46, 0.85);
            --border-color: rgba(255, 255, 255, 0.1);
            --glow-primary: 0 0 20px rgba(106, 17, 203, 0.5);
            --glow-secondary: 0 0 20px rgba(37, 117, 252, 0.5);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }
        
        /* Quantum particle background */
        .quantum-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
            pointer-events: none;
        }
        
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--primary);
            border-radius: 50%;
            animation: quantum-float 20s infinite linear;
        }
        
        @keyframes quantum-float {
            0%, 100% { transform: translate(0, 0); opacity: 0.3; }
            50% { transform: translate(100px, 100px); opacity: 1; }
        }
        
        .header {
            padding: 1.5rem 2rem;
            background: rgba(10, 14, 23, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 10;
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1.5rem;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            animation: quantum-spin 10s linear infinite;
        }
        
        @keyframes quantum-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .logo-text h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: 700;
        }
        
        .logo-text p {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .stats-bar {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--card-bg);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .stat-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--success);
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .main-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 2rem;
            min-height: calc(100vh - 200px);
        }
        
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
                padding: 0 1rem;
            }
        }
        
        .visualization-area {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            box-shadow: var(--glow-primary);
            min-height: 600px;
        }
        
        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #fractalCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .visualization-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        .rendering-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1rem;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
        }
        
        .progress-track {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.4), 
                transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }
        
        .control-panel {
            background: var(--card-bg);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(10px);
            overflow: hidden;
            height: fit-content;
        }
        
        .panel-section {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .section-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fractal-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }
        
        .fractal-card {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .fractal-card:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary);
            transform: translateY(-2px);
        }
        
        .fractal-card.active {
            background: linear-gradient(135deg, 
                rgba(106, 17, 203, 0.2), 
                rgba(37, 117, 252, 0.2));
            border-color: var(--primary);
            box-shadow: 0 5px 20px rgba(106, 17, 203, 0.3);
        }
        
        .fractal-icon {
            width: 40px;
            height: 40px;
            margin: 0 auto 0.75rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }
        
        .fractal-name {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .fractal-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .slider-group {
            margin-bottom: 1.5rem;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .slider-value {
            color: var(--success);
            font-weight: 600;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            cursor: pointer;
            border: 3px solid var(--bg-dark);
            box-shadow: 0 0 10px rgba(106, 17, 203, 0.5);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(106, 17, 203, 0.7);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
            margin-top: 1.5rem;
        }
        
        .btn {
            padding: 0.875rem 1rem;
            border: none;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(106, 17, 203, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #ff6b6b);
            color: white;
        }
        
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
            background: linear-gradient(90deg, var(--success), #42e695);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .metric-trend {
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }
        
        .trend-up { color: var(--success); }
        .trend-down { color: var(--danger); }
        .trend-stable { color: var(--warning); }
        
        .evolution-status {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(66, 230, 149, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(66, 230, 149, 0.3);
        }
        
        .status-text {
            font-size: 0.9rem;
            color: var(--success);
            margin-bottom: 0.5rem;
        }
        
        .status-details {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .quantum-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
        }
        
        .quantum-spinner {
            width: 60px;
            height: 60px;
            margin: 0 auto 1rem;
            position: relative;
        }
        
        .quantum-spinner::before,
        .quantum-spinner::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: var(--primary);
            animation: quantum-spin 1s linear infinite;
        }
        
        .quantum-spinner::before {
            width: 100%;
            height: 100%;
            border-top-color: var(--primary);
            animation-delay: 0.1s;
        }
        
        .quantum-spinner::after {
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border-top-color: var(--secondary);
            animation-delay: 0.2s;
        }
        
        .notification {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            max-width: 300px;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification-success {
            border-left: 4px solid var(--success);
        }
        
        .notification-warning {
            border-left: 4px solid var(--warning);
        }
        
        .notification-error {
            border-left: 4px solid var(--danger);
        }
        
        .notification-info {
            border-left: 4px solid var(--secondary);
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }
        
        .notification-message {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .visualization-hints {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 3;
        }
        
        .hint-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .hint {
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            pointer-events: auto;
        }
        
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
            }
            
            .stats-bar {
                justify-content: center;
            }
            
            .main-container {
                margin: 1rem auto;
                padding: 0 1rem;
            }
            
            .visualization-hints {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
        
        /* Quantum wave animation */
        .wave-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            overflow: hidden;
            opacity: 0.3;
            pointer-events: none;
        }
        
        .wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                var(--primary), 
                transparent);
            animation: wave-flow 10s linear infinite;
            mask-image: linear-gradient(transparent, black);
        }
        
        @keyframes wave-flow {
            0% { transform: translateX(-50%); }
            100% { transform: translateX(0); }
        }
        
        .fractal-complexity {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
            backdrop-filter: blur(10px);
        }
        
        .complexity-value {
            color: var(--success);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- Quantum Background -->
    <div class="quantum-bg" id="quantumBg"></div>
    
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">‚öõ</div>
                <div class="logo-text">
                    <h1>Quantum Fractal Evolution</h1>
                    <p>Real-time adaptive rendering with predictive optimization</p>
                </div>
            </div>
            
            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="fpsCounter">60</div>
                    <div class="stat-label">FPS</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="renderTime">16ms</div>
                    <div class="stat-label">Render Time</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="quantumState">|œà‚ü©</div>
                    <div class="stat-label">Quantum State</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Visualization Area -->
        <div class="visualization-area">
            <div class="canvas-container">
                <canvas id="fractalCanvas"></canvas>
                <div class="visualization-overlay">
                    <div class="visualization-hints">
                        <div class="hint-group">
                            <div class="hint">Drag to rotate</div>
                            <div class="hint">Scroll to zoom</div>
                            <div class="hint">Shift + Drag to pan</div>
                        </div>
                        <div class="fractal-complexity">
                            Complexity: <span class="complexity-value" id="complexityValue">1.2M</span> iterations
                        </div>
                    </div>
                    
                    <div class="rendering-progress">
                        <div id="renderStatus">Quantum rendering initialized</div>
                        <div class="progress-track">
                            <div class="progress-fill" id="renderProgress"></div>
                        </div>
                    </div>
                    
                    <div class="wave-container">
                        <div class="wave"></div>
                    </div>
                </div>
            </div>
            
            <div class="quantum-loader" id="quantumLoader">
                <div class="quantum-spinner"></div>
                <div id="loaderText">Initializing quantum renderer...</div>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <!-- Fractal Selection -->
            <div class="panel-section">
                <div class="section-title">
                    <div class="section-icon">üåÄ</div>
                    <span>Quantum Fractal Types</span>
                </div>
                
                <div class="fractal-grid">
                    <div class="fractal-card active" data-type="mandelbulb">
                        <div class="fractal-icon">‚ö°</div>
                        <div class="fractal-name">Mandelbulb</div>
                        <div class="fractal-desc">3D Mandelbrot set</div>
                    </div>
                    <div class="fractal-card" data-type="quaternion">
                        <div class="fractal-icon">üî¢</div>
                        <div class="fractal-name">Quaternion</div>
                        <div class="fractal-desc">4D hypercomplex</div>
                    </div>
                    <div class="fractal-card" data-type="julia">
                        <div class="fractal-icon">üé≠</div>
                        <div class="fractal-name">Julia Set</div>
                        <div class="fractal-desc">Complex dynamics</div>
                    </div>
                    <div class="fractal-card" data-type="quantum">
                        <div class="fractal-icon">‚öõ</div>
                        <div class="fractal-name">Quantum Wave</div>
                        <div class="fractal-desc">Wave function collapse</div>
                    </div>
                    <div class="fractal-card" data-type="lorenz">
                        <div class="fractal-icon">üå™</div>
                        <div class="fractal-name">Lorenz</div>
                        <div class="fractal-desc">Chaotic attractor</div>
                    </div>
                    <div class="fractal-card" data-type="sierpinski">
                        <div class="fractal-icon">üî∫</div>
                        <div class="fractal-name">Sierpinski 4D</div>
                        <div class="fractal-desc">Hyper-tetrahedron</div>
                    </div>
                </div>
            </div>
            
            <!-- Rendering Controls -->
            <div class="panel-section">
                <div class="section-title">
                    <div class="section-icon">‚öôÔ∏è</div>
                    <span>Quantum Rendering Engine</span>
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Quantum Depth</span>
                        <span class="slider-value" id="depthValue">128</span>
                    </div>
                    <input type="range" id="depthSlider" min="32" max="512" value="128" step="32">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Temporal Resolution</span>
                        <span class="slider-value" id="resolutionValue">High</span>
                    </div>
                    <input type="range" id="resolutionSlider" min="1" max="5" value="3" step="1">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Quantum Entanglement</span>
                        <span class="slider-value" id="entanglementValue">0.75</span>
                    </div>
                    <input type="range" id="entanglementSlider" min="0" max="1" value="0.75" step="0.01">
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="evolveBtn">
                        <span>‚èµ</span> Evolve
                    </button>
                    <button class="btn btn-secondary" id="pauseBtn">
                        <span>‚è∏</span> Pause
                    </button>
                    <button class="btn btn-danger" id="resetBtn">
                        <span>‚Ü∫</span> Reset
                    </button>
                </div>
            </div>
            
            <!-- Performance Monitor -->
            <div class="panel-section">
                <div class="section-title">
                    <div class="section-icon">üìä</div>
                    <span>Quantum Performance</span>
                </div>
                
                <div class="performance-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="cpuMetric">15%</div>
                        <div class="metric-label">CPU Load</div>
                        <div class="metric-trend trend-stable" id="cpuTrend">¬±2%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="gpuMetric">28%</div>
                        <div class="metric-label">GPU Load</div>
                        <div class="metric-trend trend-down" id="gpuTrend">-5%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="memoryMetric">42%</div>
                        <div class="metric-label">Memory</div>
                        <div class="metric-trend trend-stable" id="memoryTrend">¬±1%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="qualityMetric">94%</div>
                        <div class="metric-label">Quality</div>
                        <div class="metric-trend trend-up" id="qualityTrend">+3%</div>
                    </div>
                </div>
                
                <div class="evolution-status">
                    <div class="status-text" id="evolutionStatus">Quantum evolution stable</div>
                    <div class="status-details" id="evolutionDetails">Adaptive rendering at 60 FPS</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification System -->
    <div class="notification" id="notification">
        <div class="notification-title" id="notificationTitle">System Ready</div>
        <div class="notification-message" id="notificationMessage">Quantum renderer initialized successfully</div>
    </div>
    
    <script>
        class QuantumFractalEngine {
            constructor() {
                this.canvas = document.getElementById('fractalCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.performance = this.initPerformance();
                this.state = this.initState();
                this.renderer = this.initRenderer();
                this.ui = this.initUI();
                this.quantum = this.initQuantum();
                this.evolution = this.initEvolution();
                
                this.init();
            }
            
            initPerformance() {
                return {
                    fps: 60,
                    frameTime: 16,
                    cpuLoad: 15,
                    gpuLoad: 28,
                    memory: 42,
                    quality: 94,
                    lastFrameTime: performance.now(),
                    frameCount: 0,
                    metrics: {
                        cpu: [],
                        gpu: [],
                        memory: [],
                        quality: []
                    },
                    stability: 1.0,
                    loadFactor: 0.5
                };
            }
            
            initState() {
                return {
                    fractalType: 'mandelbulb',
                    depth: 128,
                    resolution: 3,
                    entanglement: 0.75,
                    zoom: 1.0,
                    rotation: { x: 0, y: 0, z: 0 },
                    position: { x: 10, y: 10, z: 20 },
                    autoEvolve: true,
                    isRendering: true,
                    progressive: true,
                    quantumState: 0,
                    iteration: 0,
                    complexity: 1200000
                };
            }
            
            initRenderer() {
                const renderer = {
                    workers: [],
                    workQueue: [],
                    renderBuffer: null,
                    timeSlice: 8, // ms per frame
                    lastSlice: 0,
                    progressiveSteps: 0
                };
                
                // Create Web Worker for fractal computation
                if (window.Worker) {
                    for (let i = 0; i < 4; i++) {
                        const worker = new Worker(URL.createObjectURL(
                            new Blob([`(${this.workerFunction.toString()})()`], 
                            { type: 'application/javascript' })
                        ));
                        renderer.workers.push({
                            worker,
                            busy: false,
                            id: i
                        });
                    }
                }
                
                return renderer;
            }
            
            workerFunction() {
                self.onmessage = function(e) {
                    const { type, data } = e.data;
                    
                    switch(type) {
                        case 'mandelbulb':
                            const result = computeMandelbulb(data);
                            self.postMessage({ id: data.id, result });
                            break;
                    }
                };
                
                function computeMandelbulb(data) {
                    const { width, height, depth, params } = data;
                    const pixels = new Uint8ClampedArray(width * height * 4);
                    
                    // Simplified computation for worker
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = (y * width + x) * 4;
                            const t = (x + y) / (width + height);
                            
                            pixels[idx] = Math.sin(t * Math.PI * 2) * 255;
                            pixels[idx + 1] = Math.cos(t * Math.PI * 2) * 255;
                            pixels[idx + 2] = t * 255;
                            pixels[idx + 3] = 255;
                        }
                    }
                    
                    return pixels;
                }
            }
            
            initQuantum() {
                return {
                    particles: [],
                    waveFunction: null,
                    collapse: false,
                    entanglement: 0.75,
                    superposition: true,
                    decoherence: 0.01,
                    phase: 0
                };
            }
            
            initEvolution() {
                return {
                    generation: 0,
                    fitness: 0,
                    mutations: 0,
                    convergence: 0,
                    history: [],
                    optimization: {
                        depth: { current: 128, target: 128, rate: 0.1 },
                        resolution: { current: 3, target: 3, rate: 0.05 },
                        quality: { current: 94, target: 94, rate: 0.02 }
                    }
                };
            }
            
            initUI() {
                return {
                    elements: this.bindUIElements(),
                    notifications: [],
                    lastNotification: 0
                };
            }
            
            bindUIElements() {
                return {
                    fpsCounter: document.getElementById('fpsCounter'),
                    renderTime: document.getElementById('renderTime'),
                    quantumState: document.getElementById('quantumState'),
                    complexityValue: document.getElementById('complexityValue'),
                    depthValue: document.getElementById('depthValue'),
                    resolutionValue: document.getElementById('resolutionValue'),
                    entanglementValue: document.getElementById('entanglementValue'),
                    cpuMetric: document.getElementById('cpuMetric'),
                    gpuMetric: document.getElementById('gpuMetric'),
                    memoryMetric: document.getElementById('memoryMetric'),
                    qualityMetric: document.getElementById('qualityMetric'),
                    cpuTrend: document.getElementById('cpuTrend'),
                    gpuTrend: document.getElementById('gpuTrend'),
                    memoryTrend: document.getElementById('memoryTrend'),
                    qualityTrend: document.getElementById('qualityTrend'),
                    evolutionStatus: document.getElementById('evolutionStatus'),
                    evolutionDetails: document.getElementById('evolutionDetails'),
                    renderStatus: document.getElementById('renderStatus'),
                    renderProgress: document.getElementById('renderProgress'),
                    quantumLoader: document.getElementById('quantumLoader'),
                    loaderText: document.getElementById('loaderText'),
                    notification: document.getElementById('notification'),
                    notificationTitle: document.getElementById('notificationTitle'),
                    notificationMessage: document.getElementById('notificationMessage')
                };
            }
            
            async init() {
                await this.setupCanvas();
                this.setupEventListeners();
                this.createQuantumBackground();
                this.startEvolution();
                this.showNotification('Quantum Engine Ready', 'Fractal evolution initialized successfully', 'success');
                this.updateLoader('Starting quantum renderer...', 0);
                
                // Progressive loading
                setTimeout(() => this.updateLoader('Loading fractal algorithms...', 25), 500);
                setTimeout(() => this.updateLoader('Initializing quantum states...', 50), 1000);
                setTimeout(() => this.updateLoader('Calibrating performance...', 75), 1500);
                setTimeout(() => this.updateLoader('Ready for exploration', 100), 2000);
                setTimeout(() => this.hideLoader(), 2500);
                
                this.animate();
            }
            
            async setupCanvas() {
                const dpr = Math.min(window.devicePixelRatio, 2);
                this.canvas.width = this.canvas.clientWidth * dpr;
                this.canvas.height = this.canvas.clientHeight * dpr;
                this.ctx.scale(dpr, dpr);
                
                // Create gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#0a0e17');
                gradient.addColorStop(1, '#1a1f2e');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            setupEventListeners() {
                // Fractal selection
                document.querySelectorAll('.fractal-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        document.querySelectorAll('.fractal-card').forEach(c => c.classList.remove('active'));
                        card.classList.add('active');
                        this.state.fractalType = card.dataset.type;
                        this.resetEvolution();
                        this.showNotification('Fractal Changed', `Now rendering ${card.querySelector('.fractal-name').textContent}`, 'info');
                    });
                });
                
                // Sliders
                document.getElementById('depthSlider').addEventListener('input', (e) => {
                    this.state.depth = parseInt(e.target.value);
                    this.ui.elements.depthValue.textContent = this.state.depth;
                    this.evolution.optimization.depth.target = this.state.depth;
                });
                
                document.getElementById('resolutionSlider').addEventListener('input', (e) => {
                    this.state.resolution = parseInt(e.target.value);
                    const resolutions = ['Very Low', 'Low', 'Medium', 'High', 'Ultra'];
                    this.ui.elements.resolutionValue.textContent = resolutions[this.state.resolution - 1];
                    this.evolution.optimization.resolution.target = this.state.resolution;
                });
                
                document.getElementById('entanglementSlider').addEventListener('input', (e) => {
                    this.state.entanglement = parseFloat(e.target.value);
                    this.ui.elements.entanglementValue.textContent = this.state.entanglement.toFixed(2);
                    this.quantum.entanglement = this.state.entanglement;
                });
                
                // Buttons
                document.getElementById('evolveBtn').addEventListener('click', () => {
                    this.state.autoEvolve = !this.state.autoEvolve;
                    const btn = document.getElementById('evolveBtn');
                    btn.innerHTML = this.state.autoEvolve ? 
                        '<span>‚è∏</span> Pause Evolution' : 
                        '<span>‚èµ</span> Evolve';
                    this.showNotification(
                        this.state.autoEvolve ? 'Evolution Resumed' : 'Evolution Paused',
                        this.state.autoEvolve ? 'Fractal will continue evolving' : 'Fractal evolution paused',
                        this.state.autoEvolve ? 'success' : 'warning'
                    );
                });
                
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.state.isRendering = !this.state.isRendering;
                    const btn = document.getElementById('pauseBtn');
                    btn.innerHTML = this.state.isRendering ? 
                        '<span>‚è∏</span> Pause Rendering' : 
                        '<span>‚èµ</span> Resume Rendering';
                    this.showNotification(
                        this.state.isRendering ? 'Rendering Resumed' : 'Rendering Paused',
                        this.state.isRendering ? 'Real-time rendering enabled' : 'Rendering paused to save resources',
                        this.state.isRendering ? 'success' : 'warning'
                    );
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetState();
                    this.showNotification('State Reset', 'All parameters reset to defaults', 'info');
                });
                
                // Mouse controls
                let isDragging = false;
                let lastX = 0;
                let lastY = 0;
                
                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    this.canvas.style.cursor = 'grabbing';
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    
                    if (!e.shiftKey) {
                        // Pan
                        this.state.position.x += dx * 0.01;
                        this.state.position.y -= dy * 0.01;
                    } else {
                        // Rotate
                        this.state.rotation.y += dx * 0.01;
                        this.state.rotation.x += dy * 0.01;
                    }
                    
                    lastX = e.clientX;
                    lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = 0.1;
                    this.state.zoom *= e.deltaY > 0 ? 1 - zoomFactor : 1 + zoomFactor;
                    this.state.zoom = Math.max(0.1, Math.min(10, this.state.zoom));
                    this.showNotification('Zoom Adjusted', `Current zoom: ${this.state.zoom.toFixed(1)}x`, 'info');
                });
                
                // Touch controls
                this.canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        isDragging = true;
                        lastX = e.touches[0].clientX;
                        lastY = e.touches[0].clientY;
                    }
                    e.preventDefault();
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    if (!isDragging || e.touches.length !== 1) return;
                    
                    const dx = e.touches[0].clientX - lastX;
                    const dy = e.touches[0].clientY - lastY;
                    
                    this.state.rotation.y += dx * 0.01;
                    this.state.rotation.x += dy * 0.01;
                    
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    e.preventDefault();
                });
                
                this.canvas.addEventListener('touchend', () => {
                    isDragging = false;
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.showNotification('Canvas Resized', 'Resolution adjusted for new window size', 'info');
                });
            }
            
            createQuantumBackground() {
                const bg = document.getElementById('quantumBg');
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.top = `${Math.random() * 100}%`;
                    particle.style.animationDelay = `${Math.random() * 20}s`;
                    particle.style.background = i % 2 === 0 ? 
                        'linear-gradient(135deg, var(--primary), transparent)' :
                        'linear-gradient(135deg, var(--secondary), transparent)';
                    bg.appendChild(particle);
                }
            }
            
            updateLoader(text, progress) {
                this.ui.elements.loaderText.textContent = text;
                this.ui.elements.renderProgress.style.width = `${progress}%`;
            }
            
            hideLoader() {
                this.ui.elements.quantumLoader.style.opacity = '0';
                setTimeout(() => {
                    this.ui.elements.quantumLoader.style.display = 'none';
                }, 300);
            }
            
            showNotification(title, message, type = 'info') {
                const now = performance.now();
                if (now - this.ui.lastNotification < 2000) return;
                
                this.ui.lastNotification = now;
                
                const notification = this.ui.elements.notification;
                notification.className = `notification notification-${type}`;
                this.ui.elements.notificationTitle.textContent = title;
                this.ui.elements.notificationMessage.textContent = message;
                
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
            
            startEvolution() {
                // Start evolutionary optimization loop
                setInterval(() => {
                    if (!this.state.autoEvolve) return;
                    
                    this.evolution.generation++;
                    
                    // Update optimization targets based on performance
                    this.updateEvolution();
                    
                    // Occasionally mutate parameters
                    if (Math.random() < 0.1) {
                        this.mutateParameters();
                    }
                    
                }, 5000); // Evolve every 5 seconds
            }
            
            updateEvolution() {
                // Adjust optimization targets based on performance
                const perf = this.performance;
                
                // If performance is good, increase quality targets
                if (perf.fps > 55 && perf.frameTime < 18) {
                    this.evolution.optimization.quality.target = Math.min(100, 
                        this.evolution.optimization.quality.target + 1);
                    this.evolution.optimization.depth.target = Math.min(512,
                        this.evolution.optimization.depth.target + 32);
                } else if (perf.fps < 30 || perf.frameTime > 33) {
                    // If performance is poor, reduce targets
                    this.evolution.optimization.quality.target = Math.max(50,
                        this.evolution.optimization.quality.target - 2);
                    this.evolution.optimization.depth.target = Math.max(32,
                        this.evolution.optimization.depth.target - 32);
                }
                
                // Gradually move current values toward targets
                for (const key in this.evolution.optimization) {
                    const opt = this.evolution.optimization[key];
                    const diff = opt.target - opt.current;
                    opt.current += diff * opt.rate;
                    
                    // Update state if changed significantly
                    if (Math.abs(diff) > 1) {
                        switch(key) {
                            case 'depth':
                                this.state.depth = Math.round(opt.current);
                                this.ui.elements.depthValue.textContent = this.state.depth;
                                document.getElementById('depthSlider').value = this.state.depth;
                                break;
                            case 'resolution':
                                this.state.resolution = Math.round(opt.current);
                                const resolutions = ['Very Low', 'Low', 'Medium', 'High', 'Ultra'];
                                this.ui.elements.resolutionValue.textContent = resolutions[this.state.resolution - 1];
                                document.getElementById('resolutionSlider').value = this.state.resolution;
                                break;
                        }
                    }
                }
                
                // Update UI
                this.updateEvolutionUI();
            }
            
            mutateParameters() {
                this.evolution.mutations++;
                
                // Randomly adjust entanglement
                if (Math.random() < 0.3) {
                    const newEntanglement = Math.max(0, Math.min(1, 
                        this.state.entanglement + (Math.random() - 0.5) * 0.2));
                    this.state.entanglement = parseFloat(newEntanglement.toFixed(2));
                    this.quantum.entanglement = this.state.entanglement;
                    this.ui.elements.entanglementValue.textContent = this.state.entanglement.toFixed(2);
                    document.getElementById('entanglementSlider').value = this.state.entanglement;
                }
                
                this.showNotification('Quantum Mutation', 'Fractal parameters evolved', 'info');
            }
            
            updateEvolutionUI() {
                const status = this.getEvolutionStatus();
                this.ui.elements.evolutionStatus.textContent = status.message;
                this.ui.elements.evolutionDetails.textContent = status.details;
                
                // Update trends
                const trends = this.calculateTrends();
                this.ui.elements.cpuTrend.textContent = trends.cpu;
                this.ui.elements.gpuTrend.textContent = trends.gpu;
                this.ui.elements.memoryTrend.textContent = trends.memory;
                this.ui.elements.qualityTrend.textContent = trends.quality;
                
                // Update trend colors
                ['cpu', 'gpu', 'memory', 'quality'].forEach(metric => {
                    const element = this.ui.elements[`${metric}Trend`];
                    const value = trends[metric];
                    element.className = 'metric-trend ' + (
                        value.startsWith('+') ? 'trend-up' :
                        value.startsWith('-') ? 'trend-down' : 'trend-stable'
                    );
                });
            }
            
            getEvolutionStatus() {
                const perf = this.performance;
                
                if (perf.fps >= 55 && perf.quality >= 90) {
                    return {
                        message: 'Quantum evolution optimal',
                        details: `Stable at ${Math.round(perf.fps)} FPS with ${perf.quality}% quality`
                    };
                } else if (perf.fps >= 45 && perf.quality >= 80) {
                    return {
                        message: 'Quantum evolution stable',
                        details: `Balanced at ${Math.round(perf.fps)} FPS`
                    };
                } else if (perf.fps >= 30) {
                    return {
                        message: 'Quantum evolution adapting',
                        details: 'Adjusting parameters for optimal performance'
                    };
                } else {
                    return {
                        message: 'Quantum evolution throttled',
                        details: 'Reduced quality to maintain stability'
                    };
                }
            }
            
            calculateTrends() {
                const metrics = this.performance.metrics;
                
                const getTrend = (array) => {
                    if (array.length < 2) return '¬±0%';
                    const recent = array.slice(-5);
                    const avg = recent.reduce((a, b) => a + b, 0) / recent.length;
                    const change = avg - (array[array.length - 6] || avg);
                    if (Math.abs(change) < 0.5) return '¬±0%';
                    return (change > 0 ? '+' : '') + change.toFixed(0) + '%';
                };
                
                return {
                    cpu: getTrend(metrics.cpu),
                    gpu: getTrend(metrics.gpu),
                    memory: getTrend(metrics.memory),
                    quality: getTrend(metrics.quality)
                };
            }
            
            updatePerformanceMetrics() {
                const now = performance.now();
                const delta = now - this.performance.lastFrameTime;
                
                this.performance.frameCount++;
                
                if (delta >= 1000) {
                    this.performance.fps = Math.round((this.performance.frameCount * 1000) / delta);
                    this.performance.lastFrameTime = now;
                    this.performance.frameCount = 0;
                    
                    // Simulate realistic performance metrics
                    this.performance.cpuLoad = 10 + Math.sin(this.state.iteration * 0.01) * 10 + Math.random() * 5;
                    this.performance.gpuLoad = 25 + Math.cos(this.state.iteration * 0.015) * 15 + Math.random() * 8;
                    this.performance.memory = 40 + Math.sin(this.state.iteration * 0.005) * 10 + Math.random() * 3;
                    
                    // Update metrics history
                    this.performance.metrics.cpu.push(this.performance.cpuLoad);
                    this.performance.metrics.gpu.push(this.performance.gpuLoad);
                    this.performance.metrics.memory.push(this.performance.memory);
                    this.performance.metrics.quality.push(this.performance.quality);
                    
                    // Keep history manageable
                    ['cpu', 'gpu', 'memory', 'quality'].forEach(metric => {
                        if (this.performance.metrics[metric].length > 60) {
                            this.performance.metrics[metric].shift();
                        }
                    });
                    
                    // Update UI
                    this.updatePerformanceUI();
                }
                
                // Update frame time
                const frameTime = now - (this.state.lastRenderTime || now);
                this.performance.frameTime = Math.round(frameTime);
                this.state.lastRenderTime = now;
            }
            
            updatePerformanceUI() {
                this.ui.elements.fpsCounter.textContent = this.performance.fps;
                this.ui.elements.renderTime.textContent = this.performance.frameTime + 'ms';
                this.ui.elements.cpuMetric.textContent = Math.round(this.performance.cpuLoad) + '%';
                this.ui.elements.gpuMetric.textContent = Math.round(this.performance.gpuLoad) + '%';
                this.ui.elements.memoryMetric.textContent = Math.round(this.performance.memory) + '%';
                this.ui.elements.qualityMetric.textContent = Math.round(this.performance.quality) + '%';
                
                // Update quantum state display
                const states = ['|œà‚ü©', '|œÜ‚ü©', '|œá‚ü©', '|œâ‚ü©', '|Œ∏‚ü©'];
                this.state.quantumState = (this.state.quantumState + 1) % states.length;
                this.ui.elements.quantumState.textContent = states[this.state.quantumState];
                
                // Update complexity
                const complexity = 500000 + Math.sin(this.state.iteration * 0.01) * 700000;
                this.state.complexity = Math.round(complexity);
                this.ui.elements.complexityValue.textContent = (this.state.complexity / 1000000).toFixed(1) + 'M';
            }
            
            resetState() {
                this.state = this.initState();
                this.evolution = this.initEvolution();
                
                // Reset UI
                this.ui.elements.depthValue.textContent = this.state.depth;
                document.getElementById('depthSlider').value = this.state.depth;
                
                this.ui.elements.resolutionValue.textContent = 'High';
                document.getElementById('resolutionSlider').value = 3;
                
                this.ui.elements.entanglementValue.textContent = this.state.entanglement.toFixed(2);
                document.getElementById('entanglementSlider').value = this.state.entanglement;
                
                document.getElementById('evolveBtn').innerHTML = '<span>‚èµ</span> Evolve';
                document.getElementById('pauseBtn').innerHTML = '<span>‚è∏</span> Pause Rendering';
                
                this.state.autoEvolve = true;
                this.state.isRendering = true;
            }
            
            resetEvolution() {
                this.evolution.generation = 0;
                this.evolution.mutations = 0;
                this.evolution.convergence = 0;
                this.evolution.history = [];
            }
            
            renderFractal() {
                if (!this.state.isRendering) return;
                
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Clear with gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#0a0e17');
                gradient.addColorStop(1, '#1a1f2e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Draw based on fractal type
                switch(this.state.fractalType) {
                    case 'mandelbulb':
                        this.renderMandelbulb(ctx, width, height);
                        break;
                    case 'julia':
                        this.renderJuliaSet(ctx, width, height);
                        break;
                    case 'quantum':
                        this.renderQuantumWave(ctx, width, height);
                        break;
                    case 'sierpinski':
                        this.renderSierpinski(ctx, width, height);
                        break;
                    default:
                        this.renderGenericFractal(ctx, width, height);
                }
                
                // Update iteration counter
                this.state.iteration++;
            }
            
            renderMandelbulb(ctx, width, height) {
                const centerX = width / 3;
                const centerY = height / 4;
                const scale = 150 * this.state.zoom;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.state.rotation.y);
                
                const time = this.state.iteration * 0.01;
                
                for (let i = 0; i < 1000; i++) {
                    const angle = (i * Math.PI * 2) / 100;
                    const radius = 50 + Math.sin(time + i * 0.1) * 20;
                    
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius * Math.cos(time);
                    const z = Math.sin(time + i * 0.05) * 30;
                    
                    const depth = Math.abs(z) / 100;
                    const size = 10 * (1 - depth);
                    
                    // Create gradient for each point
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                    gradient.addColorStop(0, `rgba(106, 17, 203, ${0.8 - depth})`);
                    gradient.addColorStop(1, `rgba(37, 117, 252, ${0.3 - depth})`);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowColor = 'rgba(106, 17, 203, 0.5)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            }
            
            renderJuliaSet(ctx, width, height) {
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                
                const maxIterations = this.state.depth;
                const zoom = this.state.zoom * 2;
                const time = this.state.iteration * 0.005;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const cx = (x - width/2) / (0.5 * zoom * width) - 0.7;
                        const cy = (y - height/2) / (0.5 * zoom * height);
                        
                        let zx = cx;
                        let zy = cy;
                        let iteration = 0;
                        
                        while (iteration < maxIterations) {
                            const x2 = zx * zx;
                            const y2 = zy * zy;
                            
                            if (x2 + y2 > 4) break;
                            
                            const newX = x2 - y2 - 0.7 + Math.sin(time) * 0.1;
                            const newY = 2 * zx * zy + 0.27015 + Math.cos(time) * 0.1;
                            
                            zx = newX;
                            zy = newY;
                            iteration++;
                        }
                        
                        const idx = (y * width + x) * 4;
                        const t = iteration / maxIterations;
                        
                        // Quantum-inspired color mapping
                        const r = Math.sin(t * Math.PI * 2 + time) * 127 + 128;
                        const g = Math.cos(t * Math.PI * 3 + time * 1.5) * 127 + 128;
                        const b = Math.sin(t * Math.PI * 4 + time * 2) * 127 + 128;
                        
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            renderQuantumWave(ctx, width, height) {
                const time = this.state.iteration * 0.01;
                
                ctx.save();
                ctx.translate(width / 4, height / 4);
                
                // Draw wave interference pattern
                for (let i = 0; i < 20; i++) {
                    const phase = i * Math.PI / 10 + time;
                    const amplitude = 100 * Math.sin(phase * 0.5);
                    
                    ctx.beginPath();
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.01) {
                        const r = 150 + Math.sin(angle * 5 + phase) * amplitude;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        
                        if (angle === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    // Quantum color gradient
                    const gradient = ctx.createLinearGradient(-200, -200, 200, 200);
                    gradient.addColorStop(0, `rgba(66, 230, 149, ${0.3 - i * 0.01})`);
                    gradient.addColorStop(0.5, `rgba(37, 117, 252, ${0.5 - i * 0.01})`);
                    gradient.addColorStop(1, `rgba(106, 17, 203, ${0.3 - i * 0.01})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            renderSierpinski(ctx, width, height) {
                const depth = Math.min(7, Math.floor(this.state.depth / 20));
                
                function drawTriangle(x, y, size, depth, maxDepth) {
                    if (depth <= 0) return;
                    
                    // Draw triangle
                    ctx.beginPath();
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x - size, y + size);
                    ctx.lineTo(x + size, y + size);
                    ctx.closePath();
                    
                    // Color based on depth
                    const hue = 200 + (maxDepth - depth) * 30;
                    ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${0.1 + depth * 0.1})`;
                    ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.3)`;
                    ctx.lineWidth = 1;
                    
                    ctx.fill();
                    ctx.stroke();
                    
                    // Recursive calls
                    if (depth > 1) {
                        const newSize = size / 2;
                        drawTriangle(x, y - newSize, newSize, depth - 1, maxDepth);
                        drawTriangle(x - newSize, y + newSize, newSize, depth - 1, maxDepth);
                        drawTriangle(x + newSize, y + newSize, newSize, depth - 1, maxDepth);
                    }
                }
                
                ctx.save();
                ctx.translate(width / 4, height / 4);
                ctx.rotate(this.state.rotation.y);
                
                drawTriangle(0, 0, 150, depth, depth);
                
                ctx.restore();
            }
            
            renderGenericFractal(ctx, width, height) {
                const time = this.state.iteration * 0.005;
                const centerX = width / 4;
                const centerY = height / 4;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.state.rotation.y);
                
                // Draw a generic fractal pattern
                for (let i = 0; i < 500; i++) {
                    const angle = i * Math.PI * 0.02 + time;
                    const radius = 100 + Math.sin(angle * 3) * 50 + Math.cos(time + i * 0.1) * 30;
                    
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    // Size based on position and time
                    const size = 3 + Math.sin(angle * 2 + time) * 2;
                    
                    // Color based on position and time
                    const hue = (x + y) * 0.5 + time * 50;
                    ctx.fillStyle = `hsla(${hue % 360}, 80%, 60%, 0.7)`;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add connecting lines
                    if (i > 0) {
                        ctx.beginPath();
                        const prevAngle = (i - 1) * Math.PI * 0.02 + time;
                        const prevRadius = 100 + Math.sin(prevAngle * 3) * 50 + Math.cos(time + (i - 1) * 0.1) * 30;
                        const prevX = Math.cos(prevAngle) * prevRadius;
                        const prevY = Math.sin(prevAngle) * prevRadius;
                        
                        ctx.moveTo(prevX, prevY);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = `hsla(${hue % 360}, 60%, 70%, 0.3)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            animate() {
                if (!this.state.isRendering) {
                    requestAnimationFrame(() => this.animate());
                    return;
                }
                
                this.updatePerformanceMetrics();
                this.renderFractal();
                
                // Update render status
                this.ui.elements.renderStatus.textContent = 
                    `Rendering ${this.state.fractalType} | Generation: ${this.evolution.generation} | FPS: ${this.performance.fps}`;
                
                // Calculate progress based on iteration
                const progress = (this.state.iteration % 100) / 100 * 100;
                this.ui.elements.renderProgress.style.width = `${progress}%`;
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize the engine when page loads
        window.addEventListener('load', () => {
            const engine = new QuantumFractalEngine();
            window.fractalEngine = engine; // Make accessible for debugging
        });
    </script>
</body>
</html>