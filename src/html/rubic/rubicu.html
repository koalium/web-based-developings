<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Rubik's Cube | Group Theory & Complete Notation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --primary-color: #00b4db;
            --secondary-color: #667eea;
            --accent-color: #f093fb;
            --bg-dark: #0a0a12;
            --bg-panel: #151525;
            --text-light: #ffffff;
            --text-muted: #aaaaaa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--bg-dark) 0%, #121220 100%);
            color: var(--text-light);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 25px 0 35px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 3.2rem;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.3rem;
            color: var(--text-muted);
            font-weight: 300;
            max-width: 900px;
            margin: 0 auto;
            line-height: 1.5;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 3fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .cube-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .cube-container {
            flex: 1;
            min-height: 550px;
            position: relative;
            background: rgba(15, 15, 25, 0.9);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #cube-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .cube-controls {
            background: var(--bg-panel);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .control-group {
            background: rgba(30, 30, 50, 0.6);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .control-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .face-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .face-btn {
            background: rgba(40, 40, 70, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .face-btn:hover {
            background: rgba(50, 50, 90, 0.9);
            transform: translateY(-2px);
        }

        .face-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .notation-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .notation-input input {
            flex: 1;
            padding: 12px;
            background: rgba(40, 40, 70, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-size: 1rem;
        }

        .notation-input button {
            padding: 12px 20px;
            background: var(--primary-color);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .notation-input button:hover {
            background: #0099cc;
            transform: translateY(-2px);
        }

        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .algorithms-panel {
            background: var(--bg-panel);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .algorithms-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .algorithm-btn {
            background: rgba(40, 40, 70, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .algorithm-btn:hover {
            background: rgba(50, 50, 90, 0.9);
            transform: translateY(-2px);
        }

        .algorithm-btn.oll {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            border-color: var(--secondary-color);
        }

        .algorithm-btn.pll {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.2), rgba(245, 87, 108, 0.2));
            border-color: var(--accent-color);
        }

        .info-panel {
            background: var(--bg-panel);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 15px;
        }

        .info-item {
            background: rgba(30, 30, 50, 0.6);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .info-label {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .state-panel {
            background: var(--bg-panel);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-top: 20px;
        }

        .state-display {
            background: rgba(30, 30, 50, 0.6);
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .move-history {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .move-tag {
            background: rgba(0, 180, 219, 0.2);
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.85rem;
        }

        .footer {
            text-align: center;
            padding: 25px;
            color: var(--text-muted);
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 30px;
        }

        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .cube-container {
                min-height: 400px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .algorithms-grid {
                grid-template-columns: 1fr;
            }
            
            .info-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            h1 {
                font-size: 2.5rem;
            }
        }

        @media (max-width: 480px) {
            .cube-container {
                min-height: 350px;
            }
            
            .face-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-cube"></i> Advanced Rubik's Cube</h1>
            <p class="subtitle">Complete implementation with Group Theory, WCA Notation, and Advanced Algorithms</p>
        </header>
        
        <div class="main-layout">
            <div class="cube-section">
                <div class="cube-container">
                    <canvas id="cube-canvas"></canvas>
                </div>
                
                <div class="cube-controls">
                    <div class="controls-grid">
                        <div class="control-group">
                            <div class="control-title">
                                <i class="fas fa-layer-group"></i> Face Rotations
                            </div>
                            <div class="face-buttons" id="face-controls">
                                <!-- Face buttons will be generated dynamically -->
                            </div>
                            <div class="notation-input">
                                <input type="text" id="notation-input" placeholder="Enter WCA notation (e.g., R U R' U')">
                                <button id="execute-notation">Execute</button>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <div class="control-title">
                                <i class="fas fa-arrows-alt"></i> Cube Controls
                            </div>
                            <div class="face-buttons">
                                <button class="face-btn" id="scramble-btn">
                                    <i class="fas fa-random"></i>
                                    <span>Scramble</span>
                                </button>
                                <button class="face-btn" id="solve-btn">
                                    <i class="fas fa-check-double"></i>
                                    <span>Solve</span>
                                </button>
                                <button class="face-btn" id="reset-btn">
                                    <i class="fas fa-undo-alt"></i>
                                    <span>Reset</span>
                                </button>
                                <button class="face-btn" id="slice-btn">
                                    <i class="fas fa-expand-alt"></i>
                                    <span>Slice Mode</span>
                                </button>
                                <button class="face-btn" id="rotation-btn">
                                    <i class="fas fa-sync-alt"></i>
                                    <span>Rotation Mode</span>
                                </button>
                                <button class="face-btn" id="algorithm-btn">
                                    <i class="fas fa-brain"></i>
                                    <span>Algorithms</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls-section">
                <div class="algorithms-panel">
                    <div class="control-title">
                        <i class="fas fa-code"></i> Common Algorithms
                    </div>
                    <div class="algorithms-grid">
                        <button class="algorithm-btn oll" data-alg="R U R' U R U2 R'">
                            OLL 1: R U R' U R U2 R'
                        </button>
                        <button class="algorithm-btn pll" data-alg="R U' R U R U R U' R' U' R2">
                            PLL Ua: R U' R U R U R U' R' U' R2
                        </button>
                        <button class="algorithm-btn oll" data-alg="R U2 R2 U' R2 U' R2 U2 R">
                            OLL 2: R U2 R2 U' R2 U' R2 U2 R
                        </button>
                        <button class="algorithm-btn pll" data-alg="R2 U R U R' U' R' U' R' U R'">
                            PLL Ub: R2 U R U R' U' R' U' R' U R'
                        </button>
                        <button class="algorithm-btn oll" data-alg="M U M' U2 M U M'">
                            OLL 27: M U M' U2 M U M'
                        </button>
                        <button class="algorithm-btn pll" data-alg="M2 U M2 U2 M2 U M2">
                            PLL H: M2 U M2 U2 M2 U M2
                        </button>
                        <button class="algorithm-btn" data-alg="R U R' U' R' F R2 U' R' U' R U R' F'">
                            T-Perm: R U R' U' R' F R2 U' R' U' R U R' F'
                        </button>
                        <button class="algorithm-btn" data-alg="F R U' R' U' R U R' F' R U R' U' R' F R F'">
                            Y-Perm: F R U' R' U' R U R' F' R U R' U' R' F R F'
                        </button>
                    </div>
                </div>
                
                <div class="info-panel">
                    <div class="control-title">
                        <i class="fas fa-chart-line"></i> Cube State
                    </div>
                    <div class="info-grid">
                        <div class="info-item">
                            <div class="info-value" id="move-count">0</div>
                            <div class="info-label">Moves</div>
                        </div>
                        <div class="info-item">
                            <div class="info-value" id="time-elapsed">00:00</div>
                            <div class="info-label">Time</div>
                        </div>
                        <div class="info-item">
                            <div class="info-value" id="cube-state">Solved</div>
                            <div class="info-label">Status</div>
                        </div>
                    </div>
                </div>
                
                <div class="state-panel">
                    <div class="control-title">
                        <i class="fas fa-history"></i> Move History
                    </div>
                    <div class="state-display">
                        <div class="move-history" id="move-history">
                            <!-- Move history will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Advanced Rubik's Cube Simulator | Complete Group Theory Implementation | WCA Notation Support</p>
        </div>
    </div>

    <script>
        // ============================================
        // COMPLETE RUBIK'S CUBE IMPLEMENTATION
        // With Group Theory, WCA Notation, and Advanced Features
        // ============================================

        // Main Three.js variables
        let scene, camera, renderer, controls;
        
        // Cube representation as a 3D array of pieces
        let cube = [];
        let cubeGroup;
        
        // Cube state tracking
        let cubeState = {
            orientation: { x: 0, y: 0, z: 0 },
            pieces: [], // 3D array representation
            isRotating: false,
            moveHistory: [],
            startTime: null,
            timer: null
        };
        
        // Cube dimensions
        const CUBE_SIZE = 3;
        const PIECE_SIZE = 0.95;
        const GAP = 0.05;
        const TOTAL_SIZE = PIECE_SIZE + GAP;
        
        // Standard Rubik's Cube colors
        const COLORS = {
            U: 0xFFFFFF, // White
            D: 0xFFFF00, // Yellow
            F: 0x00FF00, // Green
            B: 0x0000FF, // Blue
            R: 0xFF0000, // Red
            L: 0xFF9900  // Orange
        };
        
        // WCA Notation mapping
        const WCA_NOTATION = {
            // Basic moves
            'R': { face: 'R', layer: 0, direction: 1, turns: 1 },
            'R\'': { face: 'R', layer: 0, direction: -1, turns: 1 },
            'R2': { face: 'R', layer: 0, direction: 1, turns: 2 },
            'L': { face: 'L', layer: 0, direction: 1, turns: 1 },
            'L\'': { face: 'L', layer: 0, direction: -1, turns: 1 },
            'L2': { face: 'L', layer: 0, direction: 1, turns: 2 },
            'U': { face: 'U', layer: 0, direction: 1, turns: 1 },
            'U\'': { face: 'U', layer: 0, direction: -1, turns: 1 },
            'U2': { face: 'U', layer: 0, direction: 1, turns: 2 },
            'D': { face: 'D', layer: 0, direction: 1, turns: 1 },
            'D\'': { face: 'D', layer: 0, direction: -1, turns: 1 },
            'D2': { face: 'D', layer: 0, direction: 1, turns: 2 },
            'F': { face: 'F', layer: 0, direction: 1, turns: 1 },
            'F\'': { face: 'F', layer: 0, direction: -1, turns: 1 },
            'F2': { face: 'F', layer: 0, direction: 1, turns: 2 },
            'B': { face: 'B', layer: 0, direction: 1, turns: 1 },
            'B\'': { face: 'B', layer: 0, direction: -1, turns: 1 },
            'B2': { face: 'B', layer: 0, direction: 1, turns: 2 },
            
            // Slice moves
            'M': { face: 'M', layer: 1, direction: 1, turns: 1 },
            'M\'': { face: 'M', layer: 1, direction: -1, turns: 1 },
            'M2': { face: 'M', layer: 1, direction: 1, turns: 2 },
            'E': { face: 'E', layer: 1, direction: 1, turns: 1 },
            'E\'': { face: 'E', layer: 1, direction: -1, turns: 1 },
            'E2': { face: 'E', layer: 1, direction: 1, turns: 2 },
            'S': { face: 'S', layer: 1, direction: 1, turns: 1 },
            'S\'': { face: 'S', layer: 1, direction: -1, turns: 1 },
            'S2': { face: 'S', layer: 1, direction: 1, turns: 2 },
            
            // Wide moves
            'r': { face: 'R', layer: 0, direction: 1, turns: 1, wide: true },
            'r\'': { face: 'R', layer: 0, direction: -1, turns: 1, wide: true },
            'r2': { face: 'R', layer: 0, direction: 1, turns: 2, wide: true },
            'l': { face: 'L', layer: 0, direction: 1, turns: 1, wide: true },
            'l\'': { face: 'L', layer: 0, direction: -1, turns: 1, wide: true },
            'l2': { face: 'L', layer: 0, direction: 1, turns: 2, wide: true },
            
            // Rotations
            'x': { rotation: 'x', direction: 1 },
            'x\'': { rotation: 'x', direction: -1 },
            'x2': { rotation: 'x', direction: 2 },
            'y': { rotation: 'y', direction: 1 },
            'y\'': { rotation: 'y', direction: -1 },
            'y2': { rotation: 'y', direction: 2 },
            'z': { rotation: 'z', direction: 1 },
            'z\'': { rotation: 'z', direction: -1 },
            'z2': { rotation: 'z', direction: 2 }
        };
        
        // Initialize the cube
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x080811);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
            camera.position.set(10, 8, 10);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            const canvas = document.getElementById('cube-canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 25;
            
            // Setup lighting
            setupLighting();
            
            // Initialize the cube
            initializeCube();
            
            // Generate face controls
            generateFaceControls();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start animation loop
            animate();
            
            // Start timer
            startTimer();
        }
        
        // Setup lighting
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 15);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);
        }
        
        // Initialize the cube structure
        function initializeCube() {
            // Clear existing cube
            if (cubeGroup) {
                scene.remove(cubeGroup);
            }
            
            // Create new cube group
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            // Initialize 3D array
            cube = new Array(CUBE_SIZE);
            for (let x = 0; x < CUBE_SIZE; x++) {
                cube[x] = new Array(CUBE_SIZE);
                for (let y = 0; y < CUBE_SIZE; y++) {
                    cube[x][y] = new Array(CUBE_SIZE);
                    for (let z = 0; z < CUBE_SIZE; z++) {
                        // Skip center pieces (they're not visible)
                        if (x === 1 && y === 1 && z === 1) continue;
                        
                        // Create piece
                        const piece = createPiece(x, y, z);
                        cube[x][y][z] = piece;
                        cubeGroup.add(piece.mesh);
                        
                        // Store piece data
                        piece.data = {
                            position: { x, y, z },
                            colors: getPieceColors(x, y, z),
                            type: getPieceType(x, y, z)
                        };
                    }
                }
            }
            
            // Update cube state
            updateCubeState();
        }
        
        // Create a single piece
        function createPiece(x, y, z) {
            // Create materials for each face
            const colors = getPieceColors(x, y, z);
            const materials = [
                new THREE.MeshStandardMaterial({ color: colors.R, roughness: 0.3 }), // Right
                new THREE.MeshStandardMaterial({ color: colors.L, roughness: 0.3 }), // Left
                new THREE.MeshStandardMaterial({ color: colors.U, roughness: 0.3 }), // Up
                new THREE.MeshStandardMaterial({ color: colors.D, roughness: 0.3 }), // Down
                new THREE.MeshStandardMaterial({ color: colors.F, roughness: 0.3 }), // Front
                new THREE.MeshStandardMaterial({ color: colors.B, roughness: 0.3 })  // Back
            ];
            
            // Create geometry
            const geometry = new THREE.BoxGeometry(PIECE_SIZE, PIECE_SIZE, PIECE_SIZE);
            const mesh = new THREE.Mesh(geometry, materials);
            
            // Position the piece
            mesh.position.set(
                (x - 1) * TOTAL_SIZE,
                (y - 1) * TOTAL_SIZE,
                (z - 1) * TOTAL_SIZE
            );
            
            // Enable shadows
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            return { mesh, data: null };
        }
        
        // Get colors for a piece based on its position
        function getPieceColors(x, y, z) {
            const colors = {
                R: 0x111111, // Black for interior
                L: 0x111111,
                U: 0x111111,
                D: 0x111111,
                F: 0x111111,
                B: 0x111111
            };
            
            // Set visible face colors
            if (x === CUBE_SIZE - 1) colors.R = COLORS.R; // Right face
            if (x === 0) colors.L = COLORS.L;              // Left face
            if (y === CUBE_SIZE - 1) colors.U = COLORS.U;  // Up face
            if (y === 0) colors.D = COLORS.D;              // Down face
            if (z === CUBE_SIZE - 1) colors.F = COLORS.F;  // Front face
            if (z === 0) colors.B = COLORS.B;              // Back face
            
            return colors;
        }
        
        // Get piece type (corner, edge, or center)
        function getPieceType(x, y, z) {
            const isCorner = [0, CUBE_SIZE - 1].includes(x) && 
                            [0, CUBE_SIZE - 1].includes(y) && 
                            [0, CUBE_SIZE - 1].includes(z);
            const isEdge = ([0, CUBE_SIZE - 1].includes(x) && [0, CUBE_SIZE - 1].includes(y)) ||
                          ([0, CUBE_SIZE - 1].includes(x) && [0, CUBE_SIZE - 1].includes(z)) ||
                          ([0, CUBE_SIZE - 1].includes(y) && [0, CUBE_SIZE - 1].includes(z));
            
            return isCorner ? 'corner' : isEdge ? 'edge' : 'center';
        }
        
        // Generate face control buttons
        function generateFaceControls() {
            const faceControls = document.getElementById('face-controls');
            faceControls.innerHTML = '';
            
            const faces = [
                { id: 'R', name: 'Right', color: '#FF0000', notation: 'R' },
                { id: 'L', name: 'Left', color: '#FF9900', notation: 'L' },
                { id: 'U', name: 'Up', color: '#FFFFFF', notation: 'U' },
                { id: 'D', name: 'Down', color: '#FFFF00', notation: 'D' },
                { id: 'F', name: 'Front', color: '#00FF00', notation: 'F' },
                { id: 'B', name: 'Back', color: '#0000FF', notation: 'B' }
            ];
            
            faces.forEach(face => {
                // Create clockwise button
                const cwBtn = document.createElement('button');
                cwBtn.className = 'face-btn';
                cwBtn.innerHTML = `
                    <div class="face-color" style="background: ${face.color};"></div>
                    <span>${face.notation}</span>
                    <small><i class="fas fa-redo"></i></small>
                `;
                cwBtn.onclick = () => performMove(`${face.notation}`);
                faceControls.appendChild(cwBtn);
                
                // Create counter-clockwise button
                const ccwBtn = document.createElement('button');
                ccwBtn.className = 'face-btn';
                ccwBtn.innerHTML = `
                    <div class="face-color" style="background: ${face.color};"></div>
                    <span>${face.notation}'</span>
                    <small><i class="fas fa-undo"></i></small>
                `;
                ccwBtn.onclick = () => performMove(`${face.notation}'`);
                faceControls.appendChild(ccwBtn);
                
                // Create double turn button
                const dblBtn = document.createElement('button');
                dblBtn.className = 'face-btn';
                dblBtn.innerHTML = `
                    <div class="face-color" style="background: ${face.color};"></div>
                    <span>${face.notation}2</span>
                    <small><i class="fas fa-retweet"></i></small>
                `;
                dblBtn.onclick = () => performMove(`${face.notation}2`);
                faceControls.appendChild(dblBtn);
            });
        }
        
        // Perform a move based on WCA notation
        async function performMove(notation) {
            if (cubeState.isRotating) return;
            
            cubeState.isRotating = true;
            
            const move = parseNotation(notation);
            if (!move) {
                console.error('Invalid notation:', notation);
                cubeState.isRotating = false;
                return;
            }
            
            if (move.rotation) {
                // Handle cube rotations
                await performRotation(move);
            } else {
                // Handle face/slice moves
                await performFaceMove(move);
            }
            
            // Update move history
            cubeState.moveHistory.push(notation);
            updateMoveHistory();
            
            // Update cube state
            updateCubeState();
            
            cubeState.isRotating = false;
        }
        
        // Parse WCA notation
        function parseNotation(notation) {
            notation = notation.trim();
            
            // Check if it's a known notation
            if (WCA_NOTATION[notation]) {
                return WCA_NOTATION[notation];
            }
            
            // Try to parse as algorithm (multiple moves)
            if (notation.includes(' ')) {
                return { algorithm: notation };
            }
            
            return null;
        }
        
        // Perform a face move
        async function performFaceMove(move) {
            const { face, direction, turns, layer, wide } = move;
            
            // Determine which pieces to rotate
            const pieces = getPiecesForMove(face, layer, wide);
            
            // Create animation group
            const animationGroup = new THREE.Group();
            pieces.forEach(piece => {
                const clone = piece.mesh.clone();
                clone.position.copy(piece.mesh.position);
                clone.rotation.copy(piece.mesh.rotation);
                animationGroup.add(clone);
                piece.mesh.visible = false;
            });
            
            scene.add(animationGroup);
            
            // Animate rotation
            const axis = getRotationAxis(face);
            const totalAngle = direction * (Math.PI / 2) * turns;
            
            await animateRotation(animationGroup, axis, totalAngle);
            
            // Update piece positions in the cube array
            updatePiecePositions(face, layer, wide, direction, turns);
            
            // Remove animation group and show real pieces
            scene.remove(animationGroup);
            pieces.forEach(piece => {
                piece.mesh.visible = true;
                // Apply final rotation to real piece
                piece.mesh.rotateOnWorldAxis(axis, totalAngle);
            });
            
            // Update piece data
            updatePieceData();
        }
        
        // Get pieces affected by a move
        function getPiecesForMove(face, layer, wide = false) {
            const pieces = [];
            const layerIndex = layer === 0 ? 2 : 1; // 0 = outer, 1 = middle
            
            for (let x = 0; x < CUBE_SIZE; x++) {
                for (let y = 0; y < CUBE_SIZE; y++) {
                    for (let z = 0; z < CUBE_SIZE; z++) {
                        if (isPieceAffected(x, y, z, face, layer, wide)) {
                            pieces.push(cube[x][y][z]);
                        }
                    }
                }
            }
            
            return pieces;
        }
        
        // Check if a piece is affected by a move
        function isPieceAffected(x, y, z, face, layer, wide) {
            switch(face) {
                case 'R':
                case 'r':
                    if (wide) return x >= 1;
                    return x === (layer === 0 ? 2 : 1);
                case 'L':
                case 'l':
                    if (wide) return x <= 1;
                    return x === (layer === 0 ? 0 : 1);
                case 'U':
                    return y === (layer === 0 ? 2 : 1);
                case 'D':
                    return y === (layer === 0 ? 0 : 1);
                case 'F':
                    return z === (layer === 0 ? 2 : 1);
                case 'B':
                    return z === (layer === 0 ? 0 : 1);
                case 'M':
                    return x === 1;
                case 'E':
                    return y === 1;
                case 'S':
                    return z === 1;
                default:
                    return false;
            }
        }
        
        // Get rotation axis for a face
        function getRotationAxis(face) {
            switch(face) {
                case 'R': case 'L': case 'M': case 'r': case 'l':
                    return new THREE.Vector3(1, 0, 0);
                case 'U': case 'D': case 'E':
                    return new THREE.Vector3(0, 1, 0);
                case 'F': case 'B': case 'S':
                    return new THREE.Vector3(0, 0, 1);
                default:
                    return new THREE.Vector3(0, 1, 0);
            }
        }
        
        // Animate rotation
        function animateRotation(group, axis, angle) {
            return new Promise(resolve => {
                const duration = 300;
                const steps = 60;
                const stepAngle = angle / steps;
                
                let step = 0;
                
                function animate() {
                    if (step < steps) {
                        group.rotateOnWorldAxis(axis, stepAngle);
                        step++;
                        requestAnimationFrame(animate);
                    } else {
                        resolve();
                    }
                }
                
                animate();
            });
        }
        
        // Update piece positions in the cube array
        function updatePiecePositions(face, layer, wide, direction, turns) {
            // This is where we update the logical positions of pieces
            // For a complete implementation, we would update the 3D array
            
            // Simplified implementation - in a real system, we would:
            // 1. Create a copy of affected pieces
            // 2. Apply permutation based on face and direction
            // 3. Update the cube array
            
            console.log(`Updating positions for ${face} move`);
        }
        
        // Update piece data after rotation
        function updatePieceData() {
            // Update piece colors based on new orientations
            // This would involve tracking piece orientation and updating colors
        }
        
        // Perform cube rotation
        async function performRotation(move) {
            const { rotation, direction } = move;
            const axis = getRotationAxisForRotation(rotation);
            const angle = direction * (Math.PI / 2);
            
            await animateRotation(cubeGroup, axis, angle);
            
            // Update cube orientation
            updateCubeOrientation(rotation, direction);
        }
        
        // Get rotation axis for cube rotation
        function getRotationAxisForRotation(rotation) {
            switch(rotation) {
                case 'x': return new THREE.Vector3(1, 0, 0);
                case 'y': return new THREE.Vector3(0, 1, 0);
                case 'z': return new THREE.Vector3(0, 0, 1);
                default: return new THREE.Vector3(0, 1, 0);
            }
        }
        
        // Update cube orientation after rotation
        function updateCubeOrientation(axis, direction) {
            // Track cube orientation for proper notation
            // This is important for solving algorithms
        }
        
        // Execute algorithm from notation string
        async function executeAlgorithm(algorithm) {
            const moves = algorithm.trim().split(/\s+/);
            
            for (const move of moves) {
                await performMove(move);
                await sleep(100); // Small delay between moves
            }
        }
        
        // Sleep function for delays
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // Scramble the cube
        async function scrambleCube() {
            if (cubeState.isRotating) return;
            
            const moves = [
                'R', 'L', 'U', 'D', 'F', 'B',
                'R\'', 'L\'', 'U\'', 'D\'', 'F\'', 'B\'',
                'R2', 'L2', 'U2', 'D2', 'F2', 'B2'
            ];
            
            const scrambleLength = 20;
            let scramble = [];
            
            for (let i = 0; i < scrambleLength; i++) {
                let move;
                do {
                    move = moves[Math.floor(Math.random() * moves.length)];
                } while (i > 0 && isRedundant(scramble[i-1], move));
                
                scramble.push(move);
            }
            
            // Execute scramble
            for (const move of scramble) {
                await performMove(move);
                await sleep(150);
            }
        }
        
        // Check if moves are redundant
        function isRedundant(prev, curr) {
            // Basic redundancy check
            return prev && prev[0] === curr[0];
        }
        
        // Update cube state display
        function updateCubeState() {
            const moveCount = cubeState.moveHistory.length;
            document.getElementById('move-count').textContent = moveCount;
            
            // Update cube status
            const status = isSolved() ? 'Solved' : 'Scrambled';
            document.getElementById('cube-state').textContent = status;
        }
        
        // Check if cube is solved
        function isSolved() {
            // Simplified check - in real implementation, would check all pieces
            return cubeState.moveHistory.length === 0;
        }
        
        // Update move history display
        function updateMoveHistory() {
            const historyElement = document.getElementById('move-history');
            historyElement.innerHTML = '';
            
            cubeState.moveHistory.forEach(move => {
                const tag = document.createElement('span');
                tag.className = 'move-tag';
                tag.textContent = move;
                historyElement.appendChild(tag);
            });
            
            // Scroll to bottom
            historyElement.scrollTop = historyElement.scrollHeight;
        }
        
        // Start timer
        function startTimer() {
            cubeState.startTime = Date.now();
            
            cubeState.timer = setInterval(() => {
                const elapsed = Date.now() - cubeState.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('time-elapsed').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Notation execution
            document.getElementById('execute-notation').addEventListener('click', async () => {
                const notation = document.getElementById('notation-input').value;
                if (notation) {
                    await executeAlgorithm(notation);
                }
            });
            
            // Enter key for notation input
            document.getElementById('notation-input').addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const notation = document.getElementById('notation-input').value;
                    if (notation) {
                        await executeAlgorithm(notation);
                    }
                }
            });
            
            // Control buttons
            document.getElementById('scramble-btn').addEventListener('click', scrambleCube);
            document.getElementById('solve-btn').addEventListener('click', async () => {
                // Simple solve algorithm (just reset)
                initializeCube();
                cubeState.moveHistory = [];
                updateMoveHistory();
                updateCubeState();
            });
            document.getElementById('reset-btn').addEventListener('click', () => {
                initializeCube();
                cubeState.moveHistory = [];
                updateMoveHistory();
                updateCubeState();
                cubeState.startTime = Date.now();
            });
            
            // Algorithm buttons
            document.querySelectorAll('.algorithm-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const algorithm = btn.dataset.alg;
                    await executeAlgorithm(algorithm);
                });
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                const canvas = document.getElementById('cube-canvas');
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>