<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>نمایش 3D ایستگاه تهویه مطبوع پیشرفته</title>
    <script src="./three.min.js"></script>
    <script src="./OrbitControls.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 100;
            width: 90%;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        #controls.collapsed {
            transform: translateX(-85%);
            opacity: 0.7;
        }
        #info-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 90%;
            max-width: 350px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            display: none;
            z-index: 100;
            font-size: 14px;
        }
        #object-controls {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 100;
            display: none;
        }
        .close-btn {
            float: left;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            margin-left: 5px;
        }
        .control-group {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        select, input[type="range"] {
            width: 100%;
            font-size: 14px;
            padding: 5px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 3px 0;
            width: 100%;
        }
        button:hover {
            background-color: #45a049;
        }
        button.toggle-visibility {
            background-color: #2196F3;
        }
        button.toggle-visibility.hidden {
            background-color: #f44336;
        }
        h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            font-size: 16px;
        }
        .toggle-container {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .toggle-container label {
            flex: 1;
            margin-bottom: 0;
        }
        .toggle-btn {
            width: auto;
            margin-left: 10px;
            padding: 5px 8px;
        }
        .section-title {
            background-color: #f0f0f0;
            padding: 5px;
            margin: 8px -10px 5px -10px;
            font-weight: bold;
            font-size: 14px;
        }
        #toggle-controls {
            position: absolute;
            right: -25px;
            top: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            padding: 5px 8px;
            cursor: pointer;
            z-index: 101;
        }
        #hide-all-controls {
            background-color: #9E9E9E;
            margin-top: 10px;
        }
        @media (max-width: 600px) {
            #controls {
                width: 85%;
            }
            #info-panel, #object-controls {
                width: 85%;
                font-size: 12px;
            }
            button, select, input[type="range"] {
                padding: 6px 8px;
                font-size: 12px;
            }
            h3 {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <button id="toggle-controls">≡</button>
        <h3>تنظیمات نمایش</h3>
        
        <div class="control-group">
            <label for="bg-color">رنگ پس‌زمینه:</label>
            <select id="bg-color">
                <option value="#f0f0f0">سفید</option>
                <option value="#808000">زیتونی</option>
                <option value="#0066cc">آبی</option>
                <option value="#555555">خاکستری تیره</option>
                <option value="#aaaaaa">خاکستری روشن</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="light-intensity">شدت نور: <span id="light-value">1.0</span></label>
            <input type="range" id="light-intensity" min="0.1" max="2" step="0.1" value="1">
            
            <label for="wall-opacity">شفافیت دیوارها: <span id="opacity-value">25</span>%</label>
            <input type="range" id="wall-opacity" min="10" max="90" step="5" value="25">
        </div>
        
        <div class="control-group">
            <label for="camera-angle">زاویه دوربین:</label>
            <select id="camera-angle">
                <option value="perspective">پرسپکتیو</option>
                <option value="top">نمای بالا</option>
                <option value="front">نمای جلو</option>
                <option value="side">نمای جانبی</option>
                <option value="supply-side">نمای بخش رفت</option>
                <option value="return-side">نمای بخش برگشت</option>
            </select>
        </div>
        
        <div class="control-group">
            <button id="reset-view">بازنشانی نمای دوربین</button>
            <button id="toggle-wireframe">نمایش/پنهان کردن اسکلت</button>
            <button id="hide-all-controls">پنهان کردن تمام کنترل‌ها</button>
        </div>
        
        <div class="section-title">تنظیمات فن‌ها و فیلترها</div>
        <div class="control-group">
            <label for="fan-diameter">قطر فن‌ها:</label>
            <select id="fan-diameter">
                <option value="1.12">1.12 متر</option>
                <option value="1.4">1.4 متر</option>
                <option value="1.6" selected>1.6 متر</option>
            </select>
            
            <label for="fan-speed">سرعت چرخش فن‌ها: <span id="fan-speed-value">1000</span> RPM</label>
            <input type="range" id="fan-speed" min="100" max="2955" step="100" value="1000">
            
            <label for="filter-speed">سرعت چرخش فیلترها: <span id="filter-speed-value">1</span> RPM</label>
            <input type="range" id="filter-speed" min="0" max="30" step="0.1" value="1">
        </div>
        
        <div class="section-title">تنظیمات مه‌پاش‌ها</div>
        <div class="control-group">
            <div class="toggle-container">
                <label>مه‌پاش 1:</label>
                <button id="toggle-fogger1" class="toggle-btn">خاموش</button>
            </div>
            <label for="fogger1-intensity">شدت پاشش مه‌پاش 1: <span id="fogger1-value">40</span>%</label>
            <input type="range" id="fogger1-intensity" min="0" max="100" step="5" value="40">
            
            <div class="toggle-container">
                <label>مه‌پاش 2:</label>
                <button id="toggle-fogger2" class="toggle-btn">خاموش</button>
            </div>
            <label for="fogger2-intensity">شدت پاشش مه‌پاش 2: <span id="fogger2-value">50</span>%</label>
            <input type="range" id="fogger2-intensity" min="0" max="100" step="5" value="60">
        </div>
        
        <div class="section-title">تنظیمات دمپرها</div>
        <div class="control-group">
            <div class="toggle-container">
                <label>دمپر هوای تازه 1:</label>
                <button id="toggle-fresh-damper1" class="toggle-btn">بسته</button>
            </div>
            
            <div class="toggle-container" >
                <label >دمپر هوای تازه 2:</label>
                <button id="toggle-fresh-damper2" class="toggle-btn" >بسته</button>
            </div>
            
            <div class="toggle-container">
                <label>دمپر اگزاست 1:</label>
                <button id="toggle-exhaust-damper1" class="toggle-btn">باز</button>
            </div>
            
            <div class="toggle-container">
                <label>دمپر اگزاست 2:</label>
                <button id="toggle-exhaust-damper2" class="toggle-btn">باز</button>
            </div>
        </div>
    </div>
    
    <div id="info-panel">
        <span class="close-btn" onclick="hideInfo()">×</span>
        <h3 id="info-title">عنوان جزئیات</h3>
        <div id="info-content">محتوای اطلاعاتی اینجا نمایش داده می‌شود...</div>
    </div>

    <div id="object-controls">
        <h3>کنترل شیء انتخابی</h3>
        <button id="toggle-object-visibility" class="toggle-visibility">پنهان کردن شیء</button>
        <button id="close-object-controls">بستن</button>
    </div>

    <script>
        let supplyFanCount = 2;
        let returnFanCount = 2;
        let suuplyFanSize =1400;
        let returnFanSize = 1600;
        let fans = {
            supply: { count: 3, diameter: 1.4 , motor :30},
            return: { count: 2, diameter: 1.6 , motor :45}
        };
        let ducts = {
            supply: { count: 2, shape: 'circle' , width :1.4 , height:1.4},
            return: { count: 2, shape: 'rect' , width :1.6, height:1.4}
        };
        let vents = {
            supply: { count: 120, shape: 'circle' , width :1.4 , height:1.4},
            return: { count: 220, shape: 'rect' , width :1.6, height:1.4}
        };
        let rotarys = {
            filters: { count: 2, length :5.1, diameter :1.25},
            return: { count: 2, shape: 'rect' , width :1.6, height:1.4}
        };
        let damper = {
            fresh: { count: 3,  width :1.52 , height:3.04},
            exhaust: { count: 3,  width :1.52 , height:3.04},
            return: { count: 3,  width :1.52, height:3.04}
        };
        let heatcoil = {
            filters: { count: 3, width:3.04 , height :1.52 },
            
        };

        let faply =[];
        let farns =[];
        let damresh =[];
        let damturn =[];
        let damaust =[];
        let duply=[];
        let durns=[];
        // Initialize Three.js scene
        let scene, camera, renderer, controls, objects = {};
        let wireframeVisible = false;
        let fanSpeed = 1000; // RPM
        let filterSpeed = 1; // RPM
        let fanDiameter = 1.6; // meters
        let foggers = {
            fogger1: { active: false, intensity: 0.5 },
            fogger2: { active: false, intensity: 0.5 }
        };
        let dampers = {
            fresh1: { open: false },
            fresh2: { open: false },
            exhaust1: { open: true },
            exhaust2: { open: true },
            return: { open: false },
            return2:{open :false}
        };
        let wallOpacity = 0.35;
        let selectedObject = null;
        let controlsVisible = true;
        let damperOpacity = 0.40;
        let sductwidth=1.8;
        let sductheight=1.8;
        let damperw = 1.8;
        let damperheight=2.5;

        init();
        animate();
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Create camera with adjusted parameters for mobile
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 15, 20);
            
            // Create renderer with anti-aliasing and optimized for mobile
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add orbit controls with damping for smooth movement
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 50;
            controls.enableTouchZoom = true;
            controls.enablePan = true;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            objects.directionalLight = directionalLight;
            
            // Create ventilation system
            createVentilationSystem();
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(30, 30);
            scene.add(gridHelper);
            objects.gridHelper = gridHelper;
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            objects.axesHelper = axesHelper;
            
            // Setup event listeners
            setupEventListeners();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mobile orientation changes
            window.addEventListener('orientationchange', onWindowResize);
            camera.position.set(20, 7, -6);
            camera.lookAt(5, 2, 0);
        }
        
        function createVentilationSystem() {
            const system = new THREE.Group();
            
            // Create main ventilation room (25m deep, 8m wide, 5m height)
            const ventRoom = createVentilationRoom();
            system.add(ventRoom);
            objects.ventRoom = ventRoom;
            
            // Create tower on top (5m height)
            const tower = createTower();
            tower.position.y = 5; // Place on top of ventilation room
            system.add(tower);
            objects.tower = tower;
            
            // Add supply fans (2 fans side by side on supply side wall)
            updateFans();
            
            // Add return grilles (2 grilles in floor)
            const returnGrille1 = createFloorGrille();
            returnGrille1.position.set(0, 3.3, 0.3);
            returnGrille1.rotation.x = Math.PI;
            system.add(returnGrille1);
            objects.returnGrille1 = returnGrille1;
            
            const returnGrille2 = createFloorGrille();
            returnGrille2.position.set(0, 1.5, 0.3);
            returnGrille2.rotation.x = Math.PI;
            system.add(returnGrille2);
            objects.returnGrille2 = returnGrille2;
            
            // Add return ducts under floor grilles
            const returnDuct1 = createDuct(1.2, 0.8, 1, 0x32CD32);
            returnDuct1.position.set(-0.5, -0.4, 10);
            //system.add(returnDuct1);
            objects.returnDuct1 = returnDuct1;
            
            const returnDuct2 = createDuct(1.2, 0.8, 1, 0x32CD32);
            returnDuct2.position.set(0.5, -0.4, 10);
            //system.add(returnDuct2);
            objects.returnDuct2 = returnDuct2;
            
            // Add pits under rotary filters (2m depth)
            const pit1 = createPit();
            pit1.position.set(-1.5, 0, 7);
            system.add(pit1);
            objects.pit1 = pit1;
            
            const pit2 = createPit();
            pit2.position.set(1.5, 0, 7);
            system.add(pit2);
            objects.pit2 = pit2;
            
            // Add rotary filters (2 filters parallel to room, 2.5m diameter, 5.1m length)
            const filter1 = createRotaryFilter();
            filter1.position.set(-1.85, 2.5, 7);
            filter1.rotation.y = Math.PI; // Rotated 90 degrees to be parallel to room
            system.add(filter1);
            objects.filter1 = filter1;
            
            const filter2 = createRotaryFilter();
            filter2.position.set(1.85, 2.5, 7);
            filter2.rotation.y = Math.PI; // Rotated 90 degrees to be parallel to room
            system.add(filter2);
            objects.filter2 = filter2;
            
            // Add wall with holes for return fans
            const returnWall = createReturnWall();
            returnWall.position.set(0, 2.5, 4);
            system.add(returnWall);
            objects.returnWall = returnWall;
            // Add wall with holes for return fans
            const recyclenWall = createrecyclenWall();
            recyclenWall.position.set(0, 4.8, 0);
            system.add(recyclenWall);
            objects.recyclenWall = recyclenWall;
            // Add return fans (2 fans, more powerful, in wall holes)
            updateReturnFans();
            
            
            
            // Add fogging system in supply side
            createFoggingSystem(system);
            
            // Add eliminator section after foggers
            const eliminator = createEliminator();
            eliminator.position.set(0, 2.5, -7);
            system.add(eliminator);
            objects.eliminator = eliminator;
            
            // Add large fresh air dampers in tower (2 dampers)
            const freshAirDamper1 = createLargeDamper(damper.fresh.width, damper.fresh.height, 0.3);
            freshAirDamper1.position.set(-1.4, 7.5, -2.02);
            system.add(freshAirDamper1);
            objects.freshAirDamper1 = freshAirDamper1;
            
            const freshAirDamper2 = createLargeDamper(damper.fresh.width, damper.fresh.height, 0.3);
            freshAirDamper2.position.set(1.4, 7.5, -2);
            system.add(freshAirDamper2);
            objects.freshAirDamper2 = freshAirDamper2;
            
            // Add large exhaust dampers in tower (2 dampers)
            const exhaustDamper1 = createLargeDamper(damper.exhaust.width, damper.exhaust.height, 0.3);
            exhaustDamper1.position.set(-1.4, 7.5, 2);
            system.add(exhaustDamper1);
            objects.exhaustDamper1 = exhaustDamper1;
            
            const exhaustDamper2 = createLargeDamper(damper.exhaust.width, damper.exhaust.height, 0.3);
            exhaustDamper2.position.set(1.4, 7.5, 2);
            system.add(exhaustDamper2);
            objects.exhaustDamper2 = exhaustDamper2;

            const returnDamper = createLargeDamper(damper.return.width, damper.return.height, 0.3);
            returnDamper.position.set(1,2.66, -0.4);
            system.add(returnDamper);
            objects.returnDamper = returnDamper;
            
            const returnDamper2 = createLargeDamper(damper.return.width, damper.return.height, 0.3);
            returnDamper2.position.set(-1,2.66, -0.4);
            system.add(returnDamper2);
            objects.returnDamper2 = returnDamper2;
            updateDamper(objects.exhaustDamper2, dampers.exhaust2.open);
            updateDamper(objects.exhaustDamper1, dampers.exhaust1.open);
            updateDamper(objects.returnDamper, dampers.return.open);
            updateDamper(objects.returnDamper2, dampers.return2.open);
            scene.add(system);
        }
        
        function createPit() {
            const pit = new THREE.Group();
            
            // Pit walls (2m depth)
            const pitGeometry = new THREE.BoxGeometry(3, 2, 6);
            const pitMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x555555,
                transparent: true,
                opacity: 0.7
            });
            const pitMesh = new THREE.Mesh(pitGeometry, pitMaterial);
            pitMesh.position.y = -1;
            pit.add(pitMesh);
            
            return pit;
        }
        
        function createrecyclenWall() {
            const wall = new THREE.Group();
            
            // Main wall (5m height, 8m width, 0.4m thickness)
            const wallGeometry = new THREE.BoxGeometry(7.2, 9.2, 0.4);
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x665544,
                transparent: true,
                opacity: 0.42,
                side: THREE.DoubleSide
            });
            const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.add(wallMesh);
            
            // Holes for rotary filters (2.5m diameter)
           
            
            return wall;
        }
        function createReturnWall() {
            const wall = new THREE.Group();
            
            // Main wall (5m height, 8m width, 0.4m thickness)
            const wallGeometry = new THREE.BoxGeometry(8, 5, 0.4);
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x667788,
                transparent: true,
                opacity: wallOpacity,
                side: THREE.DoubleSide
            });
            const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.add(wallMesh);
            
            // Holes for rotary filters (2.5m diameter)
            const holeGeometry = new THREE.CylinderGeometry(0.1+fans.return.diameter/2, 0.3+fans.return.diameter/2, 0.75, 32);
            const holeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFF0000,
                transparent: true,
                opacity: 0.66,
                side: THREE.DoubleSide
            });
            
            const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
            hole1.position.set(-1.85, 0, 0);
            hole1.rotation.x = Math.PI / 2;
            wall.add(hole1);
            
            const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);
            hole2.position.set(1.85, 0, 0);
            hole2.rotation.x = Math.PI / 2;
            wall.add(hole2);
            
            return wall;
        }
        
        function updateFans() {
            // Remove existing fans if they exist
            if (objects.supplyFan1) scene.remove(objects.supplyFan1);
            if (objects.supplyFan2) scene.remove(objects.supplyFan2);
            if (objects.supplyFan3) scene.remove(objects.supplyFan3);
            
            
            const supplyFan1 = createFan(fans.supply.diameter, true);
            supplyFan1.position.set(-3.5, 3.5, -11);
            supplyFan1.rotation.y = Math.PI/2;
            scene.add(supplyFan1);
            objects.supplyFan1 = supplyFan1;
            
            const supplyFan2 = createFan(fans.supply.diameter, true);
            supplyFan2.position.set(-3.5, 3.5, -9);
            supplyFan2.rotation.y = Math.PI/2;
            scene.add(supplyFan2);
            objects.supplyFan2 = supplyFan2;
            if(fans.supply.count===3){
                const supplyFan3 = createFan(fans.supply.diameter, true);
            supplyFan3.position.set(-1.5, 3.5, -11.77);
            supplyFan3.rotation.y = 0;
            scene.add(supplyFan3);
            objects.supplyFan3 = supplyFan3;
            }
            // Update ducts to match new fan positions
            updateSupplyDucts();
        }
        
        function updateReturnFans() {
            // Remove existing return fans if they exist
            if (objects.returnFan1) scene.remove(objects.returnFan1);
            if (objects.returnFan2) scene.remove(objects.returnFan2);
            
            // Create new return fans with current diameter
            const returnFan1 = createFan(fans.return.diameter, false, true);
            returnFan1.position.set(-1.85, 2.5, 3.7);
            returnFan1.rotation.x=Math.PI;
            scene.add(returnFan1);
            objects.returnFan1 = returnFan1;
            
            const returnFan2 = createFan(fans.return.diameter
            , false, true);
            returnFan2.position.set(1.85, 2.5, 3.7);
            returnFan2.rotation.x=Math.PI;
            scene.add(returnFan2);
            objects.returnFan2 = returnFan2;
        }
        
        function updateSupplyDucts() {
            // Remove existing ducts if they exist
            if (objects.supplyDuct1) scene.remove(objects.supplyDuct1);
            if (objects.supplyDuct2) scene.remove(objects.supplyDuct2);
            if (objects.supplyDuct3) scene.remove(objects.supplyDuct3);
            // Create new ducts based on current fan positions
            const supplyDuct1 = createDuct(1.8, 1.8, 2.5, 0x4169E1);
            supplyDuct1.position.set(-4.95, 3.5, -11);
            supplyDuct1.rotation.y = Math.PI/2;
            scene.add(supplyDuct1);
            objects.supplyDuct1 = supplyDuct1;
            
            const supplyDuct2 = createDuct(1.8, 1.8, 2.5, 0x4169E1);
            supplyDuct2.position.set(-4.95, 3.5, -9);
            supplyDuct2.rotation.y = Math.PI/2;
            scene.add(supplyDuct2);
            objects.supplyDuct2 = supplyDuct2;
            if(fans.supply.count===3){
               const supplyDuct3 = createDuct(1.8, 1.8, 2.5, 0x4169E1);
            supplyDuct3.position.set(-1.5, 3.5, -13.3);
            supplyDuct3.rotation.y = 0;
            scene.add(supplyDuct3);
            objects.supplyDuct2 = supplyDuct3;
            }
        }
        
        function createVentilationRoom() {
            const room = new THREE.Group();
            
            // Dimensions (25m deep, 8m wide, 5m height)
            const width = 8;
            const height = 5;
            const depth = 25;
            
            // Create walls (gray) with 0.4m thickness
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xAAAAAA,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: wallOpacity
            });

            const roofMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDDDD44,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: wallOpacity
            });
            
            // Left wall
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, height, depth),
                wallMaterial
            );
            leftWall.position.set(-width/2 + 0.2, height/2, 0);
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            room.add(leftWall);
            objects.leftWall = leftWall;
            
            // Right wall
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, height, depth),
                wallMaterial
            );
            rightWall.position.set(width/2 - 0.2, height/2, 0);
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            room.add(rightWall);
            objects.rightWall = rightWall;
            
            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, 0.4),
                wallMaterial
            );
            backWall.position.set(0, height/2, -depth/2 + 0.2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            room.add(backWall);
            objects.backWall = backWall;
            
            // Front wall (with openings for ducts)
            const frontWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, 0.4),
                wallMaterial
            );
            frontWall.position.set(0, height/2, depth/2 - 0.2);
            frontWall.castShadow = true;
            frontWall.receiveShadow = true;
            room.add(frontWall);
            objects.frontWall = frontWall;
            
            // Floor (dark gray)
            const floor = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.2, depth),
                new THREE.MeshPhongMaterial({ color: 0x555555 })
            );
            floor.position.set(0, 0.1, 0);
            floor.receiveShadow = true;
            room.add(floor);
            objects.floor = floor;
            
            // Ceiling (light gray) with 0.3m thickness
            const ceiling = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.3, depth),
                roofMaterial//new THREE.MeshPhongMaterial({ color: 0xDDDDDD })
            );
            ceiling.position.set(0, height - 0.15, 0);
            ceiling.receiveShadow = true;
            room.add(ceiling);
            objects.ceiling = ceiling;
            
            return room;
        }
        
        function createTower() {
            const tower = new THREE.Group();
            
            // Dimensions (6m wide, 4m deep, 5m height)
            const width = 8;
            const height = 4.5;
            const depth = 4;
            
            // Create walls (light blue) with 0.4m thickness
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xADD8E6,
                transparent: true,
                opacity: wallOpacity
            });
            // Create walls (light blue) with 0.4m thickness
            const roofMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x22CCEE,
                transparent: true,
                opacity: 0.33
            });
            const ceilMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x555555,
                transparent: true,
                opacity: wallOpacity
            });
            
            // Left wall
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, height, depth),
                wallMaterial
            );
            leftWall.position.set(-width/2 + 0.2, height/2, 0);
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            tower.add(leftWall);
            objects.towerLeftWall = leftWall;
            
            // Right wall
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, height, depth),
                wallMaterial
            );
            rightWall.position.set(width/2 - 0.2, height/2, 0);
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            tower.add(rightWall);
            objects.towerRightWall = rightWall;
            
            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, 0.4),
                wallMaterial
            );
            backWall.position.set(0, height/2, -depth/2 + 0.2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            tower.add(backWall);
            objects.towerBackWall = backWall;
            
            // Front wall
            const frontWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, 0.4),
                wallMaterial
            );
            frontWall.position.set(0, height/2, depth/2 - 0.2);
            frontWall.castShadow = true;
            frontWall.receiveShadow = true;
            tower.add(frontWall);
            objects.towerFrontWall = frontWall;
            
            // Floor (same as ceiling of ventilation room)
            const floor = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.3, depth),
                roofMaterial//new THREE.MeshPhongMaterial({ color: 0xDDDDDD })
            );
            floor.position.set(0, 0.15, 0);
            floor.receiveShadow = true;
            //tower.add(floor);
            objects.towerFloor = floor;
            
            // Ceiling (white) with 0.3m thickness
            const ceiling = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.3, depth),
                ceilMaterial//new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
            );
            ceiling.position.set(0, height - 0.15, 0);
            ceiling.receiveShadow = true;
            tower.add(ceiling);
            objects.towerCeiling = ceiling;
            
            return tower;
        }
        
        function createLargeDamper(width, height, thickness) {
            const damper = new THREE.Group();
            
            // Damper frame
            const frameGeometry = new THREE.BoxGeometry(width, height, thickness);
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 ,transparent: true,
                opacity: 0.33});
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            damper.add(frame);
            
            // Damper blades (more blades for larger dampers)
            const bladeCount = 10;
            const bladeMaterial = new THREE.MeshPhongMaterial({ color: 0x233223 });
            for (let i = 0; i < bladeCount; i++) {
                const bladeGeometry = new THREE.BoxGeometry(width*0.95, height/(bladeCount+1), thickness*0.12);
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.y = -height/2 + (i+0.5)*(height/(bladeCount+1));
                blade.rotation.x = 0; // Start closed
                damper.add(blade);
            }
            
            return damper;
        }
        
        function updateDamper(damperObj, open) {
            damperObj.children.forEach((child, index) => {
                if (index > 0) { // Skip the frame
                    child.rotation.x = open ? Math.PI / 2.33 : 0;
                }
            });
        }
        
        function createFan(diameter, isSupply = true, isPowerful = false) {
            const fan = new THREE.Group();
            const color = isSupply ? 0x4169E1 : (isPowerful ? 0xFF4500 : 0x32CD32);
            
            // Fan housing
            const housingGeometry = new THREE.CylinderGeometry(diameter/2, diameter/2, 0.2, 32);
            const housingMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const housing = new THREE.Mesh(housingGeometry, housingMaterial);
            housing.rotation.x = Math.PI / 2;
            fan.add(housing);
            
            // Fan blades (5 blades like fan blades)
            const bladeMaterial = new THREE.MeshPhongMaterial({ color: color });
            for (let i = 0; i < 10; i++) {
                // Create curved fan blade
                const bladeShape = new THREE.Shape();
                bladeShape.moveTo(0, 0);
                bladeShape.lineTo(0.1, 0);
                bladeShape.quadraticCurveTo(
                    0.15, diameter*0.15,
                    0.1, diameter*0.3
                );
                bladeShape.quadraticCurveTo(
                    0.05, diameter*0.4,
                    0, diameter*0.45
                );
                
                const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, {
                    steps: 2,
                    depth: 0.05,
                    bevelEnabled: false
                });
                
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.rotation.y = i * (Math.PI * 2 / 7);
                blade.position.z = 0.2;
                fan.add(blade);
            }
            
            // Motor hub
            const hubGeometry = new THREE.CylinderGeometry(0.3, 0.2, 1, 16);
            const hubMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.rotation.x = Math.PI / 2;
            hub.position.z = 0.5;
            fan.add(hub);
            
            return fan;
        }
        
        function createFloorGrille() {
            const grille = new THREE.Group();
            
            // Grille frame (1.2m x 0.8m)
            const frameGeometry = new THREE.BoxGeometry(0.22, 3, 0.1);
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.x = 0.72;
            grille.add(frame);
            let frame3= new THREE.Mesh(frameGeometry, frameMaterial);
            frame3.position.x = -0.72;
            grille.add(frame3);
            
            // Grille bars (horizontal)
            const barGeometry = new THREE.BoxGeometry(1.52, 0.02, 0.05);
            const barMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
            for (let i = 0; i < 33; i++) {
                const bar = new THREE.Mesh(barGeometry, barMaterial);
                bar.position.y =  -1.4+i * 0.09;
                grille.add(bar);
            }
            grille.rotation.z=Math.PI/2;
            return grille;
        }
        
        function createRotaryFilter() {
            const filter = new THREE.Group();
            
            // Filter cylinder (2.5m diameter, 5.1m length)
            const cylinderGeometry = new THREE.CylinderGeometry(1.25, 1.25, 5.1, 32);
            const cylinderMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x55FF66,
                transparent: true,
                opacity: 0.77
            });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.rotation.x = Math.PI / 2;
            filter.add(cylinder);
            
            // Filter frame
            const frameGeometry = new THREE.CylinderGeometry(1.25, 1.25, 5.1, 32, 1, true);
            const frameMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide,
                wireframe: true
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.rotation.x = Math.PI / 2;
            filter.add(frame);
            
            return filter;
        }
        
        function createDuct(width, height, length, color) {
            const wall = new THREE.Group();
            const duct = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, length),
                new THREE.MeshPhongMaterial({ color: color })
            );
            duct.castShadow = true;
            duct.receiveShadow = true;
            wall.add(duct);
            const holeGeometry = new THREE.CylinderGeometry(0.32+fans.supply.diameter/2, 0.2+fans.supply.diameter/2,0.22);
            const holeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xaabb00,
                transparent: true,
                opacity: 0.66,
                side: THREE.DoubleSide
            });
            
            const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
            hole1.position.set(0, 0, 1.36);
            hole1.rotation.x = Math.PI / 2;
            wall.add(hole1);

            
            return wall;
        }
        
        function createFoggingSystem(system) {
            const foggingSystem = new THREE.Group();
            
            // First fogger (in supply section)
            const fogger1 = createFogger();
            fogger1.position.set(-1, 0.55, -1);
            foggingSystem.add(fogger1);
            objects.fogger1 = fogger1;
            
            // Second fogger (1m after first fogger)
            const fogger2 = createFogger();
            fogger2.position.set(1, 0.55, -1);
            foggingSystem.add(fogger2);
            objects.fogger2 = fogger2;
            
            // Create collectors with vertical pipes (1 inch, every 30cm)
            createCollectorWithPipes(foggingSystem, 0, -5);
            createCollectorWithPipes(foggingSystem, 0, -3);
            
            // Fog particles (will be shown/hidden based on toggle)
            for (let i = 0; i < 15; i++) {
                const fogParticles1 = createFogParticles(0, -5.15 +i*0.02, i*0.02);
                foggingSystem.add(fogParticles1);
                objects[`fogParticles1_${i}`] = fogParticles1;
                
                const fogParticles2 = createFogParticles(0, -3.15 +i*0.02, i*0.02);
                foggingSystem.add(fogParticles2);
                objects[`fogParticles2_${i}`] = fogParticles2;
            }
            
            system.add(foggingSystem);
        }
        
        function createCollectorWithPipes(group, xPos, zPos) {
            // Collector box (on floor)
            const collectorGeometry = new THREE.BoxGeometry(5.5, 0.1, 0.1);
            const collectorMaterial = new THREE.MeshPhongMaterial({ color: 0x0066CC });
            const collector = new THREE.Mesh(collectorGeometry, collectorMaterial);
            collector.position.set(xPos, 4.5, zPos);
            group.add(collector);
            
            // Vertical pipes (1 inch diameter, every 30cm)
            const pipeRadius = 0.0127; // 1 inch in meters
            const pipeHeight = 4;
            const pipeGeometry = new THREE.CylinderGeometry(pipeRadius, pipeRadius, pipeHeight, 16);
            const pipeMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            
            for (let i = -9; i <= 9; i++) {
                const pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
                pipe.position.set(xPos + i*0.304, 2.5, zPos);
                group.add(pipe);
            }
            
            // Header pipe at top
            const headerGeometry = new THREE.CylinderGeometry(0.05, 0.05, 5.5, 16);
            const header = new THREE.Mesh(headerGeometry, pipeMaterial);
            header.position.set(xPos, 0.5, zPos);
            header.rotation.z = Math.PI / 2;
            
            group.add(header);
           // group.rotation.z=Math.PI;
        }
        
        function createFogger() {
            const fogger = new THREE.Group();
            
            // Simplified fogger representation
            const bodyGeometry = new THREE.BoxGeometry(0.75, 0.65, 0.55);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x0066FF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            fogger.add(body);
            
            return fogger;
        }
        
        function createFogParticles(xPos, zPos,yPos) {
            const particles = new THREE.Group();
            particles.visible = false;
            
            const particleCount = 150;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = xPos + (Math.random() - 0.5) * 5.5;
                positions[i * 3 + 1] = Math.random() * 5;
                positions[i * 3 + 2] = zPos ;//+ (Math.random() - 0.5) * 2.5;
                sizes[i] = Math.random() * 0.1 + 0.05;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xAAAAFF,
                size: Math.random() * 0.1 + 0.05,
                transparent: true,
                opacity: 0.87
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            particles.add(particleSystem);
            
            return particles;
        }
        
        function updateFogParticlesVisibility() {
            for (const key in objects) {
                if (key.startsWith('fogParticles1_')) {
                    objects[key].visible = foggers.fogger1.active;
                    objects[key].children[0].material.opacity = 0.3 + (foggers.fogger1.intensity * 0.7);
                }
                if (key.startsWith('fogParticles2_')) {
                    objects[key].visible = foggers.fogger2.active;
                    objects[key].children[0].material.opacity = 0.3 + (foggers.fogger2.intensity * 0.7);
                }
            }
        }
        
        function createEliminator() {
            const eliminator = new THREE.Group();
            const efw = 5;
            const efh = 3.8;
            const efl = 0.42;
            const elbl = 0.25;
            const elbth = 0.012;
            const elbh = 3.66;
            // Main frame
            const frameGeometry = new THREE.BoxGeometry(efh, efw, efl);
            const frameMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.65
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y=-1;
            eliminator.add(frame);
            
            // Eliminator blades (35cm length)
            const bladeGeometry = new THREE.BoxGeometry(elbh, elbl, elbth);
            const bladeMaterial = new THREE.MeshPhongMaterial({ color: 0xccFAA42 });
            const bladeMaterial_ = new THREE.MeshPhongMaterial({ color: 0xd228844 });
            let blademat= bladeMaterial;
            const els = 0.1014;
            const elw = efw;
            let blcount = elw/els;
            for (let i = 0; i < blcount; i++) {
                let blade_;
                if(i%2===0){
                    blademat = bladeMaterial;
                    blademat_ = bladeMaterial_;
                }else{
                    blademat = bladeMaterial_;
                    blademat_ = bladeMaterial;
                }
                
                const blade = new THREE.Mesh(bladeGeometry, blademat);
                const bladese =new THREE.Mesh(bladeGeometry, blademat_);
                blade.position.y = -2.75 + i * (els+elbth);
                blade.rotation.x = Math.PI / 4; // Angled blades
                eliminator.add(blade);
                bladese.position.z = elbl/1.44; // Angled blades
                bladese.position.y = -2.75 + i * (els+elbth);
                bladese.rotation.x = -Math.PI/4 ; // Angled blades
                
                eliminator.add(bladese);
            }
            
            // Collection basin at bottom
            const basinGeometry = new THREE.BoxGeometry(0.48, 6, 6);
            const basinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0066CC,
                transparent: true,
                opacity: 0.66
            });
            const basin = new THREE.Mesh(basinGeometry, basinMaterial);
            basin.position.y = 0;
            basin.position.z = 2;
            basin.position.x = -2;
            eliminator.add(basin);
            eliminator.rotation.z=Math.PI/2;
            
            return eliminator;
        }
        
        function setupEventListeners() {
            // Toggle controls panel
            document.getElementById('toggle-controls').addEventListener('click', function() {
                document.getElementById('controls').classList.toggle('collapsed');
            });
            
            // Hide all controls
            document.getElementById('hide-all-controls').addEventListener('click', function() {
                controlsVisible = !controlsVisible;
                document.getElementById('controls').style.display = controlsVisible ? 'block' : 'none';
                this.textContent = controlsVisible ? 'پنهان کردن تمام کنترل‌ها' : 'نمایش کنترل‌ها';
            });
            
            // Display controls
            document.getElementById('bg-color').addEventListener('change', changeBackground);
            document.getElementById('light-intensity').addEventListener('input', updateLightIntensity);
            document.getElementById('wall-opacity').addEventListener('input', updateWallOpacity);
            document.getElementById('camera-angle').addEventListener('change', changeCameraAngle);
            document.getElementById('reset-view').addEventListener('click', resetView);
            document.getElementById('toggle-wireframe').addEventListener('click', toggleWireframe);
            
            // Fan controls
            document.getElementById('fan-diameter').addEventListener('change', function() {
                fanDiameter = parseFloat(this.value);
                updateFans();
                updateReturnFans();
            });
            
            document.getElementById('fan-speed').addEventListener('input', function() {
                fanSpeed = parseInt(this.value);
                document.getElementById('fan-speed-value').textContent = fanSpeed;
            });
            
            document.getElementById('filter-speed').addEventListener('input', function() {
                filterSpeed = parseInt(this.value);
                document.getElementById('filter-speed-value').textContent = filterSpeed;
            });
            
            // Fogger controls
            document.getElementById('toggle-fogger1').addEventListener('click', function() {
                foggers.fogger1.active = !foggers.fogger1.active;
                this.textContent = foggers.fogger1.active ? 'روشن' : 'خاموش';
                updateFogParticlesVisibility();
            });
            
            document.getElementById('toggle-fogger2').addEventListener('click', function() {
                foggers.fogger2.active = !foggers.fogger2.active;
                this.textContent = foggers.fogger2.active ? 'روشن' : 'خاموش';
                updateFogParticlesVisibility();
            });
            
            document.getElementById('fogger1-intensity').addEventListener('input', function() {
                foggers.fogger1.intensity = parseInt(this.value) / 100;
                document.getElementById('fogger1-value').textContent = this.value;
                updateFogParticlesVisibility();
            });
            
            document.getElementById('fogger2-intensity').addEventListener('input', function() {
                foggers.fogger2.intensity = parseInt(this.value) / 100;
                document.getElementById('fogger2-value').textContent = this.value;
                updateFogParticlesVisibility();
            });
            
            // Damper controls
            document.getElementById('toggle-fresh-damper1').addEventListener('click', function() {
                dampers.fresh1.open = !dampers.fresh1.open;
                this.textContent = dampers.fresh1.open ? 'باز' : 'بسته';
                updateDamper(objects.freshAirDamper1, dampers.fresh1.open);
            });
            
            document.getElementById('toggle-fresh-damper2').addEventListener('click', function() {
                dampers.fresh2.open = !dampers.fresh2.open;
                this.textContent = dampers.fresh2.open ? 'باز' : 'بسته';
                updateDamper(objects.freshAirDamper2, dampers.fresh2.open);
            });
            
            document.getElementById('toggle-exhaust-damper1').addEventListener('click', function() {
                dampers.exhaust1.open = !dampers.exhaust1.open;
                this.textContent = dampers.exhaust1.open ? 'باز' : 'بسته';
                updateDamper(objects.exhaustDamper1, dampers.exhaust1.open);
            });
            
            document.getElementById('toggle-exhaust-damper2').addEventListener('click', function() {
                dampers.exhaust2.open = !dampers.exhaust2.open;
                this.textContent = dampers.exhaust2.open ? 'باز' : 'بسته';
                updateDamper(objects.exhaustDamper2, dampers.exhaust2.open);
                dampers.return.open = !dampers.return.open;
                updateDamper(objects.returnDamper, dampers.return.open);
            });
        

            // Object visibility control
            document.getElementById('toggle-object-visibility').addEventListener('click', function() {
                if (selectedObject) {
                    selectedObject.visible = !selectedObject.visible;
                    this.classList.toggle('hidden');
                    this.textContent = selectedObject.visible ? 'پنهان کردن شیء' : 'نمایش شیء';
                }
            });
            
            document.getElementById('close-object-controls').addEventListener('click', function() {
                document.getElementById('object-controls').style.display = 'none';
                selectedObject = null;
            });
            
            // Add click event for objects
            renderer.domElement.addEventListener('click', onObjectClick, false);
            
            // Add touch event for mobile
            renderer.domElement.addEventListener('touchstart', onObjectClick, false);
        }
        
       
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function changeBackground() {
            const color = document.getElementById('bg-color').value;
            scene.background = new THREE.Color(color);
        }
        
        function updateLightIntensity() {
            const intensity = parseFloat(document.getElementById('light-intensity').value);
            objects.directionalLight.intensity = intensity;
            document.getElementById('light-value').textContent = intensity.toFixed(1);
        }
        
        function updateWallOpacity() {
            wallOpacity = parseInt(document.getElementById('wall-opacity').value) / 100;
            document.getElementById('opacity-value').textContent = Math.round(wallOpacity * 100);
            
            // Update all walls' opacity
            const walls = [
                objects.leftWall, objects.rightWall, objects.backWall, objects.frontWall,
                objects.towerLeftWall, objects.towerRightWall, objects.towerBackWall, objects.towerFrontWall,
                objects.returnWall
            ];
            
            walls.forEach(wall => {
                if (wall && wall.material) {
                    wall.material.opacity = wallOpacity;
                }
            });
        }
        
        function changeCameraAngle() {
            const angle = document.getElementById('camera-angle').value;
            
            switch(angle) {
                case 'top':
                    camera.position.set(0, 25, 0.1);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'front':
                    camera.position.set(0, 10, 30);
                    camera.lookAt(0, 5, 5);
                    break;
                case 'side':
                    camera.position.set(25, 12, 0);
                    camera.lookAt(0, 5, 0);
                    break;
                case 'supply-side':
                    camera.position.set(0, 15, -25);
                    camera.lookAt(0, 5, -5);
                    break;
                case 'return-side':
                    camera.position.set(0, 15, 25);
                    camera.lookAt(0, 5, 5);
                    break;
                default: // perspective
                    camera.position.set(15, 11, -17);
                    camera.lookAt(0, 3, 0);
                    break;
            }
            
            controls.update();
        }
        
        function resetView() {
            document.getElementById('camera-angle').value = 'perspective';
            changeCameraAngle();
        }
        
        function toggleWireframe() {
            wireframeVisible = !wireframeVisible;
            
            scene.traverse(function(child) {
                if (child.isMesh) {
                    child.material.wireframe = wireframeVisible;
                    
                    // Keep walls transparent
                    if (child.material.transparent) {
                        child.material.opacity = wallOpacity;
                    }
                }
            });
        }
        
        function onObjectClick(event) {
            event.preventDefault();
            
            // Check if we clicked on UI elements
            const uiElements = [
                document.getElementById('controls'),
                document.getElementById('info-panel'),
                document.getElementById('object-controls')
            ];
            
            const clickX = event.clientX || event.touches[0].clientX;
            const clickY = event.clientY || event.touches[0].clientY;
            
            for (const element of uiElements) {
                if (element) {
                    const rect = element.getBoundingClientRect();
                    if (clickX >= rect.left && clickX <= rect.right && 
                        clickY >= rect.top && clickY <= rect.bottom) {
                        return; // Click was on UI, ignore
                    }
                }
            }
            
            // Get mouse/touch position
            const mouse = new THREE.Vector2(
                (clickX / window.innerWidth) * 2 - 1,
                -(clickY / window.innerHeight) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                // Find the topmost parent that's in our objects list
                let parentObject = object;
                while (parentObject.parent && parentObject.parent !== scene) {
                    parentObject = parentObject.parent;
                }
                
                // Check if this is one of our main objects
                let found = false;
                for (const key in objects) {
                    if (objects[key] === parentObject || 
                        (objects[key].children && objects[key].children.includes(parentObject))) {
                        selectedObject = parentObject;
                        showObjectInfo(parentObject);
                        showObjectControls(parentObject);
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    // Check if it's a child of one of our main objects
                    for (const key in objects) {
                        if (objects[key] && objects[key].children) {
                            for (const child of objects[key].children) {
                                if (child === object) {
                                    selectedObject = objects[key];
                                    showObjectInfo(objects[key]);
                                    showObjectControls(objects[key]);
                                    found = true;
                                    break;
                                }
                            }
                            if (found) break;
                        }
                    }
                }
                
                if (!found) {
                    hideInfo();
                    document.getElementById('object-controls').style.display = 'none';
                    selectedObject = null;
                }
            }
        }
        
        function showObjectControls(object) {
            const objectControls = document.getElementById('object-controls');
            const toggleBtn = document.getElementById('toggle-object-visibility');
            
            toggleBtn.classList.toggle('hidden', !object.visible);
            toggleBtn.textContent = object.visible ? 'پنهان کردن شیء' : 'نمایش شیء';
            
            objectControls.style.display = 'block';
        }
        
        function showObjectInfo(object) {
            const infoPanel = document.getElementById('info-panel');
            const infoTitle = document.getElementById('info-title');
            const infoContent = document.getElementById('info-content');
            
            // Find the parent object name
            let objectName = '';
            for (const key in objects) {
                if (objects[key] === object || 
                    (objects[key].children && objects[key].children.includes(object))) {
                    objectName = key;
                    break;
                }
            }
            
            // Set info based on object
            if (objectName.includes('supplyFan')) {
                infoTitle.textContent = 'فن دمنده (رفت)';
                infoContent.innerHTML = `
                    <p><strong>نوع:</strong> فن پروانه‌ای دمنده</p>
                    <p><strong>قطر:</strong> ${fanDiameter} متر</p>
                    <p><strong>سرعت:</strong> ${fanSpeed} دور بر دقیقه</p>
                    <p><strong>موقعیت:</strong> دیواره بخش هوای رفت</p>
                    <p><strong>وظیفه:</strong> انتقال هوای تهویه شده به ساختمان</p>
                `;
            } 
            else if (objectName.includes('returnFan')) {
                infoTitle.textContent = 'فن مکنده (برگشت)';
                infoContent.innerHTML = `
                    <p><strong>نوع:</strong> فن پروانه‌ای مکنده (قدرتمند)</p>
                    <p><strong>قطر:</strong> ${fanDiameter} متر</p>
                    <p><strong>سرعت:</strong> ${fanSpeed} دور بر دقیقه</p>
                    <p><strong>موقعیت:</strong> دیواره جداکننده بخش برگشت</p>
                    <p><strong>وظیفه:</strong> مکش هوای برگشتی از ساختمان</p>
                `;
            }
            else if (objectName.includes('filter')) {
                infoTitle.textContent = 'فیلتر روتاری';
                infoContent.innerHTML = `
                    <p><strong>نوع:</strong> فیلتر دوار</p>
                    <p><strong>قطر:</strong> 2.5 متر</p>
                    <p><strong>طول:</strong> 5.1 متر</p>
                    <p><strong>سرعت:</strong> ${filterSpeed} دور بر دقیقه</p>
                    <p><strong>موقعیت:</strong> بخش هوای برگشت - موازی با دیوارها</p>
                    <p><strong>وظیفه:</strong> تصفیه هوای برگشتی قبل از ورود به سیستم</p>
                `;
            }
            else if (objectName.includes('pit')) {
                infoTitle.textContent = 'حفره زیر فیلتر';
                infoContent.innerHTML = `
                    <p><strong>عمق:</strong> 2 متر</p>
                    <p><strong>ابعاد:</strong> 3 × 6 متر</p>
                    <p><strong>وظیفه:</strong> جمع‌آوری ذرات و آلودگی‌های جدا شده توسط فیلتر</p>
                `;
            }
            else if (objectName.includes('returnWall')) {
                infoTitle.textContent = 'دیوار جداکننده با فن‌ها';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 8 × 5 متر (عرض × ارتفاع)</p>
                    <p><strong>ضخامت:</strong> 0.4 متر</p>
                    <p><strong>ویژگی:</strong> دارای دو سوراخ برای نصب فن‌های برگشت</p>
                `;
            }
            else if (objectName.includes('freshAirDamper')) {
                infoTitle.textContent = 'دمپر هوای تازه';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 1.5 × 1.5 متر</p>
                    <p><strong>ضخامت:</strong> 0.3 متر</p>
                    <p><strong>موقعیت:</strong> برجک - سمت هوای رفت</p>
                    <p><strong>وظیفه:</strong> ورود هوای تازه به سیستم</p>
                    <p><strong>وضعیت:</strong> ${objectName.includes('1') ? 
                        (dampers.fresh1.open ? 'باز' : 'بسته') : 
                        (dampers.fresh2.open ? 'باز' : 'بسته')}</p>
                `;
            }
            else if (objectName.includes('exhaustDamper')) {
                infoTitle.textContent = 'دمپر هوای خروجی';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 1.5 × 1.5 متر</p>
                    <p><strong>ضخامت:</strong> 0.3 متر</p>
                    <p><strong>موقعیت:</strong> برجک - سمت هوای برگشت</p>
                    <p><strong>وظیفه:</strong> خروج هوای آلوده از سیستم</p>
                    <p><strong>وضعیت:</strong> ${objectName.includes('1') ? 
                        (dampers.exhaust1.open ? 'باز' : 'بسته') : 
                        (dampers.exhaust2.open ? 'باز' : 'بسته')}</p>
                `;
            }
            else if (objectName.includes('supplyDuct')) {
                infoTitle.textContent = 'داکت هوای رفت';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 1200 × 800 میلی‌متر</p>
                    <p><strong>وظیفه:</strong> انتقال هوای تهویه شده به ساختمان</p>
                `;
            }
            else if (objectName.includes('returnDuct')) {
                infoTitle.textContent = 'داکت هوای برگشت';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 1200 × 800 میلی‌متر</p>
                    <p><strong>وظیفه:</strong> انتقال هوای برگشتی از ساختمان</p>
                `;
            }
            else if (objectName.includes('grille')) {
                infoTitle.textContent = 'گریل برگشت هوا';
                infoContent.innerHTML = `
                    <p><strong>موقعیت:</strong> کف بخش برگشت هوا</p>
                    <p><strong>ابعاد:</strong> 1200 × 800 میلی‌متر</p>
                    <p><strong>وظیفه:</strong> جمع‌آوری هوای برگشتی از ساختمان</p>
                `;
            }
            else if (objectName.includes('fogger')) {
                const foggerNum = objectName.includes('1') ? '1' : '2';
                infoTitle.textContent = `مه‌پاش ${foggerNum}`;
                infoContent.innerHTML = `
                    <p><strong>موقعیت:</strong> بخش رفت هوا</p>
                    <p><strong>سیستم:</strong> پمپ پلانجر فشار بالا با آب تصفیه شده</p>
                    <p><strong>لوله‌ها:</strong> لوله‌های عمودی 1 اینچی هر 30 سانتیمتر</p>
                    <p><strong>وضعیت:</strong> ${foggers[`fogger${foggerNum}`].active ? 'روشن' : 'خاموش'}</p>
                    <p><strong>شدت پاشش:</strong> ${Math.round(foggers[`fogger${foggerNum}`].intensity * 100)}%</p>
                `;
            }
            else if (objectName.includes('eliminator')) {
                infoTitle.textContent = 'الیمیناتور (قطره‌گیر)';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 6000 × 4000 میلی‌متر</p>
                    <p><strong>طول پره‌ها:</strong> 350 میلی‌متر</p>
                    <p><strong>موقعیت:</strong> بخش رفت هوا بعد از مه‌پاش‌ها</p>
                    <p><strong>وظیفه:</strong> جمع‌آوری قطرات آب از هوا</p>
                    <p><strong>حوضچه جمع‌آوری:</strong> در پایین الیمیناتور</p>
                `;
            }
            else if (objectName.includes('tower')) {
                infoTitle.textContent = 'برجک تهویه';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 6 × 4 × 5 متر (عرض × عمق × ارتفاع)</p>
                    <p><strong>موقعیت:</strong> روی سقف اتاق تهویه - مرکز</p>
                    <p><strong>ویژگی‌ها:</strong> 
                        <ul>
                            <li>2 دمپر ورود هوای تازه (سمت رفت)</li>
                            <li>2 دمپر خروج هوای آلوده (سمت برگشت)</li>
                        </ul>
                    </p>
                `;
            }
            else if (objectName.includes('ventRoom')) {
                infoTitle.textContent = 'اتاق تهویه';
                infoContent.innerHTML = `
                    <p><strong>ابعاد:</strong> 8 × 25 × 5 متر (عرض × عمق × ارتفاع)</p>
                    <p><strong>جزئیات ساختار:</strong> 
                        <ul>
                            <li>ضخامت دیوارها: 0.4 متر</li>
                            <li>ضخامت سقف: 0.3 متر</li>
                            <li>شفافیت دیوارها: ${Math.round(wallOpacity * 100)}%</li>
                        </ul>
                    </p>
                    <p><strong>تجهیزات:</strong> شامل فن‌ها، فیلترها، دمپرها و سیستم مه‌پاش</p>
                `;
            }
            else if (objectName.includes('leftWall') || objectName.includes('rightWall') || 
                     objectName.includes('backWall') || objectName.includes('frontWall')) {
                infoTitle.textContent = 'دیوار اتاق تهویه';
                infoContent.innerHTML = `
                    <p><strong>ضخامت:</strong> 0.4 متر</p>
                    <p><strong>شفافیت:</strong> ${Math.round(wallOpacity * 100)}%</p>
                    <p><strong>جنس:</strong> پانل‌های فلزی با عایق صوتی</p>
                `;
            }
            else if (objectName.includes('ceiling')) {
                infoTitle.textContent = 'سقف اتاق تهویه';
                infoContent.innerHTML = `
                    <p><strong>ضخامت:</strong> 0.3 متر</p>
                    <p><strong>جنس:</strong> پانل‌های فلزی با عایق حرارتی</p>
                `;
            }
            else if (objectName.includes('floor')) {
                infoTitle.textContent = 'کف اتاق تهویه';
                infoContent.innerHTML = `
                    <p><strong>ضخامت:</strong> 0.2 متر</p>
                    <p><strong>جنس:</strong> بتن مسلح با پوشش ضد لغزش</p>
                `;
            }
            else {
                infoTitle.textContent = 'جزئیات تجهیزات';
                infoContent.textContent = 'اطلاعات دقیق‌تر برای این بخش در دسترس نیست.';
            }
            
            infoPanel.style.display = 'block';
        }
        
        function hideInfo() {
            document.getElementById('info-panel').style.display = 'none';
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate fans with adjustable speed (convert RPM to radians per frame)
            const fanRadPerFrame = (fanSpeed / 60) * Math.PI * 2 / 60;
            if (objects.supplyFan1) objects.supplyFan1.rotation.z += fanRadPerFrame;
            if (objects.supplyFan2) objects.supplyFan2.rotation.z += fanRadPerFrame;
            if (objects.returnFan1) objects.returnFan1.rotation.z += fanRadPerFrame;
            if (objects.returnFan2) objects.returnFan2.rotation.z += fanRadPerFrame;
            if (objects.supplyFan3) objects.supplyFan3.rotation.z += fanRadPerFrame;
            
            // Rotate filters with adjustable speed (slower than fans)
            const filterRadPerFrame = (filterSpeed / 60) * Math.PI * 2 / 60;
            if (objects.filter1) objects.filter1.rotation.z += filterRadPerFrame;
            if (objects.filter2) objects.filter2.rotation.z += filterRadPerFrame;
            
            controls.update();
            renderer.render(scene, camera);
        }
        
    </script>
</body>
</html>