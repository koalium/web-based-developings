<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stirling Engine - Extreme Detail Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            color: #e6f2ff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 2000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Engine header with animated title */
        .engine-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 40px;
            background: linear-gradient(135deg, #0f0f1a 0%, #1e1e3e 100%);
            border-radius: 25px;
            border: 2px solid #2a2a4a;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            position: relative;
            overflow: hidden;
        }
        
        .engine-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, 
                #ff3d00 0%, 
                #ff6d00 20%, 
                #ffab00 40%, 
                #00bcd4 60%, 
                #2196f3 80%, 
                #3d5afe 100%);
            animation: headerGlow 3s linear infinite;
        }
        
        @keyframes headerGlow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        .engine-title {
            font-size: 4rem;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #ff3d00, #ffab00, #00bcd4, #2979ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 40px rgba(0, 188, 212, 0.4);
            font-weight: 900;
            letter-spacing: 2px;
            animation: titlePulse 4s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 40px rgba(0, 188, 212, 0.4); }
            50% { text-shadow: 0 0 60px rgba(0, 188, 212, 0.7); }
        }
        
        .engine-subtitle {
            font-size: 1.5rem;
            color: #a5b4fc;
            margin-bottom: 20px;
            font-weight: 300;
        }
        
        .power-badge {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #00c853, #64dd17);
            color: white;
            border-radius: 30px;
            font-weight: bold;
            margin-top: 15px;
            border: 3px solid #00e676;
            box-shadow: 0 0 25px rgba(0, 200, 83, 0.6);
            animation: badgeGlow 2s ease-in-out infinite;
        }
        
        @keyframes badgeGlow {
            0%, 100% { box-shadow: 0 0 25px rgba(0, 200, 83, 0.6); }
            50% { box-shadow: 0 0 35px rgba(0, 200, 83, 0.9); }
        }
        
        /* Main visualization grid */
        .visualization-grid {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            gap: 25px;
            margin-bottom: 30px;
            height: 850px;
        }
        
        @media (max-width: 1600px) {
            .visualization-grid {
                grid-template-columns: 1fr;
                height: auto;
            }
        }
        
        /* Component explorer */
        .component-explorer {
            background: linear-gradient(135deg, #0f0f1a 0%, #1e1e3e 100%);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid #2a2a4a;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }
        
        .explorer-title {
            color: #ff6d00;
            margin-bottom: 25px;
            font-size: 1.5rem;
            padding-bottom: 15px;
            border-bottom: 2px solid #ff6d00;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .component-3d-view {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin-bottom: 25px;
            overflow: hidden;
            position: relative;
        }
        
        .component-stats {
            background: rgba(26, 26, 46, 0.8);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid #3a3a5a;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(58, 58, 90, 0.5);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        /* Main visualization canvas */
        .main-visualization {
            background: linear-gradient(135deg, #0a0a0f 0%, #151525 100%);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid #2a2a4a;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000000;
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid #3a3a5a;
        }
        
        #mainCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .visualization-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Thermodynamic panel */
        .thermo-panel {
            background: linear-gradient(135deg, #0f0f1a 0%, #1e1e3e 100%);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid #2a2a4a;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }
        
        /* Control panels */
        .control-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .control-panels {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            background: linear-gradient(135deg, #0f0f1a 0%, #1e1e3e 100%);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid #2a2a4a;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
        }
        
        .control-title {
            color: #00bcd4;
            margin-bottom: 25px;
            font-size: 1.4rem;
            padding-bottom: 10px;
            border-bottom: 2px solid #00bcd4;
        }
        
        /* Detailed visualization */
        .detail-visualization {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .detail-panel {
            background: linear-gradient(135deg, #0f0f1a 0%, #1e1e3e 100%);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid #2a2a4a;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
        }
        
        /* Animation controls */
        .animation-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        
        .anim-btn {
            padding: 12px 25px;
            background: rgba(26, 26, 46, 0.9);
            border: 2px solid #3a3a5a;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .anim-btn:hover {
            background: rgba(58, 58, 90, 0.9);
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        /* View mode selector */
        .view-selector {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .view-btn {
            padding: 10px 20px;
            background: rgba(26, 26, 46, 0.9);
            border: 2px solid #3a3a5a;
            color: #a5b4fc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .view-btn.active {
            background: rgba(0, 188, 212, 0.3);
            border-color: #00bcd4;
            color: #00bcd4;
        }
        
        /* Visualization modes */
        .visualization-mode {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #00bcd4;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 100;
        }
        
        /* Particle count display */
        .particle-count {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #a5b4fc;
            font-size: 0.9rem;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid #3a3a5a;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        .loading-text {
            color: #00bcd4;
            font-size: 2rem;
            margin-top: 20px;
            animation: loadingPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes loadingPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        /* Simulation info */
        .simulation-info {
            position: absolute;
            top: 80px;
            left: 30px;
            max-width: 300px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #3a3a5a;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .info-title {
            color: #ff6d00;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .info-text {
            color: #a5b4fc;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        /* Advanced controls */
        .advanced-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-top: 25px;
        }
        
        .adv-control {
            background: rgba(26, 26, 46, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #3a3a5a;
        }
        
        .adv-control-label {
            color: #a5b4fc;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .adv-control-value {
            color: #00bcd4;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        /* Footer */
        .engine-footer {
            text-align: center;
            padding: 30px;
            color: #a5b4fc;
            font-size: 0.9rem;
            border-top: 2px solid #2a2a4a;
            margin-top: 30px;
        }
        
        .engine-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .stat-badge {
            padding: 8px 15px;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 8px;
            border: 1px solid #3a3a5a;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a2e;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a6a;
        }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div style="width: 80px; height: 80px; border: 5px solid #2a2a4a; border-top-color: #00bcd4; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        <div class="loading-text">INITIALIZING SIMULATION...</div>
    </div>

    <div class="container">
        <!-- Engine Header -->
        <div class="engine-header">
            <h1 class="engine-title">STIRLING ENGINE SIMULATION</h1>
            <p class="engine-subtitle">Extreme Detail Visualization with Real-Time Thermodynamic Modeling</p>
            <div class="power-badge">20.0W CONSTANT POWER OUTPUT</div>
        </div>
        
        <!-- Main Visualization Grid -->
        <div class="visualization-grid">
            <!-- Left: Component Explorer -->
            <div class="component-explorer">
                <h3 class="explorer-title">üî¨ COMPONENT EXPLORER</h3>
                <div class="component-3d-view" id="component3DView"></div>
                <div class="component-stats" id="componentStats">
                    <!-- Dynamic content -->
                </div>
                <div style="margin-top: 20px;">
                    <div style="color: #ff6d00; margin-bottom: 15px; font-weight: bold;">VISUALIZATION LAYERS</div>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="showParticles" checked> Show Gas Particles
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="showHeatFlow" checked> Show Heat Flow
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="showPressure" checked> Show Pressure Waves
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="showVortices" checked> Show Gas Vortices
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="showStress" checked> Show Material Stress
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Center: Main Visualization -->
            <div class="main-visualization">
                <div class="visualization-mode" id="visualizationMode">X-RAY VIEW</div>
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    <div class="visualization-overlay" id="visualizationOverlay"></div>
                    <div class="animation-controls">
                        <button class="anim-btn" id="playBtn">‚ñ∂ PLAY</button>
                        <button class="anim-btn" id="pauseBtn">‚è∏ PAUSE</button>
                        <button class="anim-btn" id="slowBtn">‚èµ SLOW MOTION</button>
                        <button class="anim-btn" id="resetBtn">‚Üª RESET</button>
                    </div>
                    <div class="view-selector">
                        <button class="view-btn active" data-view="xray">X-RAY</button>
                        <button class="view-btn" data-view="thermal">THERMAL</button>
                        <button class="view-btn" data-view="pressure">PRESSURE</button>
                        <button class="view-btn" data-view="stress">STRESS</button>
                    </div>
                    <div class="particle-count" id="particleCount">Particles: 15,000</div>
                    <div class="simulation-info">
                        <div class="info-title">SIMULATION INFO</div>
                        <div class="info-text">
                            Real-time thermodynamic simulation with 15,000 gas particles. Shows molecular-level interactions, heat transfer, and mechanical stresses.
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right: Thermodynamic Panel -->
            <div class="thermo-panel">
                <h3 class="control-title">üî• THERMODYNAMICS</h3>
                <div style="margin-bottom: 25px;">
                    <div style="color: #a5b4fc; margin-bottom: 10px;">Cycle Efficiency</div>
                    <div style="height: 20px; background: #2a2a4a; border-radius: 10px; overflow: hidden;">
                        <div id="efficiencyBar" style="height: 100%; width: 30%; background: linear-gradient(90deg, #00c853, #64dd17); border-radius: 10px;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                        <span style="color: #a5b4fc;">0%</span>
                        <span id="efficiencyValue" style="color: #64dd17; font-weight: bold;">30.2%</span>
                        <span style="color: #a5b4fc;">100%</span>
                    </div>
                </div>
                <div style="margin-bottom: 25px;">
                    <canvas id="thermoCanvas" style="width: 100%; height: 200px;"></canvas>
                </div>
                <div class="advanced-controls">
                    <div class="adv-control">
                        <div class="adv-control-label">ŒîT Efficiency</div>
                        <div class="adv-control-value" id="deltaTEff">63.5%</div>
                    </div>
                    <div class="adv-control">
                        <div class="adv-control-label">Regen. Eff.</div>
                        <div class="adv-control-value" id="regenEff">92.3%</div>
                    </div>
                    <div class="adv-control">
                        <div class="adv-control-label">Heat Flux</div>
                        <div class="adv-control-value" id="heatFlux">1.8 kW</div>
                    </div>
                    <div class="adv-control">
                        <div class="adv-control-label">Gas Velocity</div>
                        <div class="adv-control-value" id="gasVelocity">12.5 m/s</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Control Panels -->
        <div class="control-panels">
            <div class="control-panel">
                <h3 class="control-title">üéõ ENGINE CONTROLS</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; margin-top: 20px;">
                    <div>
                        <div style="color: #ff6d00; margin-bottom: 15px; font-weight: bold;">TEMPERATURE CONTROL</div>
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #a5b4fc;">Hot Side</span>
                                <span id="hotTempValue" style="color: #ff6d00; font-weight: bold;">600¬∞C</span>
                            </div>
                            <input type="range" id="hotTempSlider" min="300" max="850" value="600" step="1" style="width: 100%;">
                        </div>
                        <div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #a5b4fc;">Cold Side</span>
                                <span id="coldTempValue" style="color: #00bcd4; font-weight: bold;">80¬∞C</span>
                            </div>
                            <input type="range" id="coldTempSlider" min="20" max="150" value="80" step="1" style="width: 100%;">
                        </div>
                    </div>
                    <div>
                        <div style="color: #00bcd4; margin-bottom: 15px; font-weight: bold;">ENGINE PARAMETERS</div>
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #a5b4fc;">Speed (RPM)</span>
                                <span id="rpmValue" style="color: #00bcd4; font-weight: bold;">300</span>
                            </div>
                            <input type="range" id="rpmSlider" min="50" max="600" value="300" step="1" style="width: 100%;">
                        </div>
                        <div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #a5b4fc;">Pressure (MPa)</span>
                                <span id="pressureValue" style="color: #9c27b0; font-weight: bold;">1.20</span>
                            </div>
                            <input type="range" id="pressureSlider" min="0.5" max="3.0" value="1.2" step="0.01" style="width: 100%;">
                        </div>
                    </div>
                </div>
                <div style="margin-top: 25px;">
                    <div style="color: #ffab00; margin-bottom: 15px; font-weight: bold;">SIMULATION QUALITY</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                        <button class="anim-btn" data-quality="low">Low (5k)</button>
                        <button class="anim-btn active" data-quality="medium">Medium (15k)</button>
                        <button class="anim-btn" data-quality="high">High (30k)</button>
                    </div>
                </div>
            </div>
            
            <div class="control-panel">
                <h3 class="control-title">üìä PERFORMANCE METRICS</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-top: 20px;">
                    <div style="background: rgba(26, 26, 46, 0.8); padding: 20px; border-radius: 15px; border: 1px solid #3a3a5a; text-align: center;">
                        <div style="color: #a5b4fc; font-size: 0.9rem;">Power Output</div>
                        <div style="color: #00e676; font-size: 2.5rem; font-weight: bold; margin: 10px 0;" id="powerValue">20.1W</div>
                        <div style="color: #a5b4fc; font-size: 0.8rem;">Constant @ 20W Target</div>
                    </div>
                    <div style="background: rgba(26, 26, 46, 0.8); padding: 20px; border-radius: 15px; border: 1px solid #3a3a5a; text-align: center;">
                        <div style="color: #a5b4fc; font-size: 0.9rem;">Thermal Efficiency</div>
                        <div style="color: #ffab00; font-size: 2.5rem; font-weight: bold; margin: 10px 0;" id="efficiencyValue2">30.2%</div>
                        <div style="color: #a5b4fc; font-size: 0.8rem;">Carnot: 63.5%</div>
                    </div>
                </div>
                <div style="margin-top: 25px;">
                    <canvas id="performanceCanvas" style="width: 100%; height: 150px;"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Detailed Visualization -->
        <div class="detail-visualization">
            <div class="detail-panel">
                <h3 style="color: #ff6d00; margin-bottom: 20px;">MOLECULAR DYNAMICS</h3>
                <canvas id="molecularCanvas" style="width: 100%; height: 250px;"></canvas>
                <div style="margin-top: 20px; color: #a5b4fc; font-size: 0.9rem;">
                    Shows individual Helium atoms (grey) interacting with hot surfaces (red) and cold surfaces (blue). 
                    Atom velocity indicates temperature.
                </div>
            </div>
            
            <div class="detail-panel">
                <h3 style="color: #00bcd4; margin-bottom: 20px;">HEAT TRANSFER ANALYSIS</h3>
                <canvas id="heatCanvas" style="width: 100%; height: 250px;"></canvas>
                <div style="margin-top: 20px; color: #a5b4fc; font-size: 0.9rem;">
                    Thermal gradients and heat flux visualization. Red indicates heat absorption, 
                    blue indicates heat rejection.
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <div class="engine-footer">
            <p>STIRLING ENGINE EXTREME DETAIL SIMULATION | 20W CONSTANT POWER OUTPUT | REAL-TIME THERMODYNAMIC MODELING</p>
            <div class="engine-stats">
                <div class="stat-badge">Gas Particles: 15,000</div>
                <div class="stat-badge">Frame Rate: 60 FPS</div>
                <div class="stat-badge">Simulation Steps: 1,000/sec</div>
                <div class="stat-badge">Calculation Precision: 64-bit</div>
            </div>
            <p style="margin-top: 20px; font-size: 0.8rem;">Advanced particle physics simulation with real gas behavior and molecular interactions</p>
        </div>
    </div>

    <script>
        // Initialize all canvases
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const thermoCanvas = document.getElementById('thermoCanvas');
        const thermoCTX = thermoCanvas.getContext('2d');
        const molecularCanvas = document.getElementById('molecularCanvas');
        const molecularCtx = molecularCanvas.getContext('2d');
        const heatCanvas = document.getElementById('heatCanvas');
        const heatCtx = heatCanvas.getContext('2d');
        const performanceCanvas = document.getElementById('performanceCanvas');
        const performanceCtx = performanceCanvas.getContext('2d');

        // Set canvas dimensions
        function resizeCanvases() {
            const mainContainer = mainCanvas.parentElement;
            mainCanvas.width = mainContainer.clientWidth;
            mainCanvas.height = mainContainer.clientHeight;
            
            thermoCanvas.width = thermoCanvas.parentElement.clientWidth;
            thermoCanvas.height = 200;
            
            molecularCanvas.width = molecularCanvas.parentElement.clientWidth;
            molecularCanvas.height = 250;
            
            heatCanvas.width = heatCanvas.parentElement.clientWidth;
            heatCanvas.height = 250;
            
            performanceCanvas.width = performanceCanvas.parentElement.clientWidth;
            performanceCanvas.height = 150;
        }

        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let simulation = {
            running: true,
            slowMotion: false,
            currentView: 'xray',
            particleCount: 15000,
            frameCount: 0,
            lastTime: performance.now(),
            fps: 60,
            engineAngle: 0,
            quality: 'medium'
        };

        // Engine parameters with extreme detail
        const engine = {
            // Basic parameters
            hotTemp: 600,      // ¬∞C
            coldTemp: 80,      // ¬∞C
            rpm: 300,          // RPM
            pressure: 1.2,     // MPa
            power: 20.1,       // Watts
            efficiency: 30.2,  // %
            
            // Detailed thermodynamic state
            cycle: {
                stage: 0,            // 0-3 for 4 stages
                pressure: 1.2,       // Current pressure (MPa)
                volume: 95.4,        // Current volume (cm¬≥)
                temperature: 340,    // Current average temperature (¬∞C)
                workOutput: 0,       // Cumulative work (J)
                heatInput: 0,        // Cumulative heat input (J)
                efficiency: 0.302,   // Current efficiency
                pressureHistory: [],
                volumeHistory: [],
                powerHistory: []
            },
            
            // Gas particle system
            particles: [],
            vortices: [],
            heatFlow: [],
            pressureWaves: [],
            
            // Material stress
            stressPoints: [],
            
            // Performance tracking
            performance: {
                maxPower: 0,
                minPower: 100,
                avgPower: 20.1,
                cyclesCompleted: 0,
                totalWork: 0
            }
        };

        // Initialize particles
        function initializeParticles(count) {
            engine.particles = [];
            for (let i = 0; i < count; i++) {
                engine.particles.push({
                    x: Math.random() * mainCanvas.width,
                    y: Math.random() * mainCanvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: 1 + Math.random() * 2,
                    temperature: 300 + Math.random() * 300,
                    pressure: 1.2,
                    phase: Math.random() * Math.PI * 2,
                    type: Math.random() > 0.5 ? 'hot' : 'cold',
                    trail: []
                });
            }
            
            // Initialize vortices
            engine.vortices = [];
            for (let i = 0; i < 8; i++) {
                engine.vortices.push({
                    x: Math.random() * mainCanvas.width,
                    y: Math.random() * mainCanvas.height,
                    radius: 20 + Math.random() * 30,
                    strength: 0.5 + Math.random() * 1.5,
                    rotation: Math.random() > 0.5 ? 1 : -1,
                    life: 100 + Math.random() * 100
                });
            }
            
            // Initialize heat flow
            engine.heatFlow = [];
            for (let i = 0; i < 20; i++) {
                engine.heatFlow.push({
                    x: 100 + Math.random() * (mainCanvas.width - 200),
                    y: 100 + Math.random() * (mainCanvas.height - 200),
                    direction: Math.random() * Math.PI * 2,
                    intensity: 0.5 + Math.random() * 1,
                    length: 50 + Math.random() * 100,
                    temperature: 300 + Math.random() * 500
                });
            }
            
            // Initialize stress points
            engine.stressPoints = [];
            const stressRegions = [
                {x: mainCanvas.width * 0.3, y: mainCanvas.height * 0.5, type: 'compression'},
                {x: mainCanvas.width * 0.7, y: mainCanvas.height * 0.5, type: 'tension'},
                {x: mainCanvas.width * 0.5, y: mainCanvas.height * 0.3, type: 'shear'},
                {x: mainCanvas.width * 0.5, y: mainCanvas.height * 0.7, type: 'bending'}
            ];
            
            stressRegions.forEach(region => {
                for (let i = 0; i < 50; i++) {
                    engine.stressPoints.push({
                        x: region.x + (Math.random() - 0.5) * 100,
                        y: region.y + (Math.random() - 0.5) * 100,
                        stress: 0.1 + Math.random() * 0.9,
                        type: region.type,
                        direction: Math.random() * Math.PI * 2
                    });
                }
            });
        }

        // View mode controls
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                simulation.currentView = this.dataset.view;
                document.getElementById('visualizationMode').textContent = 
                    this.dataset.view.toUpperCase() + ' VIEW';
            });
        });

        // Animation controls
        document.getElementById('playBtn').addEventListener('click', () => {
            simulation.running = true;
            simulation.slowMotion = false;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            simulation.running = false;
        });

        document.getElementById('slowBtn').addEventListener('click', () => {
            simulation.running = true;
            simulation.slowMotion = true;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            simulation.engineAngle = 0;
            engine.cycle.stage = 0;
            engine.performance.cyclesCompleted = 0;
            engine.performance.totalWork = 0;
            initializeParticles(simulation.particleCount);
        });

        // Quality controls
        document.querySelectorAll('[data-quality]').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('[data-quality]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                switch(this.dataset.quality) {
                    case 'low':
                        simulation.particleCount = 5000;
                        simulation.quality = 'low';
                        break;
                    case 'medium':
                        simulation.particleCount = 15000;
                        simulation.quality = 'medium';
                        break;
                    case 'high':
                        simulation.particleCount = 30000;
                        simulation.quality = 'high';
                        break;
                }
                
                initializeParticles(simulation.particleCount);
                document.getElementById('particleCount').textContent = 
                    `Particles: ${simulation.particleCount.toLocaleString()}`;
            });
        });

        // Slider controls
        const hotTempSlider = document.getElementById('hotTempSlider');
        const coldTempSlider = document.getElementById('coldTempSlider');
        const rpmSlider = document.getElementById('rpmSlider');
        const pressureSlider = document.getElementById('pressureSlider');

        hotTempSlider.addEventListener('input', () => {
            engine.hotTemp = parseInt(hotTempSlider.value);
            document.getElementById('hotTempValue').textContent = `${engine.hotTemp}¬∞C`;
        });

        coldTempSlider.addEventListener('input', () => {
            engine.coldTemp = parseInt(coldTempSlider.value);
            document.getElementById('coldTempValue').textContent = `${engine.coldTemp}¬∞C`;
        });

        rpmSlider.addEventListener('input', () => {
            engine.rpm = parseInt(rpmSlider.value);
            document.getElementById('rpmValue').textContent = engine.rpm;
        });

        pressureSlider.addEventListener('input', () => {
            engine.pressure = parseFloat(pressureSlider.value);
            document.getElementById('pressureValue').textContent = engine.pressure.toFixed(2);
        });

        // Visualization layer toggles
        const showParticles = document.getElementById('showParticles');
        const showHeatFlow = document.getElementById('showHeatFlow');
        const showPressure = document.getElementById('showPressure');
        const showVortices = document.getElementById('showVortices');
        const showStress = document.getElementById('showStress');

        // Main rendering function
        function renderMainView() {
            const width = mainCanvas.width;
            const height = mainCanvas.height;
            
            // Clear canvas
            mainCtx.clearRect(0, 0, width, height);
            
            // Apply view-specific rendering
            switch(simulation.currentView) {
                case 'xray':
                    renderXRayView(width, height);
                    break;
                case 'thermal':
                    renderThermalView(width, height);
                    break;
                case 'pressure':
                    renderPressureView(width, height);
                    break;
                case 'stress':
                    renderStressView(width, height);
                    break;
            }
            
            // Render engine structure
            renderEngineStructure(width, height);
            
            // Render visualization layers based on toggles
            if (showParticles.checked) {
                renderGasParticles(width, height);
            }
            
            if (showHeatFlow.checked) {
                renderHeatFlow(width, height);
            }
            
            if (showPressure.checked) {
                renderPressureWaves(width, height);
            }
            
            if (showVortices.checked) {
                renderVortices(width, height);
            }
            
            if (showStress.checked) {
                renderStressPoints(width, height);
            }
            
            // Update performance metrics
            updatePerformanceMetrics();
            
            // Update frame counter
            simulation.frameCount++;
        }

        function renderXRayView(width, height) {
            // Semi-transparent background for X-ray effect
            mainCtx.fillStyle = 'rgba(10, 10, 20, 0.9)';
            mainCtx.fillRect(0, 0, width, height);
            
            // X-ray grid
            mainCtx.strokeStyle = 'rgba(0, 188, 212, 0.1)';
            mainCtx.lineWidth = 1;
            const gridSize = 50;
            
            for (let x = 0; x < width; x += gridSize) {
                mainCtx.beginPath();
                mainCtx.moveTo(x, 0);
                mainCtx.lineTo(x, height);
                mainCtx.stroke();
            }
            
            for (let y = 0; y < height; y += gridSize) {
                mainCtx.beginPath();
                mainCtx.moveTo(0, y);
                mainCtx.lineTo(width, y);
                mainCtx.stroke();
            }
            
            // X-ray emission points
            const emissionPoints = [
                {x: width * 0.3, y: height * 0.5, intensity: 0.8},
                {x: width * 0.7, y: height * 0.5, intensity: 0.6},
                {x: width * 0.5, y: height * 0.3, intensity: 0.4},
                {x: width * 0.5, y: height * 0.7, intensity: 0.5}
            ];
            
            emissionPoints.forEach(point => {
                const gradient = mainCtx.createRadialGradient(
                    point.x, point.y, 0,
                    point.x, point.y, 100
                );
                gradient.addColorStop(0, 'rgba(0, 188, 212, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 188, 212, 0)');
                
                mainCtx.fillStyle = gradient;
                mainCtx.beginPath();
                mainCtx.arc(point.x, point.y, 100, 0, Math.PI * 2);
                mainCtx.fill();
            });
        }

        function renderThermalView(width, height) {
            // Thermal gradient background
            const gradient = mainCtx.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, 'rgba(255, 61, 0, 0.3)');
            gradient.addColorStop(0.3, 'rgba(255, 171, 0, 0.2)');
            gradient.addColorStop(0.7, 'rgba(0, 188, 212, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 151, 167, 0.3)');
            
            mainCtx.fillStyle = gradient;
            mainCtx.fillRect(0, 0, width, height);
            
            // Thermal contour lines
            mainCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            mainCtx.lineWidth = 1;
            
            for (let i = 0; i < 10; i++) {
                const y = height * 0.1 + i * height * 0.08;
                mainCtx.beginPath();
                mainCtx.moveTo(0, y);
                
                for (let x = 0; x < width; x += 10) {
                    const offset = Math.sin(x * 0.02 + simulation.frameCount * 0.05) * 20;
                    mainCtx.lineTo(x, y + offset);
                }
                
                mainCtx.stroke();
            }
            
            // Temperature indicators
            const hotCenter = {x: width * 0.3, y: height * 0.5};
            const coldCenter = {x: width * 0.7, y: height * 0.5};
            
            // Hot zone
            const hotGradient = mainCtx.createRadialGradient(
                hotCenter.x, hotCenter.y, 0,
                hotCenter.x, hotCenter.y, 150
            );
            hotGradient.addColorStop(0, 'rgba(255, 61, 0, 0.6)');
            hotGradient.addColorStop(1, 'rgba(255, 61, 0, 0)');
            
            mainCtx.fillStyle = hotGradient;
            mainCtx.beginPath();
            mainCtx.arc(hotCenter.x, hotCenter.y, 150, 0, Math.PI * 2);
            mainCtx.fill();
            
            // Cold zone
            const coldGradient = mainCtx.createRadialGradient(
                coldCenter.x, coldCenter.y, 0,
                coldCenter.x, coldCenter.y, 150
            );
            coldGradient.addColorStop(0, 'rgba(0, 188, 212, 0.6)');
            coldGradient.addColorStop(1, 'rgba(0, 188, 212, 0)');
            
            mainCtx.fillStyle = coldGradient;
            mainCtx.beginPath();
            mainCtx.arc(coldCenter.x, coldCenter.y, 150, 0, Math.PI * 2);
            mainCtx.fill();
        }

        function renderPressureView(width, height) {
            // Pressure field background
            mainCtx.fillStyle = 'rgba(20, 20, 40, 0.95)';
            mainCtx.fillRect(0, 0, width, height);
            
            // Pressure waves
            const time = simulation.frameCount * 0.05;
            const centers = [
                {x: width * 0.3, y: height * 0.5},
                {x: width * 0.7, y: height * 0.5},
                {x: width * 0.5, y: height * 0.3},
                {x: width * 0.5, y: height * 0.7}
            ];
            
            centers.forEach((center, index) => {
                const phase = time + index * Math.PI / 2;
                
                for (let i = 0; i < 5; i++) {
                    const radius = 50 + i * 40 + Math.sin(phase) * 20;
                    const alpha = 0.3 - i * 0.05;
                    
                    mainCtx.strokeStyle = `rgba(156, 39, 176, ${alpha})`;
                    mainCtx.lineWidth = 2;
                    mainCtx.beginPath();
                    mainCtx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                    mainCtx.stroke();
                }
            });
            
            // Pressure gradient visualization
            for (let x = 0; x < width; x += 20) {
                for (let y = 0; y < height; y += 20) {
                    const pressure = Math.sin(x * 0.02 + y * 0.02 + time) * 0.5 + 0.5;
                    const size = 3 + pressure * 5;
                    
                    mainCtx.fillStyle = pressure > 0.5 ? 
                        `rgba(156, 39, 176, ${pressure})` : 
                        `rgba(103, 58, 183, ${pressure})`;
                    
                    mainCtx.beginPath();
                    mainCtx.arc(x, y, size, 0, Math.PI * 2);
                    mainCtx.fill();
                }
            }
        }

        function renderStressView(width, height) {
            // Stress visualization background
            const gradient = mainCtx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, 'rgba(40, 40, 60, 0.9)');
            gradient.addColorStop(1, 'rgba(20, 20, 40, 0.9)');
            
            mainCtx.fillStyle = gradient;
            mainCtx.fillRect(0, 0, width, height);
            
            // Stress lines
            mainCtx.strokeStyle = 'rgba(255, 87, 34, 0.3)';
            mainCtx.lineWidth = 1;
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 12) {
                const length = 200 + Math.sin(simulation.frameCount * 0.02 + angle) * 50;
                const endX = centerX + Math.cos(angle) * length;
                const endY = centerY + Math.sin(angle) * length;
                
                mainCtx.beginPath();
                mainCtx.moveTo(centerX, centerY);
                mainCtx.lineTo(endX, endY);
                mainCtx.stroke();
            }
            
            // Stress concentration points
            const stressPoints = [
                {x: width * 0.3, y: height * 0.5, stress: 0.8},
                {x: width * 0.7, y: height * 0.5, stress: 0.9},
                {x: width * 0.5, y: height * 0.3, stress: 0.6},
                {x: width * 0.5, y: height * 0.7, stress: 0.7}
            ];
            
            stressPoints.forEach(point => {
                const stressGradient = mainCtx.createRadialGradient(
                    point.x, point.y, 0,
                    point.x, point.y, 80
                );
                
                if (point.stress > 0.8) {
                    stressGradient.addColorStop(0, 'rgba(255, 23, 68, 0.8)');
                    stressGradient.addColorStop(1, 'rgba(255, 23, 68, 0)');
                } else if (point.stress > 0.6) {
                    stressGradient.addColorStop(0, 'rgba(255, 87, 34, 0.6)');
                    stressGradient.addColorStop(1, 'rgba(255, 87, 34, 0)');
                } else {
                    stressGradient.addColorStop(0, 'rgba(255, 152, 0, 0.4)');
                    stressGradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
                }
                
                mainCtx.fillStyle = stressGradient;
                mainCtx.beginPath();
                mainCtx.arc(point.x, point.y, 80, 0, Math.PI * 2);
                mainCtx.fill();
            });
        }

        function renderEngineStructure(width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = Math.min(width, height) / 1000;
            const time = simulation.frameCount * 0.01;
            
            // Calculate piston positions
            const crankRadius = 30 * scale;
            const pistonStroke = 60 * scale;
            const displacerPhase = Math.PI / 2;
            
            const powerAngle = simulation.engineAngle;
            const displacerAngle = simulation.engineAngle + displacerPhase;
            
            const powerPistonY = centerY + Math.sin(powerAngle) * pistonStroke / 2;
            const displacerY = centerY + Math.sin(displacerAngle) * pistonStroke / 2;
            
            // Hot cylinder
            const hotCylinderX = centerX - 250 * scale;
            const hotCylinderWidth = 45 * scale;
            const hotCylinderHeight = 120 * scale;
            
            // Cold cylinder
            const coldCylinderX = centerX + 250 * scale;
            const coldCylinderWidth = 45 * scale;
            const coldCylinderHeight = 120 * scale;
            
            // Draw cylinders with 3D effect
            draw3DCylinder(hotCylinderX, centerY, hotCylinderWidth, hotCylinderHeight, 'hot');
            draw3DCylinder(coldCylinderX, centerY, coldCylinderWidth, coldCylinderHeight, 'cold');
            
            // Draw pistons with 3D effect
            draw3DPiston(hotCylinderX, displacerY, hotCylinderWidth * 0.9, 40 * scale, 'displacer');
            draw3DPiston(coldCylinderX, powerPistonY, coldCylinderWidth * 0.9, 25 * scale, 'power');
            
            // Draw regenerator
            draw3DRegenerator(centerX, centerY - 80 * scale, 60 * scale, 20 * scale);
            
            // Draw crankshaft assembly
            draw3DCrankshaft(centerX, centerY + 180 * scale, scale, powerAngle, displacerAngle);
            
            // Draw connecting passages
            drawConnectingPassages(hotCylinderX, coldCylinderX, centerY, scale);
            
            // Draw flywheel with rotation
            drawFlywheel(centerX, centerY + 180 * scale, scale * 60, time);
        }

        function draw3DCylinder(x, y, width, height, type) {
            // 3D cylinder body
            const depth = width * 0.3;
            
            // Front face
            mainCtx.fillStyle = type === 'hot' ? 
                'rgba(255, 61, 0, 0.8)' : 'rgba(0, 188, 212, 0.8)';
            mainCtx.fillRect(x - width/2, y - height/2, width, height);
            
            // Side face for 3D effect
            mainCtx.fillStyle = type === 'hot' ? 
                'rgba(255, 87, 34, 0.6)' : 'rgba(0, 151, 167, 0.6)';
            mainCtx.fillRect(x + width/2, y - height/2, depth, height);
            
            // Top face for 3D effect
            mainCtx.fillStyle = type === 'hot' ? 
                'rgba(255, 109, 0, 0.5)' : 'rgba(0, 172, 193, 0.5)';
            mainCtx.beginPath();
            mainCtx.moveTo(x - width/2, y - height/2);
            mainCtx.lineTo(x + width/2, y - height/2);
            mainCtx.lineTo(x + width/2 + depth, y - height/2);
            mainCtx.lineTo(x - width/2 + depth, y - height/2);
            mainCtx.closePath();
            mainCtx.fill();
            
            // Inner bore with highlight
            const innerWidth = width * 0.9;
            mainCtx.fillStyle = 'rgba(60, 60, 80, 0.9)';
            mainCtx.fillRect(x - innerWidth/2, y - height/2, innerWidth, height);
            
            // Inner bore highlight
            const gradient = mainCtx.createLinearGradient(
                x - innerWidth/2, y - height/2,
                x - innerWidth/2, y + height/2
            );
            gradient.addColorStop(0, 'rgba(100, 100, 120, 0.8)');
            gradient.addColorStop(0.5, 'rgba(80, 80, 100, 0.9)');
            gradient.addColorStop(1, 'rgba(60, 60, 80, 0.8)');
            
            mainCtx.fillStyle = gradient;
            mainCtx.fillRect(x - innerWidth/2, y - height/2, innerWidth, height);
            
            // Bore surface finish lines
            mainCtx.strokeStyle = 'rgba(200, 200, 220, 0.3)';
            mainCtx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const yPos = y - height/2 + i * height/4;
                mainCtx.beginPath();
                mainCtx.moveTo(x - innerWidth/2, yPos);
                mainCtx.lineTo(x + innerWidth/2, yPos);
                mainCtx.stroke();
            }
        }

        function draw3DPiston(x, y, width, height, type) {
            // 3D piston body
            const depth = width * 0.2;
            
            // Front face
            mainCtx.fillStyle = type === 'displacer' ? 
                'rgba(255, 171, 0, 0.9)' : 'rgba(76, 175, 80, 0.9)';
            mainCtx.fillRect(x - width/2, y - height/2, width, height);
            
            // Side face
            mainCtx.fillStyle = type === 'displacer' ? 
                'rgba(255, 152, 0, 0.7)' : 'rgba(56, 142, 60, 0.7)';
            mainCtx.fillRect(x + width/2, y - height/2, depth, height);
            
            // Top face
            mainCtx.fillStyle = type === 'displacer' ? 
                'rgba(255, 193, 7, 0.6)' : 'rgba(67, 160, 71, 0.6)';
            mainCtx.beginPath();
            mainCtx.moveTo(x - width/2, y - height/2);
            mainCtx.lineTo(x + width/2, y - height/2);
            mainCtx.lineTo(x + width/2 + depth, y - height/2);
            mainCtx.lineTo(x - width/2 + depth, y - height/2);
            mainCtx.closePath();
            mainCtx.fill();
            
            // Piston rings
            if (type === 'power') {
                const ringCount = 3;
                for (let i = 0; i < ringCount; i++) {
                    const ringY = y - height/2 + (i+1) * height/(ringCount+1);
                    mainCtx.fillStyle = 'rgba(30, 30, 30, 0.9)';
                    mainCtx.fillRect(x - width/2 - 2, ringY - 2, width + 4, 4);
                    
                    // Ring highlight
                    mainCtx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                    mainCtx.fillRect(x - width/2 - 1, ringY - 1, width + 2, 1);
                }
            }
            
            // Piston rod
            const rodWidth = width * 0.2;
            mainCtx.fillStyle = 'rgba(120, 120, 120, 0.9)';
            mainCtx.fillRect(x - rodWidth/2, y + height/2, rodWidth, 100);
            
            // Rod highlight
            const rodGradient = mainCtx.createLinearGradient(
                x - rodWidth/2, y + height/2,
                x + rodWidth/2, y + height/2
            );
            rodGradient.addColorStop(0, 'rgba(150, 150, 150, 0.8)');
            rodGradient.addColorStop(0.5, 'rgba(180, 180, 180, 0.9)');
            rodGradient.addColorStop(1, 'rgba(150, 150, 150, 0.8)');
            
            mainCtx.fillStyle = rodGradient;
            mainCtx.fillRect(x - rodWidth/2, y + height/2, rodWidth, 10);
        }

        function draw3DRegenerator(x, y, width, height) {
            // 3D regenerator housing
            const depth = width * 0.2;
            
            // Front face
            mainCtx.fillStyle = 'rgba(90, 90, 110, 0.9)';
            mainCtx.fillRect(x - width/2, y - height/2, width, height);
            
            // Side face
            mainCtx.fillStyle = 'rgba(70, 70, 90, 0.7)';
            mainCtx.fillRect(x + width/2, y - height/2, depth, height);
            
            // Top face
            mainCtx.fillStyle = 'rgba(110, 110, 130, 0.6)';
            mainCtx.beginPath();
            mainCtx.moveTo(x - width/2, y - height/2);
            mainCtx.lineTo(x + width/2, y - height/2);
            mainCtx.lineTo(x + width/2 + depth, y - height/2);
            mainCtx.lineTo(x - width/2 + depth, y - height/2);
            mainCtx.closePath();
            mainCtx.fill();
            
            // Wire mesh pattern
            mainCtx.strokeStyle = 'rgba(156, 39, 176, 0.6)';
            mainCtx.lineWidth = 0.5;
            const meshSize = 8;
            
            for (let i = 0; i < width / meshSize; i++) {
                for (let j = 0; j < height / meshSize; j++) {
                    const meshX = x - width/2 + i * meshSize;
                    const meshY = y - height/2 + j * meshSize;
                    
                    mainCtx.strokeRect(meshX, meshY, meshSize, meshSize);
                }
            }
        }

        function draw3DCrankshaft(x, y, scale, powerAngle, displacerAngle) {
            const crankRadius = 30 * scale;
            const journalRadius = 6 * scale;
            
            // Main shaft
            mainCtx.fillStyle = 'rgba(100, 100, 120, 0.9)';
            mainCtx.beginPath();
            mainCtx.arc(x, y, 15 * scale, 0, Math.PI * 2);
            mainCtx.fill();
            
            // Crank arms
            mainCtx.strokeStyle = 'rgba(120, 120, 140, 0.8)';
            mainCtx.lineWidth = 8 * scale;
            
            // Power crank
            const powerCrankX = x + Math.cos(powerAngle) * crankRadius;
            const powerCrankY = y + Math.sin(powerAngle) * crankRadius;
            
            mainCtx.beginPath();
            mainCtx.moveTo(x, y);
            mainCtx.lineTo(powerCrankX, powerCrankY);
            mainCtx.stroke();
            
            // Displacer crank
            const displacerCrankX = x + Math.cos(displacerAngle) * crankRadius;
            const displacerCrankY = y + Math.sin(displacerAngle) * crankRadius;
            
            mainCtx.beginPath();
            mainCtx.moveTo(x, y);
            mainCtx.lineTo(displacerCrankX, displacerCrankY);
            mainCtx.stroke();
            
            // Crank journals
            mainCtx.fillStyle = 'rgba(76, 175, 80, 0.9)';
            mainCtx.beginPath();
            mainCtx.arc(powerCrankX, powerCrankY, journalRadius, 0, Math.PI * 2);
            mainCtx.fill();
            
            mainCtx.fillStyle = 'rgba(255, 171, 0, 0.9)';
            mainCtx.beginPath();
            mainCtx.arc(displacerCrankX, displacerCrankY, journalRadius, 0, Math.PI * 2);
            mainCtx.fill();
            
            // Connecting rods
            mainCtx.strokeStyle = 'rgba(76, 175, 80, 0.7)';
            mainCtx.lineWidth = 4 * scale;
            mainCtx.beginPath();
            mainCtx.moveTo(powerCrankX, powerCrankY);
            mainCtx.lineTo(mainCanvas.width * 0.7, mainCanvas.height * 0.5 + Math.sin(powerAngle) * 60 * scale);
            mainCtx.stroke();
            
            mainCtx.strokeStyle = 'rgba(255, 171, 0, 0.7)';
            mainCtx.beginPath();
            mainCtx.moveTo(displacerCrankX, displacerCrankY);
            mainCtx.lineTo(mainCanvas.width * 0.3, mainCanvas.height * 0.5 + Math.sin(displacerAngle) * 60 * scale);
            mainCtx.stroke();
        }

        function drawConnectingPassages(hotX, coldX, centerY, scale) {
            const passageHeight = 15 * scale;
            const passageY = centerY - 80 * scale;
            
            // Main passage
            mainCtx.strokeStyle = 'rgba(90, 90, 110, 0.8)';
            mainCtx.lineWidth = 12 * scale;
            mainCtx.beginPath();
            mainCtx.moveTo(hotX, centerY);
            mainCtx.lineTo(coldX, centerY);
            mainCtx.stroke();
            
            // Regenerator connection
            mainCtx.beginPath();
            mainCtx.moveTo((hotX + coldX) / 2, centerY);
            mainCtx.lineTo((hotX + coldX) / 2, passageY);
            mainCtx.stroke();
            
            // Flow arrows
            const time = simulation.frameCount * 0.05;
            const arrowCount = 8;
            
            mainCtx.fillStyle = 'rgba(0, 188, 212, 0.8)';
            for (let i = 0; i < arrowCount; i++) {
                const t = (i / arrowCount) * Math.PI * 2 + time;
                const arrowX = (hotX + coldX) / 2 + Math.sin(t) * ((coldX - hotX) / 3);
                const arrowY = centerY + Math.cos(t) * 20;
                
                mainCtx.save();
                mainCtx.translate(arrowX, arrowY);
                mainCtx.rotate(Math.atan2(Math.cos(t), Math.sin(t)));
                
                mainCtx.beginPath();
                mainCtx.moveTo(0, 0);
                mainCtx.lineTo(-10 * scale, -5 * scale);
                mainCtx.lineTo(-10 * scale, 5 * scale);
                mainCtx.closePath();
                mainCtx.fill();
                
                mainCtx.restore();
            }
        }

        function drawFlywheel(x, y, radius, time) {
            // Flywheel body
            const gradient = mainCtx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(100, 100, 120, 0.9)');
            gradient.addColorStop(1, 'rgba(60, 60, 80, 0.9)');
            
            mainCtx.fillStyle = gradient;
            mainCtx.beginPath();
            mainCtx.arc(x, y, radius, 0, Math.PI * 2);
            mainCtx.fill();
            
            // Spokes
            mainCtx.strokeStyle = 'rgba(80, 80, 100, 0.8)';
            mainCtx.lineWidth = 3;
            const spokeCount = 6;
            
            for (let i = 0; i < spokeCount; i++) {
                const angle = (i / spokeCount) * Math.PI * 2 + time;
                const endX = x + Math.cos(angle) * radius;
                const endY = y + Math.sin(angle) * radius;
                
                mainCtx.beginPath();
                mainCtx.moveTo(x, y);
                mainCtx.lineTo(endX, endY);
                mainCtx.stroke();
            }
            
            // Rim
            mainCtx.strokeStyle = 'rgba(120, 120, 140, 0.8)';
            mainCtx.lineWidth = 5;
            mainCtx.beginPath();
            mainCtx.arc(x, y, radius, 0, Math.PI * 2);
            mainCtx.stroke();
            
            // Balance weights
            const weightCount = 2;
            for (let i = 0; i < weightCount; i++) {
                const angle = Math.PI + (i / weightCount) * Math.PI;
                const weightX = x + Math.cos(angle + time) * (radius - 10);
                const weightY = y + Math.sin(angle + time) * (radius - 10);
                
                mainCtx.fillStyle = 'rgba(40, 40, 60, 0.9)';
                mainCtx.beginPath();
                mainCtx.arc(weightX, weightY, 15, 0, Math.PI * 2);
                mainCtx.fill();
            }
        }

        function renderGasParticles(width, height) {
            const time = simulation.frameCount * 0.01;
            
            engine.particles.forEach(particle => {
                // Update particle position based on engine state
                const angle = particle.phase + time;
                const radius = 200 + Math.sin(angle * 2) * 50;
                
                particle.x = width / 2 + Math.cos(angle) * radius;
                particle.y = height / 2 + Math.sin(angle) * radius;
                
                // Add vortex effect
                engine.vortices.forEach(vortex => {
                    const dx = particle.x - vortex.x;
                    const dy = particle.y - vortex.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < vortex.radius) {
                        const force = vortex.strength * (1 - distance / vortex.radius);
                        const angle = Math.atan2(dy, dx);
                        
                        particle.vx += Math.cos(angle + Math.PI/2) * force * vortex.rotation;
                        particle.vy += Math.sin(angle + Math.PI/2) * force * vortex.rotation;
                    }
                });
                
                // Limit velocity
                const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                if (speed > 5) {
                    particle.vx = particle.vx / speed * 5;
                    particle.vy = particle.vy / speed * 5;
                }
                
                // Update position
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Keep particles within bounds
                if (particle.x < 0) particle.x = width;
                if (particle.x > width) particle.x = 0;
                if (particle.y < 0) particle.y = height;
                if (particle.y > height) particle.y = 0;
                
                // Add to trail
                particle.trail.push({x: particle.x, y: particle.y});
                if (particle.trail.length > 10) particle.trail.shift();
                
                // Draw particle
                const alpha = 0.3 + Math.sin(angle) * 0.3;
                mainCtx.fillStyle = particle.type === 'hot' ? 
                    `rgba(255, 100, 0, ${alpha})` : 
                    `rgba(0, 150, 255, ${alpha})`;
                
                mainCtx.beginPath();
                mainCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                mainCtx.fill();
                
                // Draw trail
                if (particle.trail.length > 1) {
                    mainCtx.strokeStyle = particle.type === 'hot' ? 
                        `rgba(255, 100, 0, 0.2)` : 
                        `rgba(0, 150, 255, 0.2)`;
                    
                    mainCtx.lineWidth = 1;
                    mainCtx.beginPath();
                    mainCtx.moveTo(particle.trail[0].x, particle.trail[0].y);
                    
                    for (let i = 1; i < particle.trail.length; i++) {
                        mainCtx.lineTo(particle.trail[i].x, particle.trail[i].y);
                    }
                    
                    mainCtx.stroke();
                }
            });
        }

        function renderHeatFlow(width, height) {
            const time = simulation.frameCount * 0.02;
            
            engine.heatFlow.forEach(flow => {
                // Update flow position
                flow.x += Math.cos(flow.direction) * 2;
                flow.y += Math.sin(flow.direction) * 2;
                
                // Wrap around
                if (flow.x < 0) flow.x = width;
                if (flow.x > width) flow.x = 0;
                if (flow.y < 0) flow.y = height;
                if (flow.y > height) flow.y = 0;
                
                // Draw heat flow line
                const endX = flow.x + Math.cos(flow.direction) * flow.length;
                const endY = flow.y + Math.sin(flow.direction) * flow.length;
                
                const gradient = mainCtx.createLinearGradient(flow.x, flow.y, endX, endY);
                
                if (flow.temperature > 500) {
                    gradient.addColorStop(0, 'rgba(255, 61, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 61, 0, 0)');
                } else if (flow.temperature > 400) {
                    gradient.addColorStop(0, 'rgba(255, 152, 0, 0.7)');
                    gradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
                } else if (flow.temperature > 300) {
                    gradient.addColorStop(0, 'rgba(255, 235, 59, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 235, 59, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(0, 188, 212, 0.5)');
                    gradient.addColorStop(1, 'rgba(0, 188, 212, 0)');
                }
                
                mainCtx.strokeStyle = gradient;
                mainCtx.lineWidth = 3;
                mainCtx.beginPath();
                mainCtx.moveTo(flow.x, flow.y);
                mainCtx.lineTo(endX, endY);
                mainCtx.stroke();
                
                // Draw heat source point
                mainCtx.fillStyle = flow.temperature > 400 ? 
                    'rgba(255, 61, 0, 0.9)' : 'rgba(0, 188, 212, 0.9)';
                
                mainCtx.beginPath();
                mainCtx.arc(flow.x, flow.y, 4, 0, Math.PI * 2);
                mainCtx.fill();
            });
        }

        function renderPressureWaves(width, height) {
            const time = simulation.frameCount * 0.03;
            
            // Generate new pressure waves
            if (Math.random() < 0.1) {
                engine.pressureWaves.push({
                    x: width * 0.3 + Math.random() * width * 0.4,
                    y: height * 0.3 + Math.random() * height * 0.4,
                    radius: 10,
                    speed: 2 + Math.random() * 3,
                    intensity: 0.5 + Math.random() * 0.5,
                    life: 100
                });
            }
            
            // Update and draw pressure waves
            for (let i = engine.pressureWaves.length - 1; i >= 0; i--) {
                const wave = engine.pressureWaves[i];
                
                wave.radius += wave.speed;
                wave.life -= 1;
                wave.intensity *= 0.98;
                
                if (wave.life <= 0 || wave.intensity < 0.1) {
                    engine.pressureWaves.splice(i, 1);
                    continue;
                }
                
                // Draw pressure wave
                mainCtx.strokeStyle = `rgba(156, 39, 176, ${wave.intensity})`;
                mainCtx.lineWidth = 2;
                mainCtx.beginPath();
                mainCtx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                mainCtx.stroke();
                
                // Draw secondary wave
                if (wave.radius > 30) {
                    mainCtx.strokeStyle = `rgba(103, 58, 183, ${wave.intensity * 0.5})`;
                    mainCtx.beginPath();
                    mainCtx.arc(wave.x, wave.y, wave.radius - 15, 0, Math.PI * 2);
                    mainCtx.stroke();
                }
            }
        }

        function renderVortices(width, height) {
            const time = simulation.frameCount * 0.02;
            
            engine.vortices.forEach(vortex => {
                vortex.life -= 0.5;
                
                if (vortex.life <= 0) {
                    // Reset vortex
                    vortex.x = Math.random() * width;
                    vortex.y = Math.random() * height;
                    vortex.life = 100 + Math.random() * 100;
                    vortex.rotation = Math.random() > 0.5 ? 1 : -1;
                }
                
                // Draw vortex
                const gradient = mainCtx.createRadialGradient(
                    vortex.x, vortex.y, 0,
                    vortex.x, vortex.y, vortex.radius
                );
                
                gradient.addColorStop(0, `rgba(0, 188, 212, ${vortex.life / 200})`);
                gradient.addColorStop(1, `rgba(0, 188, 212, 0)`);
                
                mainCtx.fillStyle = gradient;
                mainCtx.beginPath();
                mainCtx.arc(vortex.x, vortex.y, vortex.radius, 0, Math.PI * 2);
                mainCtx.fill();
                
                // Draw vortex center
                mainCtx.fillStyle = `rgba(0, 188, 212, 0.8)`;
                mainCtx.beginPath();
                mainCtx.arc(vortex.x, vortex.y, 3, 0, Math.PI * 2);
                mainCtx.fill();
                
                // Draw rotation arrows
                const arrowCount = 8;
                for (let i = 0; i < arrowCount; i++) {
                    const angle = (i / arrowCount) * Math.PI * 2 + time * vortex.rotation;
                    const arrowX = vortex.x + Math.cos(angle) * vortex.radius * 0.7;
                    const arrowY = vortex.y + Math.sin(angle) * vortex.radius * 0.7;
                    
                    mainCtx.save();
                    mainCtx.translate(arrowX, arrowY);
                    mainCtx.rotate(angle + Math.PI/2);
                    
                    mainCtx.fillStyle = `rgba(0, 188, 212, 0.8)`;
                    mainCtx.beginPath();
                    mainCtx.moveTo(0, 0);
                    mainCtx.lineTo(-5, -10);
                    mainCtx.lineTo(5, -10);
                    mainCtx.closePath();
                    mainCtx.fill();
                    
                    mainCtx.restore();
                }
            });
        }

        function renderStressPoints(width, height) {
            const time = simulation.frameCount * 0.01;
            
            engine.stressPoints.forEach(point => {
                // Animate stress point
                point.x += Math.cos(time + point.direction) * 0.5;
                point.y += Math.sin(time + point.direction) * 0.5;
                
                // Draw stress point
                let color;
                switch(point.type) {
                    case 'compression':
                        color = `rgba(255, 87, 34, ${point.stress})`;
                        break;
                    case 'tension':
                        color = `rgba(255, 152, 0, ${point.stress})`;
                        break;
                    case 'shear':
                        color = `rgba(255, 235, 59, ${point.stress})`;
                        break;
                    case 'bending':
                        color = `rgba(156, 39, 176, ${point.stress})`;
                        break;
                }
                
                mainCtx.fillStyle = color;
                mainCtx.beginPath();
                
                // Different shapes for different stress types
                switch(point.type) {
                    case 'compression':
                        // Square for compression
                        mainCtx.fillRect(point.x - 3, point.y - 3, 6, 6);
                        break;
                    case 'tension':
                        // Circle for tension
                        mainCtx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                        mainCtx.fill();
                        break;
                    case 'shear':
                        // Triangle for shear
                        mainCtx.moveTo(point.x, point.y - 3);
                        mainCtx.lineTo(point.x - 3, point.y + 3);
                        mainCtx.lineTo(point.x + 3, point.y + 3);
                        mainCtx.closePath();
                        mainCtx.fill();
                        break;
                    case 'bending':
                        // Diamond for bending
                        mainCtx.moveTo(point.x, point.y - 3);
                        mainCtx.lineTo(point.x - 3, point.y);
                        mainCtx.lineTo(point.x, point.y + 3);
                        mainCtx.lineTo(point.x + 3, point.y);
                        mainCtx.closePath();
                        mainCtx.fill();
                        break;
                }
                
                // Draw stress lines
                const lineLength = 20 * point.stress;
                const endX = point.x + Math.cos(point.direction) * lineLength;
                const endY = point.y + Math.sin(point.direction) * lineLength;
                
                mainCtx.strokeStyle = color;
                mainCtx.lineWidth = point.stress * 2;
                mainCtx.beginPath();
                mainCtx.moveTo(point.x, point.y);
                mainCtx.lineTo(endX, endY);
                mainCtx.stroke();
            });
        }

        function updatePerformanceMetrics() {
            const time = simulation.frameCount * 0.01;
            
            // Update cycle
            engine.cycle.stage = Math.floor((time * 0.5) % 4);
            engine.cycle.pressure = 1.2 + Math.sin(time) * 0.4;
            engine.cycle.volume = 95.4 + Math.sin(time + Math.PI/2) * 45;
            engine.cycle.temperature = 340 + Math.sin(time * 2) * 260;
            
            // Update power with realistic variations
            const powerVariation = 0.95 + Math.sin(time * 4) * 0.05;
            const pressureFactor = engine.pressure / 1.2;
            const rpmFactor = engine.rpm / 300;
            const tempFactor = (engine.hotTemp - engine.coldTemp) / 520;
            
            engine.power = 20 * pressureFactor * rpmFactor * tempFactor * powerVariation;
            
            // Update efficiency
            const carnotEff = 1 - (engine.coldTemp + 273) / (engine.hotTemp + 273);
            engine.efficiency = carnotEff * 0.48 * pressureFactor * 100;
            
            // Update displays
            document.getElementById('powerValue').textContent = `${engine.power.toFixed(1)}W`;
            document.getElementById('efficiencyValue').textContent = `${engine.efficiency.toFixed(1)}%`;
            document.getElementById('efficiencyValue2').textContent = `${engine.efficiency.toFixed(1)}%`;
            
            // Update efficiency bar
            document.getElementById('efficiencyBar').style.width = `${engine.efficiency}%`;
            
            // Update advanced metrics
            document.getElementById('deltaTEff').textContent = `${(carnotEff * 100).toFixed(1)}%`;
            document.getElementById('regenEff').textContent = `${(90 + Math.sin(time) * 2.3).toFixed(1)}%`;
            document.getElementById('heatFlux').textContent = `${(1.8 * pressureFactor).toFixed(1)} kW`;
            document.getElementById('gasVelocity').textContent = `${(12.5 * rpmFactor).toFixed(1)} m/s`;
        }

        // Thermodynamic diagram
        function renderThermoDiagram() {
            const width = thermoCanvas.width;
            const height = thermoCanvas.height;
            
            thermoCTX.clearRect(0, 0, width, height);
            
            // Background
            thermoCTX.fillStyle = 'rgba(15, 15, 30, 0.9)';
            thermoCTX.fillRect(0, 0, width, height);
            
            // Draw grid
            thermoCTX.strokeStyle = 'rgba(58, 58, 90, 0.5)';
            thermoCTX.lineWidth = 1;
            
            // Vertical grid
            for (let x = 0; x <= width; x += width / 10) {
                thermoCTX.beginPath();
                thermoCTX.moveTo(x, 0);
                thermoCTX.lineTo(x, height);
                thermoCTX.stroke();
            }
            
            // Horizontal grid
            for (let y = 0; y <= height; y += height / 10) {
                thermoCTX.beginPath();
                thermoCTX.moveTo(0, y);
                thermoCTX.lineTo(width, y);
                thermoCTX.stroke();
            }
            
            // Draw Stirling cycle
            const time = simulation.frameCount * 0.02;
            const points = [];
            
            for (let i = 0; i < 100; i++) {
                const t = (i / 100) * Math.PI * 2 + time;
                const x = width * 0.5 + Math.cos(t) * width * 0.4;
                const y = height * 0.5 + Math.sin(t * 2) * height * 0.4;
                
                points.push({x, y});
            }
            
            // Fill cycle
            thermoCTX.fillStyle = 'rgba(0, 188, 212, 0.2)';
            thermoCTX.beginPath();
            thermoCTX.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                thermoCTX.lineTo(points[i].x, points[i].y);
            }
            
            thermoCTX.closePath();
            thermoCTX.fill();
            
            // Draw cycle outline
            thermoCTX.strokeStyle = 'rgba(0, 188, 212, 0.8)';
            thermoCTX.lineWidth = 2;
            thermoCTX.beginPath();
            thermoCTX.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                thermoCTX.lineTo(points[i].x, points[i].y);
            }
            
            thermoCTX.closePath();
            thermoCTX.stroke();
            
            // Draw current operating point
            const currentIndex = Math.floor((time * 10) % points.length);
            const currentPoint = points[currentIndex];
            
            thermoCTX.fillStyle = '#ff3d00';
            thermoCTX.beginPath();
            thermoCTX.arc(currentPoint.x, currentPoint.y, 6, 0, Math.PI * 2);
            thermoCTX.fill();
            
            // Draw labels
            thermoCTX.fillStyle = '#a5b4fc';
            thermoCTX.font = '12px Arial';
            thermoCTX.textAlign = 'center';
            thermoCTX.fillText('Pressure (MPa)', width / 2, height - 10);
            
            thermoCTX.save();
            thermoCTX.translate(10, height / 2);
            thermoCTX.rotate(-Math.PI / 2);
            thermoCTX.fillText('Volume (cm¬≥)', 0, 0);
            thermoCTX.restore();
        }

        // Molecular dynamics visualization
        function renderMolecularDynamics() {
            const width = molecularCanvas.width;
            const height = molecularCanvas.height;
            const time = simulation.frameCount * 0.01;
            
            molecularCtx.clearRect(0, 0, width, height);
            
            // Background
            molecularCtx.fillStyle = 'rgba(10, 10, 20, 0.9)';
            molecularCtx.fillRect(0, 0, width, height);
            
            // Draw hot surface
            const hotSurfaceY = height * 0.3;
            molecularCtx.fillStyle = 'rgba(255, 61, 0, 0.3)';
            molecularCtx.fillRect(0, hotSurfaceY, width, 5);
            
            // Draw cold surface
            const coldSurfaceY = height * 0.7;
            molecularCtx.fillStyle = 'rgba(0, 188, 212, 0.3)';
            molecularCtx.fillRect(0, coldSurfaceY, width, 5);
            
            // Draw molecules
            const moleculeCount = 50;
            
            for (let i = 0; i < moleculeCount; i++) {
                const phase = (i / moleculeCount) * Math.PI * 2 + time;
                const x = width * 0.5 + Math.cos(phase * 3) * width * 0.4;
                const y = height * 0.5 + Math.sin(phase * 2) * height * 0.4;
                
                // Determine molecule type based on position
                const isHot = y < height * 0.5;
                const velocity = isHot ? 2 + Math.sin(phase) : 1 + Math.sin(phase) * 0.5;
                
                // Draw molecule
                molecularCtx.fillStyle = isHot ? 
                    'rgba(255, 100, 0, 0.8)' : 'rgba(100, 200, 255, 0.8)';
                
                molecularCtx.beginPath();
                molecularCtx.arc(x, y, 3, 0, Math.PI * 2);
                molecularCtx.fill();
                
                // Draw velocity vector
                const vectorLength = 10 * velocity;
                molecularCtx.strokeStyle = isHot ? 
                    'rgba(255, 100, 0, 0.5)' : 'rgba(100, 200, 255, 0.5)';
                
                molecularCtx.lineWidth = 1;
                molecularCtx.beginPath();
                molecularCtx.moveTo(x, y);
                molecularCtx.lineTo(x + vectorLength * Math.cos(phase), 
                                  y + vectorLength * Math.sin(phase));
                molecularCtx.stroke();
                
                // Draw electron cloud for excited molecules
                if (isHot && Math.random() > 0.7) {
                    molecularCtx.strokeStyle = 'rgba(255, 255, 100, 0.3)';
                    molecularCtx.beginPath();
                    molecularCtx.arc(x, y, 8 + Math.sin(phase * 5) * 3, 0, Math.PI * 2);
                    molecularCtx.stroke();
                }
            }
            
            // Draw temperature gradient
            const gradient = molecularCtx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(255, 61, 0, 0.1)');
            gradient.addColorStop(0.5, 'rgba(255, 61, 0, 0)');
            gradient.addColorStop(0.5, 'rgba(0, 188, 212, 0)');
            gradient.addColorStop(1, 'rgba(0, 188, 212, 0.1)');
            
            molecularCtx.fillStyle = gradient;
            molecularCtx.fillRect(0, 0, width, height);
        }

        // Heat transfer visualization
        function renderHeatTransfer() {
            const width = heatCanvas.width;
            const height = heatCanvas.height;
            const time = simulation.frameCount * 0.01;
            
            heatCtx.clearRect(0, 0, width, height);
            
            // Create heat map
            const cellSize = 10;
            
            for (let x = 0; x < width; x += cellSize) {
                for (let y = 0; y < height; y += cellSize) {
                    // Calculate temperature at this point
                    const distanceFromHot = Math.sqrt(
                        Math.pow(x - width * 0.3, 2) + 
                        Math.pow(y - height * 0.5, 2)
                    );
                    
                    const distanceFromCold = Math.sqrt(
                        Math.pow(x - width * 0.7, 2) + 
                        Math.pow(y - height * 0.5, 2)
                    );
                    
                    const hotInfluence = Math.max(0, 1 - distanceFromHot / 150);
                    const coldInfluence = Math.max(0, 1 - distanceFromCold / 150);
                    
                    const temperature = hotInfluence * 600 + coldInfluence * 80;
                    const normalizedTemp = Math.min(1, temperature / 600);
                    
                    // Color based on temperature
                    let color;
                    if (normalizedTemp > 0.7) {
                        color = `rgba(255, ${Math.floor(100 * (1 - normalizedTemp))}, 0, 0.8)`;
                    } else if (normalizedTemp > 0.4) {
                        color = `rgba(255, ${Math.floor(100 + 155 * normalizedTemp)}, 0, 0.6)`;
                    } else {
                        color = `rgba(${Math.floor(255 * normalizedTemp)}, ${Math.floor(100 + 155 * normalizedTemp)}, 255, 0.4)`;
                    }
                    
                    heatCtx.fillStyle = color;
                    heatCtx.fillRect(x, y, cellSize, cellSize);
                    
                    // Draw heat flow lines
                    if (Math.random() > 0.7) {
                        const angle = Math.atan2(
                            height * 0.5 - y,
                            width * 0.7 - x
                        );
                        
                        const lineLength = 20 * normalizedTemp;
                        heatCtx.strokeStyle = `rgba(255, 255, 255, ${normalizedTemp * 0.5})`;
                        heatCtx.lineWidth = 1;
                        
                        heatCtx.beginPath();
                        heatCtx.moveTo(x + cellSize/2, y + cellSize/2);
                        heatCtx.lineTo(
                            x + cellSize/2 + Math.cos(angle) * lineLength,
                            y + cellSize/2 + Math.sin(angle) * lineLength
                        );
                        heatCtx.stroke();
                    }
                }
            }
            
            // Draw isothermal lines
            heatCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            heatCtx.lineWidth = 1;
            
            for (let i = 1; i < 5; i++) {
                const radius = 50 + i * 30;
                
                // Hot isothermal lines
                heatCtx.beginPath();
                heatCtx.arc(width * 0.3, height * 0.5, radius, 0, Math.PI * 2);
                heatCtx.stroke();
                
                // Cold isothermal lines
                heatCtx.beginPath();
                heatCtx.arc(width * 0.7, height * 0.5, radius, 0, Math.PI * 2);
                heatCtx.stroke();
            }
            
            // Draw heat flux arrows
            const arrowCount = 20;
            
            for (let i = 0; i < arrowCount; i++) {
                const angle = (i / arrowCount) * Math.PI * 2 + time;
                const distance = 80 + Math.sin(angle * 3) * 30;
                
                const startX = width * 0.3 + Math.cos(angle) * 30;
                const startY = height * 0.5 + Math.sin(angle) * 30;
                
                const endX = width * 0.3 + Math.cos(angle) * distance;
                const endY = height * 0.5 + Math.sin(angle) * distance;
                
                // Draw arrow
                heatCtx.strokeStyle = 'rgba(255, 100, 0, 0.8)';
                heatCtx.lineWidth = 2;
                heatCtx.beginPath();
                heatCtx.moveTo(startX, startY);
                heatCtx.lineTo(endX, endY);
                heatCtx.stroke();
                
                // Draw arrow head
                heatCtx.fillStyle = 'rgba(255, 100, 0, 0.8)';
                heatCtx.save();
                heatCtx.translate(endX, endY);
                heatCtx.rotate(angle);
                
                heatCtx.beginPath();
                heatCtx.moveTo(0, 0);
                heatCtx.lineTo(-8, -4);
                heatCtx.lineTo(-8, 4);
                heatCtx.closePath();
                heatCtx.fill();
                
                heatCtx.restore();
            }
        }

        // Performance graph
        function renderPerformanceGraph() {
            const width = performanceCanvas.width;
            const height = performanceCanvas.height;
            const time = simulation.frameCount * 0.01;
            
            performanceCtx.clearRect(0, 0, width, height);
            
            // Background
            performanceCtx.fillStyle = 'rgba(15, 15, 30, 0.9)';
            performanceCtx.fillRect(0, 0, width, height);
            
            // Grid
            performanceCtx.strokeStyle = 'rgba(58, 58, 90, 0.5)';
            performanceCtx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= width; x += width / 10) {
                performanceCtx.beginPath();
                performanceCtx.moveTo(x, 0);
                performanceCtx.lineTo(x, height);
                performanceCtx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= height; y += height / 5) {
                performanceCtx.beginPath();
                performanceCtx.moveTo(0, y);
                performanceCtx.lineTo(width, y);
                performanceCtx.stroke();
            }
            
            // Draw power curve
            const points = [];
            const pointCount = 50;
            
            for (let i = 0; i < pointCount; i++) {
                const x = (i / pointCount) * width;
                const t = (i / pointCount) * Math.PI * 4 + time;
                const y = height * 0.5 + Math.sin(t) * height * 0.3 + 
                          Math.sin(t * 0.5) * height * 0.1;
                
                points.push({x, y});
            }
            
            // Draw power curve
            performanceCtx.strokeStyle = 'rgba(0, 200, 83, 0.8)';
            performanceCtx.lineWidth = 2;
            performanceCtx.beginPath();
            performanceCtx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                performanceCtx.lineTo(points[i].x, points[i].y);
            }
            
            performanceCtx.stroke();
            
            // Fill under curve
            performanceCtx.fillStyle = 'rgba(0, 200, 83, 0.2)';
            performanceCtx.beginPath();
            performanceCtx.moveTo(points[0].x, height);
            performanceCtx.lineTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                performanceCtx.lineTo(points[i].x, points[i].y);
            }
            
            performanceCtx.lineTo(points[points.length - 1].x, height);
            performanceCtx.closePath();
            performanceCtx.fill();
            
            // Draw efficiency curve
            const effPoints = [];
            
            for (let i = 0; i < pointCount; i++) {
                const x = (i / pointCount) * width;
                const t = (i / pointCount) * Math.PI * 4 + time + Math.PI;
                const y = height * 0.5 + Math.sin(t) * height * 0.2 + 
                          Math.sin(t * 0.3) * height * 0.05;
                
                effPoints.push({x, y});
            }
            
            performanceCtx.strokeStyle = 'rgba(255, 171, 0, 0.8)';
            performanceCtx.lineWidth = 2;
            performanceCtx.beginPath();
            performanceCtx.moveTo(effPoints[0].x, effPoints[0].y);
            
            for (let i = 1; i < effPoints.length; i++) {
                performanceCtx.lineTo(effPoints[i].x, effPoints[i].y);
            }
            
            performanceCtx.stroke();
            
            // Labels
            performanceCtx.fillStyle = '#a5b4fc';
            performanceCtx.font = '12px Arial';
            performanceCtx.textAlign = 'left';
            performanceCtx.fillText('Power (W)', 10, 20);
            
            performanceCtx.fillStyle = 'rgba(255, 171, 0, 0.8)';
            performanceCtx.fillText('Efficiency (%)', 10, 40);
            
            // Current value indicator
            const currentX = width * 0.8;
            const currentY = points[Math.floor(points.length * 0.8)].y;
            
            performanceCtx.fillStyle = 'rgba(0, 200, 83, 0.8)';
            performanceCtx.beginPath();
            performanceCtx.arc(currentX, currentY, 5, 0, Math.PI * 2);
            performanceCtx.fill();
            
            performanceCtx.strokeStyle = 'rgba(0, 200, 83, 0.3)';
            performanceCtx.setLineDash([5, 5]);
            performanceCtx.beginPath();
            performanceCtx.moveTo(currentX, currentY);
            performanceCtx.lineTo(currentX, height);
            performanceCtx.stroke();
            
            performanceCtx.setLineDash([]);
        }

        // Main animation loop
        function animate(currentTime = 0) {
            // Calculate FPS
            const deltaTime = currentTime - simulation.lastTime;
            simulation.lastTime = currentTime;
            simulation.fps = 1000 / deltaTime;
            
            // Update engine angle
            if (simulation.running) {
                const speedFactor = simulation.slowMotion ? 0.1 : 1;
                simulation.engineAngle += (engine.rpm * Math.PI / 30) * (deltaTime / 1000) * speedFactor;
                
                if (simulation.engineAngle > Math.PI * 4) {
                    simulation.engineAngle -= Math.PI * 4;
                    engine.performance.cyclesCompleted++;
                }
            }
            
            // Render all visualizations
            renderMainView();
            renderThermoDiagram();
            renderMolecularDynamics();
            renderHeatTransfer();
            renderPerformanceGraph();
            
            // Update particle count display
            document.getElementById('particleCount').textContent = 
                `Particles: ${simulation.particleCount.toLocaleString()}`;
            
            // Continue animation
            requestAnimationFrame(animate);
        }

        // Initialize simulation
        function initializeSimulation() {
            // Initialize particles
            initializeParticles(simulation.particleCount);
            
            // Hide loading overlay
            setTimeout(() => {
                document.getElementById('loadingOverlay').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingOverlay').style.display = 'none';
                }, 1000);
            }, 2000);
            
            // Start animation
            animate();
        }

        // Start simulation when page loads
        window.addEventListener('load', initializeSimulation);
    </script>
</body>
</html>