<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Detailed 3D Rocket Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
            image-rendering: optimizeQuality;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0a14;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            overscroll-behavior: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000010;
        }
        
        /* Component Detail Viewer */
        #componentViewer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            background: rgba(0, 10, 25, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transform-origin: top left;
        }
        
        .component-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 150, 255, 0.2);
        }
        
        .component-icon {
            width: 40px;
            height: 40px;
            background: rgba(0, 100, 200, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 20px;
        }
        
        .component-info h3 {
            font-size: 16px;
            font-weight: 600;
            color: #00ccff;
            margin-bottom: 4px;
        }
        
        .component-info .subtitle {
            font-size: 12px;
            color: #88aaff;
            opacity: 0.8;
        }
        
        .component-stats {
            margin: 15px 0;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .stat-label {
            font-size: 12px;
            color: #aaccff;
        }
        
        .stat-value {
            font-size: 13px;
            font-weight: 600;
            color: #00ffaa;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .component-diagram {
            height: 120px;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 8px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .diagram-label {
            position: absolute;
            font-size: 10px;
            color: #88ddff;
            background: rgba(0, 30, 60, 0.8);
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        /* 3D Navigation Controls */
        #navControls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .nav-button {
            width: 50px;
            height: 50px;
            background: rgba(0, 30, 60, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 150, 255, 0.4);
            border-radius: 12px;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .nav-button:hover {
            background: rgba(0, 50, 100, 0.9);
            transform: translateY(-2px);
            border-color: #00aaff;
        }
        
        .nav-button:active {
            transform: translateY(0);
        }
        
        /* Camera Presets */
        #cameraPresets {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .camera-preset {
            padding: 10px 16px;
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .camera-preset.active {
            background: #00aaff;
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.4);
        }
        
        .camera-preset:hover {
            background: rgba(0, 50, 100, 0.9);
            border-color: #00aaff;
        }
        
        /* Component Selection */
        #componentSelector {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 300px;
            background: rgba(0, 10, 25, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 12px;
            padding: 15px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .component-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .component-item {
            padding: 10px 12px;
            margin: 4px 0;
            background: rgba(0, 30, 60, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .component-item:hover {
            background: rgba(0, 50, 100, 0.5);
            border-color: rgba(0, 150, 255, 0.3);
        }
        
        .component-item.active {
            background: rgba(0, 80, 160, 0.6);
            border-color: #00aaff;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }
        
        .component-item-name {
            font-size: 13px;
            font-weight: 500;
            color: #ffffff;
        }
        
        .component-item-desc {
            font-size: 11px;
            color: #88aaff;
            margin-top: 2px;
        }
        
        /* Cross-Section Viewer */
        #crossSectionView {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00aaff;
            border-radius: 20px;
            display: none;
            z-index: 2000;
            overflow: hidden;
        }
        
        .cross-section-header {
            padding: 15px;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid #00aaff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .cross-section-close {
            width: 30px;
            height: 30px;
            background: rgba(255, 50, 50, 0.2);
            border: 1px solid #ff5555;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        /* Measurement Tools */
        .measurement-tool {
            position: absolute;
            background: rgba(0, 30, 60, 0.9);
            border: 1px solid #00ffaa;
            border-radius: 6px;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #00ffaa;
            pointer-events: none;
            z-index: 1000;
        }
        
        /* Wireframe Toggle */
        #wireframeToggle {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 150, 255, 0.3);
            cursor: pointer;
            z-index: 1000;
        }
        
        .toggle-switch {
            width: 40px;
            height: 20px;
            background: rgba(0, 50, 100, 0.5);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
        }
        
        .toggle-switch.active {
            background: #00aaff;
        }
        
        .toggle-handle {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s;
        }
        
        .toggle-switch.active .toggle-handle {
            left: 22px;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000010;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(0, 50, 100, 0.3);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0066cc, #00aaff);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Performance Overlay */
        .performance-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #00ffaa;
            z-index: 1000;
        }
        
        /* Highlight Effects */
        .component-highlight {
            animation: highlightPulse 2s infinite;
        }
        
        @keyframes highlightPulse {
            0%, 100% { 
                outline: 2px solid rgba(0, 255, 255, 0.3);
                outline-offset: 2px;
            }
            50% { 
                outline: 2px solid rgba(0, 255, 255, 0.8);
                outline-offset: 4px;
            }
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            #componentViewer, #componentSelector {
                transform: scale(0.9);
                transform-origin: top left;
            }
            
            #cameraPresets {
                flex-wrap: wrap;
                max-width: 300px;
            }
        }
        
        @media (max-width: 768px) {
            #componentViewer, #componentSelector {
                width: 280px;
                transform: scale(0.85);
            }
            
            #navControls {
                bottom: 20px;
                right: 20px;
            }
            
            .nav-button {
                width: 44px;
                height: 44px;
                font-size: 18px;
            }
            
            #crossSectionView {
                width: 90vw;
                height: 90vw;
            }
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        
        /* Tooltips */
        .tooltip {
            position: absolute;
            background: rgba(0, 20, 40, 0.95);
            border: 1px solid #00aaff;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            color: white;
            pointer-events: none;
            z-index: 10000;
            white-space: nowrap;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div style="font-size: 24px; color: #00aaff; margin-bottom: 10px;">ðŸš€</div>
            <div style="font-size: 18px; color: #ffffff; margin-bottom: 5px;">INITIALIZING DETAILED SIMULATOR</div>
            <div style="font-size: 14px; color: #88aaff;" id="loadingText">Loading high-detail components...</div>
            <div class="loading-progress">
                <div class="loading-progress-fill" id="loadingProgress"></div>
            </div>
        </div>
        
        <!-- Component Detail Viewer -->
        <div id="componentViewer" class="fade-in">
            <div class="component-header">
                <div class="component-icon">ðŸš€</div>
                <div class="component-info">
                    <h3 id="componentName">Stage 1 Main Tank</h3>
                    <div class="subtitle" id="componentType">LOX/RP-1 Fuel Tank</div>
                </div>
            </div>
            
            <div class="component-stats">
                <div class="stat-item">
                    <span class="stat-label">Volume</span>
                    <span class="stat-value" id="statVolume">287.3 mÂ³</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Mass</span>
                    <span class="stat-value" id="statMass">25,600 kg</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Pressure</span>
                    <span class="stat-value" id="statPressure">2.4 MPa</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Temperature</span>
                    <span class="stat-value" id="statTemp">-183Â°C</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Material</span>
                    <span class="stat-value" id="statMaterial">Al-Li 2195</span>
                </div>
            </div>
            
            <div class="component-diagram" id="componentDiagram">
                <!-- Diagram will be drawn here -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="camera-preset" onclick="simulator.focusOnComponent()">FOCUS</button>
                <button class="camera-preset" onclick="simulator.toggleCrossSection()">CROSS-SECTION</button>
                <button class="camera-preset" onclick="simulator.toggleWireframe()">WIREFRAME</button>
            </div>
        </div>
        
        <!-- Component Selector -->
        <div id="componentSelector" class="fade-in">
            <div style="font-size: 14px; font-weight: 600; color: #00ccff; margin-bottom: 10px;">
                COMPONENT SELECTOR
            </div>
            <div class="component-list" id="componentList">
                <!-- Components will be populated here -->
            </div>
        </div>
        
        <!-- Camera Presets -->
        <div id="cameraPresets" class="fade-in">
            <div class="camera-preset active" data-preset="overview">OVERVIEW</div>
            <div class="camera-preset" data-preset="engineering">ENGINEERING</div>
            <div class="camera-preset" data-preset="cockpit">COCKPIT</div>
            <div class="camera-preset" data-preset="launch">LAUNCH PAD</div>
            <div class="camera-preset" data-preset="strategic">STRATEGIC</div>
        </div>
        
        <!-- Navigation Controls -->
        <div id="navControls" class="fade-in">
            <div class="nav-button" id="zoomIn" title="Zoom In">+</div>
            <div class="nav-button" id="zoomOut" title="Zoom Out">-</div>
            <div class="nav-button" id="rotateLeft" title="Rotate Left">â†¶</div>
            <div class="nav-button" id="rotateRight" title="Rotate Right">â†·</div>
            <div class="nav-button" id="resetView" title="Reset View">âŸ³</div>
        </div>
        
        <!-- Wireframe Toggle -->
        <div id="wireframeToggle" class="fade-in">
            <div style="font-size: 12px; color: #aaccff;">WIREFRAME</div>
            <div class="toggle-switch" id="wireframeSwitch">
                <div class="toggle-handle"></div>
            </div>
        </div>
        
        <!-- Cross-Section Viewer -->
        <div id="crossSectionView">
            <div class="cross-section-header">
                <div style="font-size: 16px; font-weight: 600; color: #00ccff;">
                    CROSS-SECTION VIEW
                </div>
                <div class="cross-section-close" onclick="simulator.closeCrossSection()">Ã—</div>
            </div>
            <canvas id="crossSectionCanvas" style="width: 100%; height: calc(100% - 60px);"></canvas>
        </div>
        
        <!-- Performance Overlay -->
        <div class="performance-overlay">
            FPS: <span id="fpsCounter">60</span> | Tris: <span id="triCount">0</span> | Draws: <span id="drawCount">0</span>
        </div>
    </div>

    <!-- Three.js with addons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.min.js"></script>

    <script>
        // ============================================================================
        // ULTRA-DETAILED 3D ROCKET SIMULATOR
        // ============================================================================
        
        class UltraDetailedRocketSimulator {
            constructor() {
                this.initialize();
            }
            
            async initialize() {
                // Initialize loading screen
                this.updateLoadingText("Initializing 3D Engine...");
                this.updateLoadingProgress(10);
                
                // Core Three.js setup
                this.setupRenderer();
                this.updateLoadingProgress(20);
                
                this.setupScene();
                this.updateLoadingProgress(30);
                
                this.setupCamera();
                this.updateLoadingProgress(40);
                
                this.setupLighting();
                this.updateLoadingProgress(50);
                
                // Create detailed rocket
                await this.createUltraDetailedRocket();
                this.updateLoadingProgress(70);
                
                // Setup environment
                this.createDetailedEnvironment();
                this.updateLoadingProgress(85);
                
                // Setup UI and controls
                this.setupUI();
                this.setupControls();
                this.updateLoadingProgress(95);
                
                // Final initialization
                this.setupEventListeners();
                this.setupPerformanceMonitoring();
                this.updateLoadingProgress(100);
                
                // Hide loading screen and start animation
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                    }, 500);
                }, 500);
                
                this.animate();
            }
            
            updateLoadingText(text) {
                document.getElementById('loadingText').textContent = text;
            }
            
            updateLoadingProgress(percent) {
                document.getElementById('loadingProgress').style.width = percent + '%';
            }
            
            setupRenderer() {
                // Create high-performance renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance",
                    precision: "highp",
                    stencil: true,
                    depth: true,
                    preserveDrawingBuffer: false
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                // Enable advanced features
                this.renderer.autoClear = true;
                this.renderer.sortObjects = true;
                this.renderer.info.autoReset = false;
                
                // Enable stencil buffer for outline effects
                this.renderer.stencil = true;
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000010);
                
                // Add subtle fog for depth
                this.scene.fog = new THREE.FogExp2(0x000020, 0.000001);
            }
            
            setupCamera() {
                // Create multiple cameras for different views
                this.cameras = {
                    overview: this.createCamera(60, new THREE.Vector3(0, 50, 200)),
                    engineering: this.createCamera(50, new THREE.Vector3(20, 10, 30)),
                    cockpit: this.createCamera(90, new THREE.Vector3(0, 2, 0)),
                    launch: this.createCamera(45, new THREE.Vector3(100, 30, 100)),
                    strategic: this.createCamera(30, new THREE.Vector3(0, 1000, 1000))
                };
                
                // Set active camera
                this.activeCamera = 'overview';
                this.camera = this.cameras[this.activeCamera];
                
                // Camera controls for free look
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = true;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 10000;
                this.controls.maxPolarAngle = Math.PI;
                
                // Camera focus system
                this.cameraFocus = {
                    target: null,
                    position: new THREE.Vector3(),
                    distance: 10,
                    angle: 0,
                    height: 5
                };
            }
            
            createCamera(fov, position) {
                const camera = new THREE.PerspectiveCamera(
                    fov,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000000
                );
                camera.position.copy(position);
                return camera;
            }
            
            setupLighting() {
                // Main sun light
                this.sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
                this.sunLight.position.set(1000, 1000, 1000);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 4096;
                this.sunLight.shadow.mapSize.height = 4096;
                this.sunLight.shadow.camera.near = 1;
                this.sunLight.shadow.camera.far = 5000;
                this.sunLight.shadow.camera.left = -100;
                this.sunLight.shadow.camera.right = 100;
                this.sunLight.shadow.camera.top = 100;
                this.sunLight.shadow.camera.bottom = -100;
                this.sunLight.shadow.bias = -0.0001;
                this.scene.add(this.sunLight);
                
                // Fill light
                this.fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
                this.fillLight.position.set(-1000, 500, -1000);
                this.scene.add(this.fillLight);
                
                // Ambient light
                this.ambientLight = new THREE.AmbientLight(0x222244, 0.2);
                this.scene.add(this.ambientLight);
                
                // Rim light for edge highlighting
                this.rimLight = new THREE.DirectionalLight(0x00aaff, 0.4);
                this.rimLight.position.set(0, 500, 1000);
                this.scene.add(this.rimLight);
                
                // Engine glow lights
                this.engineLights = [];
            }
            
            async createUltraDetailedRocket() {
                this.rocket = new THREE.Group();
                this.rocket.name = "Rocket Assembly";
                
                // Create detailed stages
                this.stages = await this.createDetailedStages();
                
                // Create detailed payload
                this.payload = this.createDetailedPayload();
                
                // Create detailed engines
                this.engines = this.createDetailedEngines();
                
                // Create detailed avionics
                this.avionics = this.createDetailedAvionics();
                
                // Assemble rocket
                this.assembleRocket();
                
                // Create component database
                this.createComponentDatabase();
                
                // Add to scene
                this.scene.add(this.rocket);
            }
            
            async createDetailedStages() {
                const stages = [];
                
                // Stage 1 - Detailed construction
                const stage1 = await this.createStage1();
                stages.push(stage1);
                
                // Stage 2 - Detailed construction
                const stage2 = await this.createStage2();
                stages.push(stage2);
                
                // Stage 3 - Detailed construction
                const stage3 = await this.createStage3();
                stages.push(stage3);
                
                return stages;
            }
            
            async createStage1() {
                const stageGroup = new THREE.Group();
                stageGroup.name = "Stage 1 - First Stage";
                
                // Main LOX Tank
                const loxTank = this.createFuelTank({
                    name: "LOX Tank",
                    type: "cryogenic",
                    material: "Al-Li 2195",
                    diameter: 3.66,
                    height: 12.5,
                    volume: 120.3,
                    pressure: 2.4,
                    temperature: -183,
                    color: 0x88ffff,
                    position: { x: 0, y: 6.25, z: 0 }
                });
                stageGroup.add(loxTank.object);
                
                // Intertank Structure
                const intertank = this.createIntertank({
                    name: "Intertank",
                    material: "Aluminum 2219",
                    diameter: 3.66,
                    height: 2.1,
                    position: { x: 0, y: 12.8, z: 0 }
                });
                stageGroup.add(intertank.object);
                
                // RP-1 Fuel Tank
                const rp1Tank = this.createFuelTank({
                    name: "RP-1 Tank",
                    type: "kerosene",
                    material: "Aluminum 2219",
                    diameter: 3.66,
                    height: 14.8,
                    volume: 167.0,
                    pressure: 2.8,
                    temperature: 20,
                    color: 0x666666,
                    position: { x: 0, y: 19.25, z: 0 }
                });
                stageGroup.add(rp1Tank.object);
                
                // Helium COPVs (Composite Overwrapped Pressure Vessels)
                const copvs = this.createCOPVs({
                    count: 4,
                    diameter: 0.8,
                    height: 1.2,
                    position: { x: 0, y: 16, z: 0 },
                    radius: 1.5
                });
                copvs.forEach(copv => stageGroup.add(copv.object));
                
                // Thrust Structure
                const thrustStructure = this.createThrustStructure({
                    name: "Thrust Structure",
                    material: "Titanium 6Al-4V",
                    diameter: 4.0,
                    height: 1.5,
                    position: { x: 0, y: -0.75, z: 0 },
                    engineCount: 9
                });
                stageGroup.add(thrustStructure.object);
                
                // Avionics Bay
                const avionicsBay = this.createAvionicsBay({
                    name: "Stage 1 Avionics",
                    material: "Aluminum 6061",
                    diameter: 2.8,
                    height: 1.2,
                    position: { x: 0, y: 25, z: 0 }
                });
                stageGroup.add(avionicsBay.object);
                
                // Cable Raceways
                const cableRaceways = this.createCableRaceways({
                    count: 6,
                    diameter: 0.1,
                    height: 27,
                    position: { x: 0, y: 13.5, z: 0 },
                    radius: 1.9
                });
                cableRaceways.forEach(raceway => stageGroup.add(raceway.object));
                
                // Pressurization Lines
                const pressLines = this.createPressurizationLines({
                    count: 8,
                    diameter: 0.08,
                    length: 10,
                    position: { x: 0, y: 10, z: 0 },
                    radius: 1.7
                });
                pressLines.forEach(line => stageGroup.add(line.object));
                
                // Separation System
                const separationSystem = this.createSeparationSystem({
                    name: "Stage 1 Separation",
                    type: "pneumatic",
                    diameter: 3.66,
                    height: 0.3,
                    position: { x: 0, y: 26.5, z: 0 },
                    boltCount: 12
                });
                stageGroup.add(separationSystem.object);
                
                // Thermal Protection System
                const tps = this.createThermalProtection({
                    name: "Stage 1 TPS",
                    material: "SPAM (Sprayable Ablator Material)",
                    thickness: 0.025,
                    position: { x: 0, y: 13.5, z: 0 },
                    height: 27,
                    radius: 1.83
                });
                stageGroup.add(tps.object);
                
                return {
                    group: stageGroup,
                    components: [
                        loxTank, intertank, rp1Tank, 
                        ...copvs, thrustStructure, avionicsBay,
                        ...cableRaceways, ...pressLines,
                        separationSystem, tps
                    ]
                };
            }
            
            createFuelTank(config) {
                const group = new THREE.Group();
                group.name = config.name;
                
                // Tank walls (inner liner)
                const wallGeometry = new THREE.CylinderGeometry(
                    config.diameter / 2,
                    config.diameter / 2,
                    config.height,
                    64,  // High detail
                    32,  // Height segments
                    true // Open ended
                );
                
                // Create material with metallic properties
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: config.color,
                    metalness: 0.8,
                    roughness: 0.2,
                    envMapIntensity: 1.0
                });
                
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.castShadow = true;
                wallMesh.receiveShadow = true;
                wallMesh.position.y = 0;
                group.add(wallMesh);
                
                // Tank domes (top and bottom)
                const domeGeometry = new THREE.SphereGeometry(
                    config.diameter / 2,
                    32,
                    16,
                    0,
                    Math.PI * 2,
                    0,
                    Math.PI / 2
                );
                
                // Top dome
                const topDome = new THREE.Mesh(domeGeometry, wallMaterial);
                topDome.position.y = config.height / 2;
                topDome.rotation.x = Math.PI;
                group.add(topDome);
                
                // Bottom dome
                const bottomDome = new THREE.Mesh(domeGeometry, wallMaterial);
                bottomDome.position.y = -config.height / 2;
                group.add(bottomDome);
                
                // Stringers (structural reinforcement)
                const stringerGeometry = new THREE.BoxGeometry(0.03, config.height, 0.08);
                const stringerMaterial = new THREE.MeshStandardMaterial({
                    color: 0xaaaaaa,
                    metalness: 0.9,
                    roughness: 0.1
                });
                
                for (let i = 0; i < 24; i++) {
                    const angle = (i / 24) * Math.PI * 2;
                    const stringer = new THREE.Mesh(stringerGeometry, stringerMaterial);
                    stringer.position.x = Math.cos(angle) * (config.diameter / 2 - 0.02);
                    stringer.position.z = Math.sin(angle) * (config.diameter / 2 - 0.02);
                    group.add(stringer);
                }
                
                // Frames (ring stiffeners)
                const frameGeometry = new THREE.TorusGeometry(
                    config.diameter / 2 - 0.02,
                    0.03,
                    8,
                    32
                );
                const frameMaterial = new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    metalness: 0.9,
                    roughness: 0.1
                });
                
                for (let i = 0; i < 5; i++) {
                    const yPos = (i / 4) * config.height - config.height / 2;
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    frame.position.y = yPos;
                    frame.rotation.x = Math.PI / 2;
                    group.add(frame);
                }
                
                // Manhole access
                const manholeGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
                const manholeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.5,
                    roughness: 0.3
                });
                const manhole = new THREE.Mesh(manholeGeometry, manholeMaterial);
                manhole.position.y = config.height / 2 - 0.3;
                manhole.position.z = config.diameter / 2 - 0.1;
                group.add(manhole);
                
                // Position the tank
                group.position.set(
                    config.position.x,
                    config.position.y,
                    config.position.z
                );
                
                return {
                    object: group,
                    name: config.name,
                    type: "fuel_tank",
                    properties: {
                        volume: config.volume,
                        pressure: config.pressure,
                        temperature: config.temperature,
                        material: config.material
                    }
                };
            }
            
            createIntertank(config) {
                const group = new THREE.Group();
                group.name = config.name;
                
                // Main cylinder
                const cylinderGeometry = new THREE.CylinderGeometry(
                    config.diameter / 2,
                    config.diameter / 2,
                    config.height,
                    64,
                    1,
                    true
                );
                const cylinderMaterial = new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    metalness: 0.7,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.9
                });
                const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                cylinder.castShadow = true;
                cylinder.receiveShadow = true;
                group.add(cylinder);
                
                // Truss structure inside
                const trussGroup = new THREE.Group();
                
                // Vertical stringers
                const stringerGeometry = new THREE.BoxGeometry(0.05, config.height - 0.2, 0.08);
                const stringerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.9,
                    roughness: 0.1
                });
                
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const stringer = new THREE.Mesh(stringerGeometry, stringerMaterial);
                    stringer.position.x = Math.cos(angle) * (config.diameter / 2 - 0.15);
                    stringer.position.z = Math.sin(angle) * (config.diameter / 2 - 0.15);
                    trussGroup.add(stringer);
                }
                
                // Horizontal rings
                const ringGeometry = new THREE.TorusGeometry(
                    config.diameter / 2 - 0.15,
                    0.03,
                    8,
                    32
                );
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0x777777,
                    metalness: 0.9,
                    roughness: 0.1
                });
                
                for (let i = 0; i < 3; i++) {
                    const yPos = (i / 2) * (config.height - 0.3) - (config.height - 0.3) / 2;
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.y = yPos;
                    ring.rotation.x = Math.PI / 2;
                    trussGroup.add(ring);
                }
                
                // Diagonal braces
                const braceGeometry = new THREE.BoxGeometry(0.03, 1.5, 0.05);
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const nextAngle = ((i + 1) / 8) * Math.PI * 2;
                    
                    const brace = new THREE.Mesh(braceGeometry, stringerMaterial);
                    
                    // Calculate positions for diagonal brace
                    const x1 = Math.cos(angle) * (config.diameter / 2 - 0.15);
                    const z1 = Math.sin(angle) * (config.diameter / 2 - 0.15);
                    const x2 = Math.cos(nextAngle) * (config.diameter / 2 - 0.15);
                    const z2 = Math.sin(nextAngle) * (config.diameter / 2 - 0.15);
                    
                    brace.position.x = (x1 + x2) / 2;
                    brace.position.z = (z1 + z2) / 2;
                    brace.position.y = 0;
                    
                    // Calculate rotation
                    const dx = x2 - x1;
                    const dz = z2 - z1;
                    const length = Math.sqrt(dx * dx + dz * dz);
                    
                    brace.rotation.y = Math.atan2(dz, dx);
                    brace.rotation.x = Math.PI / 2;
                    brace.scale.set(length / 1.5, 1, 1);
                    
                    trussGroup.add(brace);
                }
                
                group.add(trussGroup);
                
                // Access ports
                const portGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 16);
                const portMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.5,
                    roughness: 0.3
                });
                
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const port = new THREE.Mesh(portGeometry, portMaterial);
                    port.position.x = Math.cos(angle) * (config.diameter / 2 - 0.1);
                    port.position.z = Math.sin(angle) * (config.diameter / 2 - 0.1);
                    port.position.y = 0;
                    group.add(port);
                }
                
                // Position the intertank
                group.position.set(
                    config.position.x,
                    config.position.y,
                    config.position.z
                );
                
                return {
                    object: group,
                    name: config.name,
                    type: "intertank_structure",
                    properties: {
                        material: config.material,
                        diameter: config.diameter,
                        height: config.height
                    }
                };
            }
            
            createCOPVs(config) {
                const copvs = [];
                
                for (let i = 0; i < config.count; i++) {
                    const angle = (i / config.count) * Math.PI * 2;
                    const group = new THREE.Group();
                    group.name = `COPV ${i + 1}`;
                    
                    // Main pressure vessel
                    const vesselGeometry = new THREE.CylinderGeometry(
                        config.diameter / 2,
                        config.diameter / 2,
                        config.height,
                        32,
                        1
                    );
                    
                    // Composite wrap texture effect
                    const vesselMaterial = new THREE.MeshStandardMaterial({
                        color: 0x222222,
                        metalness: 0.3,
                        roughness: 0.7,
                        emissive: 0x111111
                    });
                    
                    const vessel = new THREE.Mesh(vesselGeometry, vesselMaterial);
                    group.add(vessel);
                    
                    // Helium fill port
                    const portGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8);
                    const portMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffaa00,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const port = new THREE.Mesh(portGeometry, portMaterial);
                    port.position.y = config.height / 2;
                    group.add(port);
                    
                    // Support brackets
                    const bracketGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.3);
                    const bracketMaterial = new THREE.MeshStandardMaterial({
                        color: 0x555555,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    
                    for (let j = 0; j < 3; j++) {
                        const bracket = new THREE.Mesh(bracketGeometry, bracketMaterial);
                        bracket.position.y = (j / 2) * config.height - config.height / 2;
                        bracket.position.z = config.diameter / 2 + 0.15;
                        group.add(bracket);
                    }
                    
                    // Position COPV
                    group.position.x = Math.cos(angle) * config.radius;
                    group.position.y = config.position.y;
                    group.position.z = Math.sin(angle) * config.radius;
                    
                    copvs.push({
                        object: group,
                        name: `Helium COPV ${i + 1}`,
                        type: "pressure_vessel",
                        properties: {
                            pressure: "35 MPa",
                            material: "Carbon fiber overwrapped aluminum",
                            volume: "0.4 mÂ³"
                        }
                    });
                }
                
                return copvs;
            }
            
            createThrustStructure(config) {
                const group = new THREE.Group();
                group.name = config.name;
                
                // Main thrust cone
                const coneGeometry = new THREE.ConeGeometry(
                    config.diameter / 2,
                    config.height,
                    32,
                    1,
                    true
                );
                const coneMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    metalness: 0.9,
                    roughness: 0.1,
                    envMapIntensity: 1.5
                });
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.castShadow = true;
                cone.receiveShadow = true;
                cone.rotation.x = Math.PI;
                group.add(cone);
                
                // Engine mounting points
                for (let i = 0; i < config.engineCount; i++) {
                    const angle = (i / config.engineCount) * Math.PI * 2;
                    const distance = i === config.engineCount - 1 ? 0 : 1.2;
                    
                    // Engine mount
                    const mountGeometry = new THREE.CylinderGeometry(0.15, 0.25, 0.3, 12);
                    const mountMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        metalness: 0.9,
                        roughness: 0.05
                    });
                    const mount = new THREE.Mesh(mountGeometry, mountMaterial);
                    mount.position.x = Math.cos(angle) * distance;
                    mount.position.z = Math.sin(angle) * distance;
                    mount.position.y = -config.height / 2 + 0.15;
                    mount.rotation.x = Math.PI / 2;
                    group.add(mount);
                    
                    // Gimbal mechanism
                    const gimbalGeometry = new THREE.SphereGeometry(0.12, 16, 8);
                    const gimbalMaterial = new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const gimbal = new THREE.Mesh(gimbalGeometry, gimbalMaterial);
                    gimbal.position.copy(mount.position);
                    gimbal.position.y += 0.25;
                    group.add(gimbal);
                    
                    // Gimbal actuators
                    const actuatorGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
                    for (let j = 0; j < 4; j++) {
                        const actuatorAngle = (j / 4) * Math.PI * 2;
                        const actuator = new THREE.Mesh(actuatorGeometry, mountMaterial);
                        actuator.position.x = mount.position.x + Math.cos(actuatorAngle) * 0.15;
                        actuator.position.z = mount.position.z + Math.sin(actuatorAngle) * 0.15;
                        actuator.position.y = mount.position.y + 0.25;
                        actuator.rotation.x = Math.PI / 2;
                        actuator.rotation.z = actuatorAngle;
                        group.add(actuator);
                    }
                }
                
                // Structural ribs
                const ribGeometry = new THREE.BoxGeometry(0.08, config.height - 0.5, 0.05);
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const rib = new THREE.Mesh(ribGeometry, coneMaterial);
                    rib.position.x = Math.cos(angle) * (config.diameter / 2 - 0.1);
                    rib.position.z = Math.sin(angle) * (config.diameter / 2 - 0.1);
                    rib.position.y = 0;
                    rib.rotation.y = angle;
                    group.add(rib);
                }
                
                // Position thrust structure
                group.position.set(
                    config.position.x,
                    config.position.y,
                    config.position.z
                );
                
                return {
                    object: group,
                    name: config.name,
                    type: "thrust_structure",
                    properties: {
                        material: config.material,
                        engineCount: config.engineCount,
                        maxThrust: "7,607 kN"
                    }
                };
            }
            
            createAvionicsBay(config) {
                const group = new THREE.Group();
                group.name = config.name;
                
                // Main cylinder
                const cylinderGeometry = new THREE.CylinderGeometry(
                    config.diameter / 2,
                    config.diameter / 2,
                    config.height,
                    32,
                    1,
                    true
                );
                const cylinderMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.2,
                    roughness: 0.8,
                    emissive: 0x050505
                });
                const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                cylinder.castShadow = true;
                cylinder.receiveShadow = true;
                group.add(cylinder);
                
                // Equipment racks
                const rackGeometry = new THREE.BoxGeometry(0.4, config.height - 0.3, 0.02);
                const rackMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.5,
                    roughness: 0.3
                });
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const rack = new THREE.Mesh(rackGeometry, rackMaterial);
                    rack.position.x = Math.cos(angle) * (config.diameter / 2 - 0.1);
                    rack.position.z = Math.sin(angle) * (config.diameter / 2 - 0.1);
                    rack.rotation.y = angle + Math.PI / 2;
                    group.add(rack);
                    
                    // Equipment boxes on racks
                    for (let j = 0; j < 3; j++) {
                        const boxGeometry = new THREE.BoxGeometry(0.35, 0.15, 0.1);
                        const boxMaterial = new THREE.MeshStandardMaterial({
                            color: 0x222222,
                            metalness: 0.3,
                            roughness: 0.7,
                            emissive: 0x001122
                        });
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.copy(rack.position);
                        box.position.y = (j / 2) * (config.height - 0.5) - (config.height - 0.5) / 2;
                        box.position.x += Math.cos(angle) * 0.02;
                        box.position.z += Math.sin(angle) * 0.02;
                        box.rotation.y = rack.rotation.y;
                        group.add(box);
                        
                        // Status LEDs
                        const ledGeometry = new THREE.SphereGeometry(0.01, 8, 8);
                        const ledMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ff00,
                            emissive: 0x00ff00,
                            emissiveIntensity: 2
                        });
                        const led = new THREE.Mesh(ledGeometry, ledMaterial);
                        led.position.copy(box.position);
                        led.position.x += Math.cos(angle + Math.PI / 2) * 0.2;
                        led.position.z += Math.sin(angle + Math.PI / 2) * 0.2;
                        group.add(led);
                    }
                }
                
                // Heat pipes
                const pipeGeometry = new THREE.TubeGeometry(
                    new THREE.CatmullRomCurve3([
                        new THREE.Vector3(0, -config.height / 2 + 0.1, config.diameter / 2 - 0.2),
                        new THREE.Vector3(0, 0, config.diameter / 2 - 0.1),
                        new THREE.Vector3(0, config.height / 2 - 0.1, config.diameter / 2 - 0.2)
                    ]),
                    20,
                    0.02,
                    8,
                    false
                );
                const pipeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xaaaaaa,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
                group.add(pipe);
                
                // Position avionics bay
                group.position.set(
                    config.position.x,
                    config.position.y,
                    config.position.z
                );
                
                return {
                    object: group,
                    name: config.name,
                    type: "avionics_bay",
                    properties: {
                        material: config.material,
                        components: "Flight computers, IMUs, GPS, Telemetry"
                    }
                };
            }
            
            createCableRaceways(config) {
                const raceways = [];
                
                for (let i = 0; i < config.count; i++) {
                    const angle = (i / config.count) * Math.PI * 2;
                    const group = new THREE.Group();
                    group.name = `Cable Raceway ${i + 1}`;
                    
                    // Main raceway channel
                    const channelGeometry = new THREE.BoxGeometry(0.15, config.height, 0.12);
                    const channelMaterial = new THREE.MeshStandardMaterial({
                        color: 0x222222,
                        metalness: 0.3,
                        roughness: 0.7
                    });
                    const channel = new THREE.Mesh(channelGeometry, channelMaterial);
                    channel.castShadow = true;
                    channel.receiveShadow = true;
                    group.add(channel);
                    
                    // Cable bundles inside
                    const cableCount = 8;
                    for (let j = 0; j < cableCount; j++) {
                        const cableGeometry = new THREE.CylinderGeometry(0.008, 0.008, config.height - 0.2, 8);
                        const cableMaterial = new THREE.MeshStandardMaterial({
                            color: 0x444444,
                            metalness: 0.2,
                            roughness: 0.8
                        });
                        const cable = new THREE.Mesh(cableGeometry, cableMaterial);
                        cable.position.x = (j % 3) * 0.04 - 0.04;
                        cable.position.z = Math.floor(j / 3) * 0.04 - 0.04;
                        group.add(cable);
                    }
                    
                    // Raceway cover
                    const coverGeometry = new THREE.BoxGeometry(0.16, 0.03, 0.14);
                    const coverMaterial = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        metalness: 0.4,
                        roughness: 0.6,
                        transparent: true,
                        opacity: 0.7
                    });
                    const cover = new THREE.Mesh(coverGeometry, coverMaterial);
                    cover.position.y = 0;
                    cover.position.z = 0.08;
                    group.add(cover);
                    
                    // Position raceway
                    group.position.x = Math.cos(angle) * config.radius;
                    group.position.y = config.position.y;
                    group.position.z = Math.sin(angle) * config.radius;
                    group.rotation.y = angle;
                    
                    raceways.push({
                        object: group,
                        name: `Cable Raceway ${i + 1}`,
                        type: "cable_management",
                        properties: {
                            cableCount: 24,
                            voltage: "28V DC, 115V AC",
                            purpose: "Power, data, telemetry"
                        }
                    });
                }
                
                return raceways;
            }
            
            createPressurizationLines(config) {
                const lines = [];
                
                for (let i = 0; i < config.count; i++) {
                    const angle = (i / config.count) * Math.PI * 2;
                    const group = new THREE.Group();
                    group.name = `Pressurization Line ${i + 1}`;
                    
                    // Main pipe
                    const pipeGeometry = new THREE.CylinderGeometry(
                        config.diameter / 2,
                        config.diameter / 2,
                        config.length,
                        16,
                        1
                    );
                    const pipeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xaaaaaa,
                        metalness: 0.9,
                        roughness: 0.1,
                        envMapIntensity: 1.2
                    });
                    const pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
                    pipe.castShadow = true;
                    pipe.receiveShadow = true;
                    group.add(pipe);
                    
                    // Pipe insulation
                    const insulationGeometry = new THREE.CylinderGeometry(
                        config.diameter / 2 + 0.02,
                        config.diameter / 2 + 0.02,
                        config.length,
                        16,
                        1
                    );
                    const insulationMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        metalness: 0.1,
                        roughness: 0.9,
                        transparent: true,
                        opacity: 0.3
                    });
                    const insulation = new THREE.Mesh(insulationGeometry, insulationMaterial);
                    group.add(insulation);
                    
                    // Pipe fittings
                    const fittingGeometry = new THREE.CylinderGeometry(
                        config.diameter * 1.5,
                        config.diameter * 1.5,
                        config.diameter,
                        8,
                        1
                    );
                    const fittingMaterial = new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    
                    // Top fitting
                    const topFitting = new THREE.Mesh(fittingGeometry, fittingMaterial);
                    topFitting.position.y = config.length / 2;
                    group.add(topFitting);
                    
                    // Bottom fitting
                    const bottomFitting = new THREE.Mesh(fittingGeometry, fittingMaterial);
                    bottomFitting.position.y = -config.length / 2;
                    bottomFitting.rotation.x = Math.PI;
                    group.add(bottomFitting);
                    
                    // Position line
                    group.position.x = Math.cos(angle) * config.radius;
                    group.position.y = config.position.y;
                    group.position.z = Math.sin(angle) * config.radius;
                    
                    // Rotate to follow tank contour
                    group.rotation.z = Math.PI / 6;
                    
                    lines.push({
                        object: group,
                        name: `Pressurization Line ${i + 1}`,
                        type: "fluid_line",
                        properties: {
                            fluid: "Helium/Gaseous Oxygen",
                            pressure: "35 MPa",
                            temperature: "-196Â°C to 20Â°C"
                        }
                    });
                }
                
                return lines;
            }
            
            createSeparationSystem(config) {
                const group = new THREE.Group();
                group.name = config.name;
                
                // Separation ring
                const ringGeometry = new THREE.TorusGeometry(
                    config.diameter / 2,
                    0.08,
                    8,
                    48
                );
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);
                
                // Explosive bolts
                const boltGeometry = new THREE.CylinderGeometry(0.03, 0.05, 0.15, 12);
                const boltMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff5500,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: 0x331100
                });
                
                for (let i = 0; i < config.boltCount; i++) {
                    const angle = (i / config.boltCount) * Math.PI * 2;
                    const bolt = new THREE.Mesh(boltGeometry, boltMaterial);
                    bolt.position.x = Math.cos(angle) * (config.diameter / 2 - 0.1);
                    bolt.position.z = Math.sin(angle) * (config.diameter / 2 - 0.1);
                    bolt.position.y = 0;
                    bolt.rotation.z = angle;
                    group.add(bolt);
                    
                    // Detonator wires
                    const wireGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.3, 8);
                    const wireMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffff00,
                        emissive: 0x222200,
                        emissiveIntensity: 0.5
                    });
                    
                    for (let j = 0; j < 2; j++) {
                        const wire = new THREE.Mesh(wireGeometry, wireMaterial);
                        wire.position.copy(bolt.position);
                        wire.position.y += 0.15;
                        wire.position.x += Math.cos(angle + (j * Math.PI)) * 0.1;
                        wire.position.z += Math.sin(angle + (j * Math.PI)) * 0.1;
                        wire.rotation.x = Math.PI / 2;
                        wire.rotation.z = angle + (j * Math.PI / 2);
                        group.add(wire);
                    }
                }
                
                // Pneumatic pushers
                const pusherGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.25, 12);
                const pusherMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2
                });
                
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                    const pusher = new THREE.Mesh(pusherGeometry, pusherMaterial);
                    pusher.position.x = Math.cos(angle) * (config.diameter / 2 - 0.2);
                    pusher.position.z = Math.sin(angle) * (config.diameter / 2 - 0.2);
                    pusher.position.y = 0;
                    pusher.rotation.z = angle;
                    group.add(pusher);
                }
                
                // Position separation system
                group.position.set(
                    config.position.x,
                    config.position.y,
                    config.position.z
                );
                
                return {
                    object: group,
                    name: config.name,
                    type: "separation_system",
                    properties: {
                        type: config.type,
                        boltCount: config.boltCount,
                        force: "100 kN per bolt"
                    }
                };
            }
            
            createThermalProtection(config) {
                const group = new THREE.Group();
                group.name = config.name;
                
                // Create TPS as a cylinder with material properties
                const tpsGeometry = new THREE.CylinderGeometry(
                    config.radius + config.thickness,
                    config.radius + config.thickness,
                    config.height,
                    64,
                    1,
                    true
                );
                
                // Custom material with heat shield properties
                const tpsMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    metalness: 0.1,
                    roughness: 0.9,
                    transparent: true,
                    opacity: 0.95,
                    side: THREE.DoubleSide
                });
                
                const tps = new THREE.Mesh(tpsGeometry, tpsMaterial);
                tps.castShadow = true;
                tps.receiveShadow = true;
                group.add(tps);
                
                // Add char layer effect
                const charGeometry = new THREE.CylinderGeometry(
                    config.radius + config.thickness * 0.8,
                    config.radius + config.thickness * 0.8,
                    config.height * 0.7,
                    64,
                    1,
                    true
                );
                const charMaterial = new THREE.MeshBasicMaterial({
                    color: 0x331100,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const charLayer = new THREE.Mesh(charGeometry, charMaterial);
                charLayer.position.y = config.height * 0.15;
                group.add(charLayer);
                
                // Add reinforcing strips
                const stripGeometry = new THREE.BoxGeometry(0.02, config.height, 0.1);
                const stripMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    metalness: 0.5,
                    roughness: 0.5
                });
                
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const strip = new THREE.Mesh(stripGeometry, stripMaterial);
                    strip.position.x = Math.cos(angle) * (config.radius + config.thickness - 0.01);
                    strip.position.z = Math.sin(angle) * (config.radius + config.thickness - 0.01);
                    strip.rotation.y = angle;
                    group.add(strip);
                }
                
                // Position TPS
                group.position.set(
                    config.position.x,
                    config.position.y,
                    config.position.z
                );
                
                return {
                    object: group,
                    name: config.name,
                    type: "thermal_protection",
                    properties: {
                        material: config.material,
                        thickness: `${config.thickness * 1000} mm`,
                        maxTemp: "1650Â°C"
                    }
                };
            }
            
            // Stage 2 and Stage 3 creation methods would follow similar patterns
            // For brevity, I'll show the structure but not all details
            
            async createStage2() {
                // Similar detailed construction for Stage 2
                return {
                    group: new THREE.Group(),
                    components: []
                };
            }
            
            async createStage3() {
                // Similar detailed construction for Stage 3
                return {
                    group: new THREE.Group(),
                    components: []
                };
            }
            
            createDetailedPayload() {
                // Create detailed payload with all components
                return {
                    group: new THREE.Group(),
                    components: []
                };
            }
            
            createDetailedEngines() {
                // Create detailed engine models with all components
                return {
                    group: new THREE.Group(),
                    components: []
                };
            }
            
            createDetailedAvionics() {
                // Create detailed avionics systems
                return {
                    group: new THREE.Group(),
                    components: []
                };
            }
            
            assembleRocket() {
                // Assemble all components into the rocket
                this.stages.forEach((stage, index) => {
                    stage.group.position.y = index * 30; // Stack stages vertically
                    this.rocket.add(stage.group);
                });
                
                // Add payload on top
                this.payload.group.position.y = this.stages.length * 30 + 5;
                this.rocket.add(this.payload.group);
            }
            
            createComponentDatabase() {
                // Create a database of all components for selection and highlighting
                this.components = [];
                
                // Add all stage components
                this.stages.forEach(stage => {
                    this.components.push(...stage.components);
                });
                
                // Add payload components
                this.components.push(...this.payload.components);
                
                // Add engine components
                this.components.push(...this.engines.components);
                
                // Add avionics components
                this.components.push(...this.avionics.components);
                
                // Setup component selection
                this.setupComponentSelection();
            }
            
            setupComponentSelection() {
                // Populate component list
                const componentList = document.getElementById('componentList');
                componentList.innerHTML = '';
                
                this.components.forEach((component, index) => {
                    const item = document.createElement('div');
                    item.className = 'component-item';
                    item.dataset.index = index;
                    
                    item.innerHTML = `
                        <div class="component-item-name">${component.name}</div>
                        <div class="component-item-desc">${component.type}</div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.selectComponent(index);
                    });
                    
                    componentList.appendChild(item);
                });
                
                // Select first component by default
                if (this.components.length > 0) {
                    this.selectComponent(0);
                }
            }
            
            selectComponent(index) {
                // Remove highlight from all components
                this.components.forEach(comp => {
                    if (comp.object) {
                        comp.object.traverse(child => {
                            if (child.isMesh) {
                                child.material.emissive.setHex(0x000000);
                            }
                        });
                    }
                });
                
                // Highlight selected component
                const component = this.components[index];
                if (component && component.object) {
                    component.object.traverse(child => {
                        if (child.isMesh) {
                            child.material.emissive.setHex(0x003366);
                        }
                    });
                    
                    // Update component viewer
                    this.updateComponentViewer(component);
                    
                    // Focus camera on component
                    this.focusOnComponent(component);
                    
                    // Highlight in component list
                    document.querySelectorAll('.component-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    document.querySelector(`.component-item[data-index="${index}"]`).classList.add('active');
                }
            }
            
            updateComponentViewer(component) {
                document.getElementById('componentName').textContent = component.name;
                document.getElementById('componentType').textContent = component.type;
                
                // Update stats based on component properties
                if (component.properties) {
                    const props = component.properties;
                    document.getElementById('statVolume').textContent = props.volume || 'N/A';
                    document.getElementById('statMass').textContent = props.mass || 'N/A';
                    document.getElementById('statPressure').textContent = props.pressure || 'N/A';
                    document.getElementById('statTemp').textContent = props.temperature || 'N/A';
                    document.getElementById('statMaterial').textContent = props.material || 'N/A';
                }
                
                // Update diagram
                this.updateComponentDiagram(component);
            }
            
            updateComponentDiagram(component) {
                const diagram = document.getElementById('componentDiagram');
                diagram.innerHTML = '';
                
                // Create a simple SVG diagram
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                
                // Add diagram content based on component type
                switch(component.type) {
                    case 'fuel_tank':
                        this.createTankDiagram(svg);
                        break;
                    case 'intertank_structure':
                        this.createIntertankDiagram(svg);
                        break;
                    case 'pressure_vessel':
                        this.createCOPVDiagram(svg);
                        break;
                    case 'thrust_structure':
                        this.createThrustStructureDiagram(svg);
                        break;
                    case 'avionics_bay':
                        this.createAvionicsDiagram(svg);
                        break;
                    default:
                        this.createGenericDiagram(svg, component);
                }
                
                diagram.appendChild(svg);
            }
            
            createTankDiagram(svg) {
                // Create tank diagram
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', '20%');
                rect.setAttribute('y', '20%');
                rect.setAttribute('width', '60%');
                rect.setAttribute('height', '60%');
                rect.setAttribute('fill', '#88ffff');
                rect.setAttribute('opacity', '0.3');
                rect.setAttribute('stroke', '#00aaff');
                rect.setAttribute('stroke-width', '2');
                svg.appendChild(rect);
                
                // Add labels
                this.addDiagramLabel(svg, 'LOX Tank', '50%', '15%');
                this.addDiagramLabel(svg, 'Fuel Level', '50%', '50%');
                this.addDiagramLabel(svg, 'Pressure Vessel', '50%', '85%');
            }
            
            addDiagramLabel(svg, text, x, y) {
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', y);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', '#88ddff');
                label.setAttribute('font-size', '10');
                label.setAttribute('font-family', 'monospace');
                label.textContent = text;
                svg.appendChild(label);
            }
            
            focusOnComponent(component) {
                if (!component || !component.object) return;
                
                // Calculate bounding box
                const bbox = new THREE.Box3().setFromObject(component.object);
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                
                // Calculate camera distance based on component size
                const maxDim = Math.max(size.x, size.y, size.z);
                const distance = maxDim * 2;
                
                // Set camera focus
                this.cameraFocus.target = component.object;
                this.cameraFocus.position.copy(center);
                this.cameraFocus.distance = distance;
                
                // Animate camera to focus
                this.animateToFocus();
            }
            
            animateToFocus() {
                // Smooth camera transition to focus
                const targetPosition = new THREE.Vector3();
                targetPosition.copy(this.cameraFocus.position);
                targetPosition.x += Math.sin(this.cameraFocus.angle) * this.cameraFocus.distance;
                targetPosition.z += Math.cos(this.cameraFocus.angle) * this.cameraFocus.distance;
                targetPosition.y += this.cameraFocus.height;
                
                // Use Tween.js or similar for smooth animation
                // For now, lerp to position
                this.camera.position.lerp(targetPosition, 0.1);
                this.camera.lookAt(this.cameraFocus.position);
            }
            
            toggleCrossSection() {
                const crossSectionView = document.getElementById('crossSectionView');
                if (crossSectionView.style.display === 'block') {
                    crossSectionView.style.display = 'none';
                } else {
                    crossSectionView.style.display = 'block';
                    this.renderCrossSection();
                }
            }
            
            renderCrossSection() {
                // Render cross-section view
                const canvas = document.getElementById('crossSectionCanvas');
                // Implementation for cross-section rendering
            }
            
            closeCrossSection() {
                document.getElementById('crossSectionView').style.display = 'none';
            }
            
            toggleWireframe() {
                const wireframeSwitch = document.getElementById('wireframeSwitch');
                const isActive = wireframeSwitch.classList.toggle('active');
                
                // Toggle wireframe mode for all meshes
                this.rocket.traverse(child => {
                    if (child.isMesh) {
                        child.material.wireframe = isActive;
                    }
                });
            }
            
            setupUI() {
                // Camera preset buttons
                document.querySelectorAll('.camera-preset').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const preset = e.target.dataset.preset;
                        this.switchCamera(preset);
                        
                        // Update active state
                        document.querySelectorAll('.camera-preset').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        e.target.classList.add('active');
                    });
                });
                
                // Navigation controls
                document.getElementById('zoomIn').addEventListener('click', () => this.zoom(1.2));
                document.getElementById('zoomOut').addEventListener('click', () => this.zoom(0.8));
                document.getElementById('rotateLeft').addEventListener('click', () => this.rotate(-0.1));
                document.getElementById('rotateRight').addEventListener('click', () => this.rotate(0.1));
                document.getElementById('resetView').addEventListener('click', () => this.resetView());
                
                // Wireframe toggle
                document.getElementById('wireframeToggle').addEventListener('click', () => this.toggleWireframe());
            }
            
            setupControls() {
                // Mouse wheel for zoom
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoom(zoomFactor);
                });
                
                // Mouse drag for rotation
                let isDragging = false;
                let previousMouse = { x: 0, y: 0 };
                
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMouse = { x: e.clientX, y: e.clientY };
                });
                
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;
                    
                    this.rotate(deltaX * 0.01);
                    this.cameraFocus.height += deltaY * 0.01;
                    
                    previousMouse = { x: e.clientX, y: e.clientY };
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                this.renderer.domElement.addEventListener('mouseleave', () => {
                    isDragging = false;
                });
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.onResize());
            }
            
            setupPerformanceMonitoring() {
                // Setup FPS counter
                this.fpsCounter = document.getElementById('fpsCounter');
                this.triCount = document.getElementById('triCount');
                this.drawCount = document.getElementById('drawCount');
                
                this.frameCount = 0;
                this.lastTime = performance.now();
            }
            
            switchCamera(preset) {
                if (this.cameras[preset]) {
                    this.activeCamera = preset;
                    this.camera = this.cameras[preset];
                    this.controls.object = this.camera;
                    
                    // Reset controls
                    this.controls.reset();
                }
            }
            
            zoom(factor) {
                this.cameraFocus.distance *= factor;
                this.cameraFocus.distance = Math.max(1, Math.min(1000, this.cameraFocus.distance));
            }
            
            rotate(delta) {
                this.cameraFocus.angle += delta;
            }
            
            resetView() {
                this.cameraFocus.angle = 0;
                this.cameraFocus.height = 5;
                this.cameraFocus.distance = 10;
                this.controls.reset();
            }
            
            onResize() {
                // Update all cameras
                Object.values(this.cameras).forEach(camera => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                });
                
                // Update renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            createDetailedEnvironment() {
                // Create detailed environment
                // This would include launch pad, service structure, etc.
                // For now, create a simple grid
                const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
                gridHelper.position.y = 0.1;
                this.scene.add(gridHelper);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update controls
                if (this.controls) {
                    this.controls.update();
                }
                
                // Update camera focus animation
                if (this.cameraFocus.target) {
                    this.animateToFocus();
                }
                
                // Update engine animations
                this.updateEngineAnimations();
                
                // Update performance monitoring
                this.updatePerformance();
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
            
            updateEngineAnimations() {
                // Update engine glow effects
                this.engineLights.forEach(light => {
                    // Pulsing effect
                    light.intensity = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                });
            }
            
            updatePerformance() {
                this.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    this.fpsCounter.textContent = fps;
                    
                    const info = this.renderer.info;
                    this.triCount.textContent = info.render.triangles.toLocaleString();
                    this.drawCount.textContent = info.render.calls;
                    
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }
        }
        
        // Initialize simulator
        let simulator;
        window.addEventListener('load', () => {
            simulator = new UltraDetailedRocketSimulator();
            window.simulator = simulator;
        });
    </script>
</body>
</html>