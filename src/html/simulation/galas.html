<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Spiral Galaxy Simulation - Advanced Astrophysics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/stats.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/FilmPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/GlitchPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
            background: radial-gradient(circle at center, #000010 0%, #000000 100%);
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        /* Advanced UI with dynamic positioning */
        #ui-panels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-panel {
            pointer-events: auto;
            background: rgba(0, 5, 15, 0.92);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            border: 1px solid rgba(100, 180, 255, 0.4);
            box-shadow: 0 0 40px rgba(0, 80, 200, 0.3);
            transition: all 0.3s ease;
        }
        
        .ui-panel:hover {
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 0 60px rgba(0, 120, 255, 0.4);
        }
        
        #main-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 380px;
            padding: 25px;
        }
        
        #controls-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 360px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 25px;
        }
        
        #bottom-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 120px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #time-ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 30px;
            min-width: 300px;
            text-align: center;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #8cf, #4af, #0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
        }
        
        h2 {
            font-size: 1.4rem;
            margin: 20px 0 12px 0;
            color: #6af;
            border-bottom: 2px solid rgba(100, 180, 255, 0.4);
            padding-bottom: 8px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }
        
        h3 {
            font-size: 1.1rem;
            margin: 15px 0 8px 0;
            color: #8cf;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .info-item {
            background: rgba(10, 20, 40, 0.6);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .info-label {
            color: #aad;
            font-size: 0.9rem;
            display: block;
            margin-bottom: 4px;
        }
        
        .info-value {
            color: #fff;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        .control-section {
            background: rgba(10, 20, 40, 0.6);
            padding: 18px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            margin-bottom: 20px;
        }
        
        .slider-group {
            margin: 15px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #aad;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #1a3c7a, #2a6ccc);
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4af;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.8);
            transition: transform 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #6cf;
        }
        
        .toggle-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .toggle-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(20, 40, 80, 0.4);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .toggle-item:hover {
            background: rgba(30, 60, 120, 0.5);
            transform: translateY(-2px);
        }
        
        .toggle-item input {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .action-button {
            padding: 14px;
            background: linear-gradient(135deg, #2a5caa, #1a3c7a);
            border: 1px solid rgba(100, 180, 255, 0.6);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .action-button:hover {
            background: linear-gradient(135deg, #3a7cda, #2a5caa);
            box-shadow: 0 0 20px rgba(100, 180, 255, 0.7);
            transform: translateY(-2px);
        }
        
        .action-button:active {
            transform: translateY(0);
        }
        
        .action-button.danger {
            background: linear-gradient(135deg, #aa2a2a, #7a1a1a);
        }
        
        .action-button.danger:hover {
            background: linear-gradient(135deg, #da3a3a, #aa2a2a);
        }
        
        .action-button.success {
            background: linear-gradient(135deg, #2aaa5c, #1a7a3c);
        }
        
        .action-button.success:hover {
            background: linear-gradient(135deg, #3ada7c, #2aaa5c);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(0, 5, 15, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(100, 180, 255, 0.5);
            box-shadow: 0 0 50px rgba(0, 100, 255, 0.5);
        }
        
        .loading-text {
            font-size: 1.8rem;
            color: #8cf;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(100, 180, 255, 0.8);
        }
        
        .loading-subtext {
            font-size: 1rem;
            color: #aad;
            margin-bottom: 30px;
        }
        
        .progress-container {
            width: 400px;
            height: 10px;
            background: rgba(20, 40, 80, 0.5);
            border-radius: 5px;
            overflow: hidden;
            margin: 20px auto;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #2a5caa, #4af);
            border-radius: 5px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            color: #8cf;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        #notification-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .notification {
            background: rgba(0, 5, 15, 0.95);
            padding: 30px 40px;
            border-radius: 15px;
            border: 2px solid #4af;
            color: #fff;
            font-size: 1.2rem;
            text-align: center;
            max-width: 600px;
            box-shadow: 0 0 50px rgba(100, 180, 255, 0.5);
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.5s;
            pointer-events: auto;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .notification.warning {
            border-color: #ffaa00;
            box-shadow: 0 0 50px rgba(255, 170, 0, 0.5);
        }
        
        .notification.error {
            border-color: #ff3300;
            box-shadow: 0 0 50px rgba(255, 50, 0, 0.5);
        }
        
        .notification.success {
            border-color: #00ff88;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.5);
        }
        
        .star-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            padding: 6px;
            background: rgba(20, 40, 80, 0.3);
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .star-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 6px currentColor;
        }
        
        .mini-button {
            padding: 8px 12px;
            background: rgba(30, 60, 120, 0.6);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 6px;
            color: #aad;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .mini-button:hover {
            background: rgba(40, 80, 160, 0.8);
            color: #fff;
        }
        
        .graph-container {
            width: 100%;
            height: 100px;
            background: rgba(10, 20, 40, 0.6);
            border-radius: 8px;
            margin: 15px 0;
            padding: 10px;
            position: relative;
        }
        
        .graph-canvas {
            width: 100%;
            height: 100%;
        }
        
        .hud-stats {
            display: flex;
            gap: 20px;
        }
        
        .hud-stat {
            text-align: center;
            min-width: 100px;
        }
        
        .hud-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4af;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.8);
        }
        
        .hud-label {
            font-size: 0.9rem;
            color: #aad;
            margin-top: 5px;
        }
        
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 5, 15, 0.9);
            border-radius: 10px;
            border: 1px solid rgba(100, 180, 255, 0.4);
            overflow: hidden;
            z-index: 50;
        }
        
        .context-menu {
            position: absolute;
            background: rgba(0, 10, 25, 0.95);
            border-radius: 10px;
            border: 1px solid rgba(100, 180, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 80, 200, 0.3);
            backdrop-filter: blur(10px);
            padding: 10px 0;
            min-width: 200px;
            z-index: 1000;
            display: none;
        }
        
        .context-item {
            padding: 12px 20px;
            color: #aad;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .context-item:hover {
            background: rgba(100, 150, 255, 0.2);
            color: #fff;
        }
        
        .context-divider {
            height: 1px;
            background: rgba(100, 150, 255, 0.3);
            margin: 5px 0;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 10, 25, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(100, 180, 255, 0.5);
            color: #fff;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            display: none;
            backdrop-filter: blur(5px);
        }
        
        /* Animation for supernova effects */
        @keyframes supernova-flash {
            0% { opacity: 0; }
            10% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        .supernova-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,200,100,0.8) 0%, transparent 70%);
            pointer-events: none;
            z-index: 400;
            animation: supernova-flash 2s ease-out;
        }
        
        /* Pulsar beam animation */
        @keyframes pulsar-beam {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.5); }
        }
        
        .pulsar-beam {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(100,150,255,0.6) 0%, transparent 70%);
            pointer-events: none;
            z-index: 300;
            animation: pulsar-beam 0.5s ease-out;
        }
        
        /* Star twinkle effect */
        @keyframes star-twinkle {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .star-twinkle {
            animation: star-twinkle 3s infinite;
        }
        
        /* Responsive design */
        @media (max-width: 1400px) {
            #main-ui, #controls-ui {
                width: 340px;
            }
            
            #time-ui {
                min-width: 250px;
                padding: 15px 20px;
            }
        }
        
        @media (max-width: 1200px) {
            #main-ui, #controls-ui {
                width: 320px;
                padding: 20px;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
            
            .toggle-group {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-height: 800px) {
            #bottom-ui {
                height: 100px;
                padding: 15px;
            }
            
            .hud-value {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <!-- Loading Screen -->
        <div id="loading">
            <div class="loading-text">ðŸŒ€ Initializing Galaxy Simulation</div>
            <div class="loading-subtext">Building 20,000+ stars with astrophysical accuracy...</div>
            <div class="progress-container">
                <div class="progress-bar" id="loading-progress"></div>
            </div>
            <div class="progress-text" id="loading-text">0%</div>
            <div class="loading-subtext" id="loading-detail">Creating spiral arms...</div>
        </div>
        
        <!-- Notification Overlay -->
        <div id="notification-overlay"></div>
        
        <!-- Main UI Panels -->
        <div id="ui-panels">
            <!-- Top Center: Time Control -->
            <div id="time-ui" class="ui-panel">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 1rem; color: #aad;">Galactic Time</div>
                        <div style="font-size: 1.8rem; color: #4af; font-weight: bold;" id="current-time">0.0 Myr</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 0.9rem; color: #aad;">Time Scale</div>
                        <div style="font-size: 1.2rem; color: #8cf;" id="time-scale">1.0x</div>
                    </div>
                </div>
                <div class="progress-container" style="width: 100%; margin-top: 10px;">
                    <div class="progress-bar" id="time-progress" style="width: 0%"></div>
                </div>
            </div>
            
            <!-- Left: Main Information -->
            <div id="main-ui" class="ui-panel">
                <h1>ðŸŒ€ Spiral Galaxy</h1>
                
                <div class="info-grid">
                    <div class="info-item">
                        <span class="info-label">Total Stars</span>
                        <span class="info-value" id="total-stars">0</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Galaxy Mass</span>
                        <span class="info-value" id="galaxy-mass">1.5T Mâ˜‰</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Diameter</span>
                        <span class="info-value" id="galaxy-diameter">100k ly</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Spiral Arms</span>
                        <span class="info-value" id="spiral-arms">6</span>
                    </div>
                </div>
                
                <h3>Selected Object</h3>
                <div class="info-grid">
                    <div class="info-item">
                        <span class="info-label">Type</span>
                        <span class="info-value" id="selected-type">None</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Mass</span>
                        <span class="info-value" id="selected-mass">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Age</span>
                        <span class="info-value" id="selected-age">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Temperature</span>
                        <span class="info-value" id="selected-temp">-</span>
                    </div>
                </div>
                
                <h3>Star Distribution</h3>
                <div class="star-legend">
                    <div class="legend-item"><span class="star-icon" style="background: #ff3300;"></span> Red Dwarf</div>
                    <div class="legend-item"><span class="star-icon" style="background: #ff9966;"></span> Orange Dwarf</div>
                    <div class="legend-item"><span class="star-icon" style="background: #ffff00;"></span> Sun-like</div>
                    <div class="legend-item"><span class="star-icon" style="background: #ffffff;"></span> White Dwarf</div>
                    <div class="legend-item"><span class="star-icon" style="background: #ff9900;"></span> Red Giant</div>
                    <div class="legend-item"><span class="star-icon" style="background: #3399ff;"></span> Blue Giant</div>
                    <div class="legend-item"><span class="star-icon" style="background: #ff66cc;"></span> Neutron Star</div>
                    <div class="legend-item"><span class="star-icon" style="background: #000000; border: 1px solid #ff0000;"></span> Black Hole</div>
                </div>
            </div>
            
            <!-- Right: Controls -->
            <div id="controls-ui" class="ui-panel">
                <h2>Simulation Controls</h2>
                
                <div class="control-section">
                    <h3>Time & Speed</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Time Scale</span>
                            <span id="time-speed-value">1.0x</span>
                        </div>
                        <input type="range" id="time-speed" min="0" max="200" value="100" step="1">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Rotation Speed</span>
                            <span id="rotation-speed-value">1.0x</span>
                        </div>
                        <input type="range" id="rotation-speed" min="0" max="200" value="100" step="1">
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Visualization</h3>
                    <div class="toggle-group">
                        <label class="toggle-item">
                            <input type="checkbox" id="show-orbits" checked>
                            <span>Orbits</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="show-nebulas" checked>
                            <span>Nebulas</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="show-dark-matter">
                            <span>Dark Matter</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="show-spiral-arms" checked>
                            <span>Spiral Arms</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="show-labels" checked>
                            <span>Labels</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="show-glow" checked>
                            <span>Star Glow</span>
                        </label>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Physics & Events</h3>
                    <div class="toggle-group">
                        <label class="toggle-item">
                            <input type="checkbox" id="auto-supernovae" checked>
                            <span>Auto Supernovae</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="auto-star-formation" checked>
                            <span>Star Formation</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="enable-gravity">
                            <span>Gravity Effects</span>
                        </label>
                        <label class="toggle-item">
                            <input type="checkbox" id="enable-collisions">
                            <span>Stellar Collisions</span>
                        </label>
                    </div>
                    
                    <div class="button-grid">
                        <button class="action-button" id="trigger-supernova">Supernova</button>
                        <button class="action-button" id="form-star-cluster">Star Cluster</button>
                        <button class="action-button" id="create-blackhole">Black Hole</button>
                        <button class="action-button" id="simulate-collision">Galaxy Collision</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>Camera & View</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Camera Distance</span>
                            <span id="camera-distance-value">200</span>
                        </div>
                        <input type="range" id="camera-distance" min="50" max="1000" value="200" step="10">
                    </div>
                    
                    <select id="view-mode" style="width: 100%; padding: 10px; margin: 10px 0; background: rgba(20,40,80,0.8); border: 1px solid rgba(100,180,255,0.6); border-radius: 6px; color: white;">
                        <option value="free">Free Exploration</option>
                        <option value="top">Top View</option>
                        <option value="side">Edge View</option>
                        <option value="core" selected>Galactic Core</option>
                        <option value="arm">Spiral Arm</option>
                        <option value="orbit">Orbital</option>
                    </select>
                    
                    <div class="button-grid">
                        <button class="action-button" id="reset-view">Reset View</button>
                        <button class="action-button" id="follow-star">Follow Star</button>
                        <button class="action-button" id="toggle-immersion">Immersive Mode</button>
                        <button class="action-button success" id="save-state">Save State</button>
                    </div>
                </div>
            </div>
            
            <!-- Bottom: HUD -->
            <div id="bottom-ui" class="ui-panel">
                <div class="hud-stats">
                    <div class="hud-stat">
                        <div class="hud-value" id="hud-fps">0</div>
                        <div class="hud-label">FPS</div>
                    </div>
                    <div class="hud-stat">
                        <div class="hud-value" id="hud-stars">0</div>
                        <div class="hud-label">Stars</div>
                    </div>
                    <div class="hud-stat">
                        <div class="hud-value" id="hud-supernovae">0</div>
                        <div class="hud-label">Supernovae</div>
                    </div>
                    <div class="hud-stat">
                        <div class="hud-value" id="hud-blackholes">1</div>
                        <div class="hud-label">Black Holes</div>
                    </div>
                    <div class="hud-stat">
                        <div class="hud-value" id="hud-clusters">0</div>
                        <div class="hud-label">Clusters</div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button class="mini-button" id="toggle-ui">Hide UI</button>
                    <button class="mini-button" id="toggle-help">Help</button>
                    <button class="mini-button" id="toggle-stats">Stats</button>
                </div>
            </div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap"></div>
        
        <!-- Context Menu -->
        <div id="context-menu" class="context-menu">
            <div class="context-item" data-action="select">Select Object</div>
            <div class="context-item" data-action="follow">Follow Object</div>
            <div class="context-divider"></div>
            <div class="context-item" data-action="supernova">Trigger Supernova</div>
            <div class="context-item" data-action="blackhole">Create Black Hole</div>
            <div class="context-divider"></div>
            <div class="context-item" data-action="info">Show Information</div>
            <div class="context-item" data-action="bookmark">Bookmark Location</div>
        </div>
        
        <!-- Tooltip -->
        <div id="tooltip" class="tooltip"></div>
        
        <!-- Stats Container -->
        <div id="stats-container"></div>
    </div>

    <script>
        // Ultimate Spiral Galaxy Simulation with Advanced Features
        class UltimateGalaxySimulation {
            constructor() {
                // Core Three.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.composer = null;
                this.controls = null;
                this.stats = null;
                
                // Galaxy components
                this.stars = [];
                this.nebulas = [];
                this.starClusters = [];
                this.blackHoles = [];
                this.supernovae = [];
                this.pulsars = [];
                this.dustClouds = [];
                this.planetaryNebulas = [];
                this.gasClouds = [];
                
                // Galaxy parameters
                this.galaxyParams = {
                    name: "Andromeda II",
                    type: "SBc",
                    mass: 1.5e12, // Solar masses
                    diameter: 100000, // Light years
                    age: 13000, // Million years
                    rotationPeriod: 250, // Million years at solar radius
                    metallicity: 0.02, // Solar metallicity
                    starFormationRate: 1.0 // Solar masses per year
                };
                
                // Simulation state
                this.simulationTime = 0;
                this.timeScale = 1.0;
                this.rotationSpeed = 0.0001;
                this.isPaused = false;
                this.followingObject = null;
                this.selectedObject = null;
                this.immersionMode = false;
                this.uiVisible = true;
                
                // Performance optimization
                this.starGroups = new Map();
                this.instancedStars = new Map();
                this.LODlevels = [];
                this.frameCount = 0;
                this.lastFPSUpdate = 0;
                
                // Statistics
                this.statsData = {
                    totalStars: 0,
                    supernovaCount: 0,
                    blackHoleCount: 1,
                    clusterCount: 0,
                    binaryCount: 0,
                    starFormationCount: 0,
                    collisionCount: 0,
                    fps: 0
                };
                
                // Event system
                this.eventQueue = [];
                this.eventHandlers = new Map();
                
                // User settings
                this.settings = {
                    graphics: {
                        bloom: true,
                        bloomStrength: 1.5,
                        bloomRadius: 0.4,
                        bloomThreshold: 0.85,
                        starGlow: true,
                        motionBlur: false,
                        depthOfField: false,
                        antiAliasing: true
                    },
                    physics: {
                        gravity: false,
                        collisions: false,
                        relativity: false,
                        darkMatter: true,
                        magneticFields: false,
                        radiationPressure: false
                    },
                    simulation: {
                        autoEvents: true,
                        starEvolution: true,
                        galaxyEvolution: true,
                        saveHistory: true,
                        realTime: false
                    }
                };
                
                // Initialize
                this.init();
            }
            
            async init() {
                await this.showLoadingScreen();
                this.setupThreeJS();
                this.setupPostProcessing();
                this.createGalaxyStructure();
                this.setupEventSystem();
                this.setupUIEvents();
                this.hideLoadingScreen();
                this.animate();
            }
            
            async showLoadingScreen() {
                const steps = [
                    "Initializing rendering engine...",
                    "Setting up astrophysics models...",
                    "Creating spiral arm structure...",
                    "Generating stellar populations...",
                    "Building galactic bulge...",
                    "Creating interstellar medium...",
                    "Initializing supermassive black hole...",
                    "Setting up gravitational models...",
                    "Preparing visualization effects...",
                    "Finalizing simulation..."
                ];
                
                for (let i = 0; i < steps.length; i++) {
                    const progress = (i + 1) * (100 / steps.length);
                    document.getElementById('loading-progress').style.width = `${progress}%`;
                    document.getElementById('loading-text').textContent = `${Math.round(progress)}%`;
                    document.getElementById('loading-detail').textContent = steps[i];
                    
                    // Simulate some work being done
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            hideLoadingScreen() {
                const loading = document.getElementById('loading');
                loading.style.opacity = '0';
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
            }
            
            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000010, 0.001);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.camera.position.set(0, 150, 250);
                
                // Renderer with advanced settings
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance",
                    logarithmicDepthBuffer: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                // Controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.maxDistance = 5000;
                this.controls.minDistance = 10;
                this.controls.maxPolarAngle = Math.PI;
                
                // Stats
                this.stats = new Stats();
                this.stats.domElement.style.position = 'absolute';
                this.stats.domElement.style.top = '0px';
                this.stats.domElement.style.left = '0px';
                document.getElementById('stats-container').appendChild(this.stats.domElement);
                this.stats.domElement.style.display = 'none';
                
                // Window resize handler
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }
            
            setupPostProcessing() {
                // Effect composer for post-processing
                this.composer = new THREE.EffectComposer(this.renderer);
                
                // Render pass
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);
                
                // Bloom pass
                this.bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, // strength
                    0.4, // radius
                    0.85 // threshold
                );
                this.composer.addPass(this.bloomPass);
                
                // Film pass for some grain
                this.filmPass = new THREE.FilmPass(0.35, 0.025, 648, false);
                this.composer.addPass(this.filmPass);
                
                // Copy pass to finalize
                const copyPass = new THREE.ShaderPass(THREE.CopyShader);
                copyPass.renderToScreen = true;
                this.composer.addPass(copyPass);
            }
            
            createGalaxyStructure() {
                // Add advanced lighting
                this.setupAdvancedLighting();
                
                // Create galaxy components
                this.createSupermassiveBlackHole();
                this.createGalacticBulge();
                this.createSpiralArms();
                this.createStellarDisk();
                this.createStellarHalo();
                this.createInterstellarMedium();
                this.createGlobularClusters();
                this.createDarkMatterHalo();
                this.createAccretionDisks();
                this.createMagneticFields();
                
                // Initialize statistics
                this.updateStatistics();
            }
            
            setupAdvancedLighting() {
                // HDR-like lighting setup
                const ambientLight = new THREE.AmbientLight(0x222244, 0.4);
                this.scene.add(ambientLight);
                
                // Galactic core illumination
                const coreLight = new THREE.PointLight(0xffffaa, 5, 1000);
                coreLight.position.set(0, 0, 0);
                this.scene.add(coreLight);
                
                // Directional light for spiral arms
                const directionalLight = new THREE.DirectionalLight(0x4466ff, 1.5);
                directionalLight.position.set(100, 50, 100);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 1000;
                this.scene.add(directionalLight);
                
                // Additional point lights in spiral arms
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = 100 + Math.random() * 100;
                    const intensity = 0.5 + Math.random() * 0.5;
                    
                    const pointLight = new THREE.PointLight(0x4466ff, intensity, 500);
                    pointLight.position.set(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 10,
                        Math.sin(angle) * radius
                    );
                    this.scene.add(pointLight);
                }
                
                // Hemispheric light for ambient fill
                const hemisphereLight = new THREE.HemisphereLight(0x4488ff, 0x002244, 0.3);
                this.scene.add(hemisphereLight);
            }
            
            createSupermassiveBlackHole() {
                // Supermassive black hole with accretion disk
                const blackHoleGeometry = new THREE.SphereGeometry(3, 64, 64);
                const blackHoleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    emissive: 0x330000,
                    emissiveIntensity: 0.8
                });
                
                this.supermassiveBlackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                this.supermassiveBlackHole.position.set(0, 0, 0);
                
                // Event horizon visualization
                const horizonGeometry = new THREE.SphereGeometry(5, 64, 64);
                const horizonMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        uniform float time;
                        void main() {
                            vPosition = position;
                            vNormal = normalize(normalMatrix * normal);
                            
                            // Distortion effect
                            float distortion = sin(time * 2.0 + position.x * 0.5) * 
                                             cos(time * 1.5 + position.y * 0.3) * 
                                             sin(time * 2.5 + position.z * 0.4) * 0.2;
                            vec3 distortedPosition = position * (1.0 + distortion);
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(distortedPosition, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        uniform float time;
                        
                        void main() {
                            float dist = length(vPosition);
                            float intensity = 1.0 - smoothstep(0.0, 5.0, dist);
                            
                            // Swirling accretion effect
                            float angle = atan(vPosition.z, vPosition.x) + time;
                            float swirl = sin(angle * 5.0 + dist * 3.0) * 0.5 + 0.5;
                            
                            vec3 color = mix(
                                vec3(1.0, 0.3, 0.1),
                                vec3(1.0, 0.8, 0.2),
                                swirl
                            );
                            
                            float alpha = intensity * (0.3 + swirl * 0.2);
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const eventHorizon = new THREE.Mesh(horizonGeometry, horizonMaterial);
                this.supermassiveBlackHole.add(eventHorizon);
                
                // Accretion disk
                this.createAccretionDisk(0, 0, 0, 8, 20, 0xff3300, 0.7);
                
                this.supermassiveBlackHole.userData = {
                    type: 'supermassive_black_hole',
                    mass: 4.1e6, // 4.1 million solar masses
                    name: 'Sagittarius A*',
                    temperature: 0,
                    luminosity: 0,
                    age: 13000
                };
                
                this.scene.add(this.supermassiveBlackHole);
                this.blackHoles.push(this.supermassiveBlackHole);
            }
            
            createAccretionDisk(x, y, z, innerRadius, outerRadius, color, opacity) {
                const segments = 128;
                const geometry = new THREE.RingGeometry(innerRadius, outerRadius, segments);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        color: { value: new THREE.Color(color) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        uniform float time;
                        void main() {
                            vUv = uv;
                            float angle = atan(position.x, position.z) + time * 0.5;
                            float radius = length(vec2(position.x, position.z));
                            float height = sin(angle * 3.0 + radius * 2.0) * 0.5;
                            vec3 pos = vec3(position.x, height, position.z);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec2 vUv;
                        uniform vec3 color;
                        uniform float time;
                        
                        void main() {
                            float radial = vUv.x;
                            float angular = vUv.y * 3.14159 * 2.0 + time;
                            
                            // Temperature gradient
                            float temperature = 1.0 - radial;
                            vec3 hotColor = vec3(1.0, 0.5, 0.2);
                            vec3 coolColor = vec3(0.2, 0.1, 0.8);
                            vec3 diskColor = mix(coolColor, hotColor, temperature);
                            
                            // Spiral density waves
                            float density = sin(angular * 5.0 + radial * 10.0) * 0.5 + 0.5;
                            density *= sin(angular * 3.0 - time * 2.0) * 0.3 + 0.7;
                            
                            // Radial falloff
                            float falloff = 1.0 - smoothstep(0.7, 1.0, radial);
                            
                            float alpha = density * falloff * ${opacity.toFixed(2)};
                            gl_FragColor = vec4(diskColor, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const disk = new THREE.Mesh(geometry, material);
                disk.position.set(x, y, z);
                disk.rotation.x = Math.PI / 2;
                
                this.scene.add(disk);
                return disk;
            }
            
            createGalacticBulge() {
                // Create galactic bulge with advanced population synthesis
                const bulgeStars = 5000;
                const bulgeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
                
                // Use instancing for performance
                const instanceCount = bulgeStars;
                const instancedGeometry = new THREE.InstancedBufferGeometry();
                instancedGeometry.copy(bulgeGeometry);
                
                // Instance matrices
                const matrices = new Float32Array(instanceCount * 16);
                const colors = new Float32Array(instanceCount * 3);
                const sizes = new Float32Array(instanceCount);
                
                for (let i = 0; i < bulgeStars; i++) {
                    // Generate position using Hernquist profile
                    const a = 1.0; // Scale radius
                    const r = a * Math.sqrt(Math.random()) / (1 - Math.sqrt(Math.random()));
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta) * 0.3; // Flattened
                    const z = r * Math.cos(phi);
                    
                    // Determine star type based on metallicity and age
                    const age = 8000 + Math.random() * 5000;
                    const metallicity = 0.02 * (1 - r / 30); // Metallicity gradient
                    
                    let starType;
                    if (r < 5) {
                        // Inner bulge: mostly old, metal-rich
                        const rand = Math.random();
                        if (rand < 0.7) starType = 'redDwarf';
                        else if (rand < 0.85) starType = 'orangeDwarf';
                        else if (rand < 0.95) starType = 'whiteDwarf';
                        else starType = 'redGiant';
                    } else {
                        // Outer bulge: mixed population
                        const rand = Math.random();
                        if (rand < 0.6) starType = 'redDwarf';
                        else if (rand < 0.8) starType = 'orangeDwarf';
                        else if (rand < 0.9) starType = 'sunLike';
                        else if (rand < 0.97) starType = 'whiteDwarf';
                        else starType = 'redGiant';
                    }
                    
                    const color = this.getStarColor(starType);
                    const size = this.getStarSize(starType) * (0.8 + Math.random() * 0.4);
                    
                    // Create transformation matrix
                    const matrix = new THREE.Matrix4();
                    matrix.makeScale(size, size, size);
                    matrix.setPosition(x, y, z);
                    
                    matrix.toArray(matrices, i * 16);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    sizes[i] = size;
                }
                
                instancedGeometry.setAttribute('instanceMatrix', new THREE.InstancedBufferAttribute(matrices, 16));
                instancedGeometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(colors, 3));
                instancedGeometry.setAttribute('instanceSize', new THREE.InstancedBufferAttribute(sizes, 1));
                
                const bulgeMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        glowIntensity: { value: 0.7 }
                    },
                    vertexShader: `
                        attribute vec3 instanceColor;
                        attribute float instanceSize;
                        varying vec3 vColor;
                        varying float vSize;
                        
                        void main() {
                            vColor = instanceColor;
                            vSize = instanceSize;
                            
                            // Add subtle twinkling
                            float twinkle = sin(time * 2.0 + float(gl_InstanceID) * 0.1) * 0.1 + 0.9;
                            vec3 pos = position * instanceSize * twinkle;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        varying float vSize;
                        uniform float glowIntensity;
                        
                        void main() {
                            vec3 color = vColor;
                            float intensity = glowIntensity * (1.0 + vSize * 0.5);
                            gl_FragColor = vec4(color * intensity, 1.0);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                const bulgeMesh = new THREE.InstancedMesh(instancedGeometry, bulgeMaterial, instanceCount);
                bulgeMesh.userData = { type: 'bulge_stars', count: bulgeStars };
                this.scene.add(bulgeMesh);
                
                this.statsData.totalStars += bulgeStars;
            }
            
            createSpiralArms() {
                // Create logarithmic spiral arms with density waves
                const spiralArms = [
                    { name: 'Perseus', pitch: 0.18, radius: 0.15, width: 0.06, phase: 0, color: 0x4466ff },
                    { name: 'Norma', pitch: 0.16, radius: 0.22, width: 0.05, phase: Math.PI/2, color: 0x44aaff },
                    { name: 'Scutum-Centaurus', pitch: 0.20, radius: 0.25, width: 0.07, phase: Math.PI, color: 0x44ffaa },
                    { name: 'Sagittarius', pitch: 0.15, radius: 0.12, width: 0.04, phase: 3*Math.PI/2, color: 0xffaa44 },
                    { name: 'Orion', pitch: 0.12, radius: 0.08, width: 0.03, phase: Math.PI/4, color: 0xff66aa },
                    { name: 'Outer', pitch: 0.22, radius: 0.30, width: 0.08, phase: Math.PI/3, color: 0xaa44ff }
                ];
                
                const starsPerArm = 2000;
                
                spiralArms.forEach((arm, armIndex) => {
                    // Create instanced geometry for this arm
                    const armGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const instancedGeometry = new THREE.InstancedBufferGeometry();
                    instancedGeometry.copy(armGeometry);
                    
                    const instanceCount = starsPerArm;
                    const matrices = new Float32Array(instanceCount * 16);
                    const colors = new Float32Array(instanceCount * 3);
                    const ages = new Float32Array(instanceCount);
                    const masses = new Float32Array(instanceCount);
                    
                    for (let i = 0; i < starsPerArm; i++) {
                        // Spiral arm position with density wave
                        const t = i / starsPerArm;
                        const minRadius = 25;
                        const maxRadius = 200;
                        const radius = minRadius + t * (maxRadius - minRadius);
                        
                        // Spiral equation with density wave perturbation
                        const baseAngle = arm.phase + (radius / 10) * arm.pitch;
                        const densityWave = Math.sin(radius * 0.1 + this.simulationTime * 0.001) * 0.1;
                        const angle = baseAngle + densityWave + (Math.random() - 0.5) * arm.width;
                        
                        // 3D position with warp and flare
                        const warp = Math.sin(angle * 2) * 5 * (radius / maxRadius);
                        const flare = 1 - Math.pow(1 - t, 2); // Disk flares outward
                        
                        const x = Math.cos(angle) * radius;
                        const y = (Math.random() - 0.5) * 5 * flare + warp;
                        const z = Math.sin(angle) * radius;
                        
                        // Star properties based on position
                        const starType = this.getSpiralArmStarType(radius, y, t);
                        const age = t * 3000 + Math.random() * 1000; // Younger at tips
                        const mass = this.getStarMass(starType);
                        
                        const color = this.getStarColor(starType);
                        const size = this.getStarSize(starType) * (0.9 + Math.random() * 0.2);
                        
                        // Create transformation matrix
                        const matrix = new THREE.Matrix4();
                        matrix.makeScale(size, size, size);
                        matrix.setPosition(x, y, z);
                        
                        matrix.toArray(matrices, i * 16);
                        colors[i * 3] = color.r;
                        colors[i * 3 + 1] = color.g;
                        colors[i * 3 + 2] = color.b;
                        ages[i] = age;
                        masses[i] = mass;
                    }
                    
                    instancedGeometry.setAttribute('instanceMatrix', new THREE.InstancedBufferAttribute(matrices, 16));
                    instancedGeometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(colors, 3));
                    instancedGeometry.setAttribute('instanceAge', new THREE.InstancedBufferAttribute(ages, 1));
                    instancedGeometry.setAttribute('instanceMass', new THREE.InstancedBufferAttribute(masses, 1));
                    
                    const armMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0.0 },
                            armColor: { value: new THREE.Color(arm.color) }
                        },
                        vertexShader: `
                            attribute vec3 instanceColor;
                            attribute float instanceAge;
                            attribute float instanceMass;
                            varying vec3 vColor;
                            varying float vAge;
                            varying float vMass;
                            
                            void main() {
                                vColor = instanceColor;
                                vAge = instanceAge;
                                vMass = instanceMass;
                                
                                // Add rotation and twinkle
                                float rotation = time * 0.001 * (1.0 + instanceMass * 0.1);
                                float twinkle = sin(time * 3.0 + float(gl_InstanceID) * 0.01) * 0.15 + 0.85;
                                
                                vec4 pos = instanceMatrix * vec4(position * twinkle, 1.0);
                                pos.y += sin(rotation + pos.x * 0.01) * 0.5;
                                
                                gl_Position = projectionMatrix * modelViewMatrix * pos;
                            }
                        `,
                        fragmentShader: `
                            varying vec3 vColor;
                            varying float vAge;
                            varying float vMass;
                            uniform vec3 armColor;
                            
                            void main() {
                                // Age-based color adjustment
                                float ageFactor = clamp(vAge / 5000.0, 0.0, 1.0);
                                vec3 agedColor = mix(vColor, vec3(1.0, 0.8, 0.6), ageFactor * 0.3);
                                
                                // Mass-based brightness
                                float brightness = 0.7 + vMass * 0.3;
                                
                                // Spiral arm tint
                                vec3 finalColor = mix(agedColor, armColor, 0.1) * brightness;
                                
                                gl_FragColor = vec4(finalColor, 1.0);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const armMesh = new THREE.InstancedMesh(instancedGeometry, armMaterial, instanceCount);
                    armMesh.userData = {
                        type: 'spiral_arm',
                        name: arm.name,
                        stars: starsPerArm,
                        armData: arm
                    };
                    
                    this.scene.add(armMesh);
                    this.statsData.totalStars += starsPerArm;
                });
            }
            
            getSpiralArmStarType(radius, height, t) {
                // Complex star type distribution based on position
                const distanceFromPlane = Math.abs(height);
                const isInDenseRegion = t > 0.3 && t < 0.7 && distanceFromPlane < 2;
                
                if (isInDenseRegion) {
                    // Star-forming regions
                    const rand = Math.random();
                    if (rand < 0.02) return 'blueGiant';
                    if (rand < 0.08) return 'sunLike';
                    if (rand < 0.15) return 'orangeDwarf';
                    if (rand < 0.20) return 'redGiant';
                }
                
                // General distribution
                const rand = Math.random();
                if (rand < 0.65) return 'redDwarf';
                if (rand < 0.85) return 'orangeDwarf';
                if (rand < 0.95) return 'sunLike';
                if (rand < 0.98) return 'whiteDwarf';
                return 'redGiant';
            }
            
            getStarColor(starType) {
                const colors = {
                    'redDwarf': new THREE.Color(0xff3300),
                    'orangeDwarf': new THREE.Color(0xff9966),
                    'sunLike': new THREE.Color(0xffff00),
                    'whiteDwarf': new THREE.Color(0xffffff),
                    'redGiant': new THREE.Color(0xff9900),
                    'blueGiant': new THREE.Color(0x3399ff),
                    'neutronStar': new THREE.Color(0xff66cc),
                    'blackHole': new THREE.Color(0x000000)
                };
                return colors[starType] || new THREE.Color(0xffffff);
            }
            
            getStarSize(starType) {
                const sizes = {
                    'redDwarf': 0.15,
                    'orangeDwarf': 0.25,
                    'sunLike': 0.5,
                    'whiteDwarf': 0.12,
                    'redGiant': 1.8,
                    'blueGiant': 1.2,
                    'neutronStar': 0.08,
                    'blackHole': 0.2
                };
                return sizes[starType] || 0.1;
            }
            
            getStarMass(starType) {
                const masses = {
                    'redDwarf': 0.1 + Math.random() * 0.4,
                    'orangeDwarf': 0.5 + Math.random() * 0.3,
                    'sunLike': 0.8 + Math.random() * 0.4,
                    'whiteDwarf': 0.6,
                    'redGiant': 1.5 + Math.random() * 2,
                    'blueGiant': 10 + Math.random() * 20,
                    'neutronStar': 1.4,
                    'blackHole': 5 + Math.random() * 15
                };
                return masses[starType] || 1.0;
            }
            
            createStellarDisk() {
                // Create thin stellar disk between spiral arms
                const diskStars = 3000;
                const diskGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const instancedGeometry = new THREE.InstancedBufferGeometry();
                instancedGeometry.copy(diskGeometry);
                
                const matrices = new Float32Array(diskStars * 16);
                const colors = new Float32Array(diskStars * 3);
                
                for (let i = 0; i < diskStars; i++) {
                    const radius = 30 + Math.random() * 170;
                    const angle = Math.random() * Math.PI * 2;
                    const height = (Math.random() - 0.5) * 3;
                    
                    const x = Math.cos(angle) * radius;
                    const y = height;
                    const z = Math.sin(angle) * radius;
                    
                    // Disk stars are mostly main sequence
                    const starType = Math.random() < 0.8 ? 'redDwarf' : 
                                   Math.random() < 0.9 ? 'orangeDwarf' : 'sunLike';
                    
                    const color = this.getStarColor(starType);
                    const size = this.getStarSize(starType);
                    
                    const matrix = new THREE.Matrix4();
                    matrix.makeScale(size, size, size);
                    matrix.setPosition(x, y, z);
                    
                    matrix.toArray(matrices, i * 16);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                instancedGeometry.setAttribute('instanceMatrix', new THREE.InstancedBufferAttribute(matrices, 16));
                instancedGeometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(colors, 3));
                
                const diskMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const diskMesh = new THREE.InstancedMesh(instancedGeometry, diskMaterial, diskStars);
                diskMesh.userData = { type: 'disk_stars', count: diskStars };
                this.scene.add(diskMesh);
                
                this.statsData.totalStars += diskStars;
            }
            
            createStellarHalo() {
                // Create spherical halo of ancient stars
                const haloStars = 1000;
                
                for (let i = 0; i < haloStars; i++) {
                    const radius = 200 + Math.random() * 300;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    // Halo stars are very old
                    const starType = Math.random() < 0.7 ? 'whiteDwarf' : 
                                   Math.random() < 0.9 ? 'redDwarf' : 'orangeDwarf';
                    
                    const star = this.createIndividualStar(x, y, z, starType);
                    star.userData.age = 10000 + Math.random() * 3000;
                    star.userData.isHalo = true;
                    
                    this.stars.push(star);
                    this.statsData.totalStars++;
                }
            }
            
            createIndividualStar(x, y, z, type) {
                const geometry = new THREE.SphereGeometry(0.1, 12, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: this.getStarColor(type),
                    emissive: this.getStarColor(type),
                    emissiveIntensity: 0.7
                });
                
                const star = new THREE.Mesh(geometry, material);
                star.position.set(x, y, z);
                star.scale.setScalar(this.getStarSize(type));
                
                star.userData = {
                    type: type,
                    mass: this.getStarMass(type),
                    age: Math.random() * 5000,
                    temperature: this.getStarTemperature(type),
                    luminosity: this.getStarLuminosity(type)
                };
                
                this.scene.add(star);
                return star;
            }
            
            getStarTemperature(starType) {
                const temps = {
                    'redDwarf': 2500 + Math.random() * 1500,
                    'orangeDwarf': 3500 + Math.random() * 1000,
                    'sunLike': 5000 + Math.random() * 2000,
                    'whiteDwarf': 8000 + Math.random() * 12000,
                    'redGiant': 3000 + Math.random() * 1000,
                    'blueGiant': 10000 + Math.random() * 20000,
                    'neutronStar': 1000000
                };
                return temps[starType] || 5800;
            }
            
            getStarLuminosity(starType) {
                const luminosities = {
                    'redDwarf': 0.001 + Math.random() * 0.1,
                    'orangeDwarf': 0.1 + Math.random() * 0.4,
                    'sunLike': 0.5 + Math.random() * 1.5,
                    'whiteDwarf': 0.001 + Math.random() * 0.01,
                    'redGiant': 100 + Math.random() * 900,
                    'blueGiant': 10000 + Math.random() * 90000,
                    'neutronStar': 0.001
                };
                return luminosities[starType] || 1.0;
            }
            
            createInterstellarMedium() {
                // Create nebulas, dust clouds, and gas clouds
                this.createNebulas(15);
                this.createDustClouds(20);
                this.createGasClouds(10);
                this.createPlanetaryNebulas(5);
            }
            
            createNebulas(count) {
                for (let i = 0; i < count; i++) {
                    const radius = 50 + Math.random() * 150;
                    const angle = Math.random() * Math.PI * 2;
                    
                    const x = Math.cos(angle) * radius;
                    const y = (Math.random() - 0.5) * 5;
                    const z = Math.sin(angle) * radius;
                    
                    const size = 15 + Math.random() * 25;
                    const particleCount = 300 + Math.floor(Math.random() * 400);
                    
                    const nebula = this.createParticleCloud(x, y, z, size, particleCount, 0x4466ff, 0.6);
                    nebula.userData = {
                        type: 'nebula',
                        starFormationRate: 0.01 + Math.random() * 0.03,
                        age: Math.random() * 1000,
                        mass: 1000 + Math.random() * 9000
                    };
                    
                    this.nebulas.push(nebula);
                }
            }
            
            createParticleCloud(x, y, z, size, count, color, opacity) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                
                const baseColor = new THREE.Color(color);
                
                for (let i = 0; i < count; i++) {
                    // Spherical distribution
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.cbrt(Math.random()) * size;
                    
                    positions[i * 3] = x + r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = y + r * Math.sin(phi) * Math.sin(theta) * 0.3; // Flattened
                    positions[i * 3 + 2] = z + r * Math.cos(phi);
                    
                    // Color variation
                    const colorVar = new THREE.Color(
                        baseColor.r * (0.7 + Math.random() * 0.3),
                        baseColor.g * (0.7 + Math.random() * 0.3),
                        baseColor.b * (0.7 + Math.random() * 0.3)
                    );
                    
                    colors[i * 3] = colorVar.r;
                    colors[i * 3 + 1] = colorVar.g;
                    colors[i * 3 + 2] = colorVar.b;
                    
                    sizes[i] = 0.3 + Math.random() * 0.7;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        opacity: { value: opacity }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform float time;
                        
                        void main() {
                            vColor = color;
                            
                            // Animated particles
                            float animation = sin(time * 0.5 + float(gl_VertexID) * 0.01) * 0.5 + 0.5;
                            vec3 animPos = position;
                            animPos.x += sin(time + position.y * 0.1) * 0.5;
                            animPos.y += cos(time * 1.3 + position.z * 0.1) * 0.3;
                            
                            vec4 mvPosition = modelViewMatrix * vec4(animPos, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * animation;
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        uniform float opacity;
                        
                        void main() {
                            float dist = length(gl_PointCoord - vec2(0.5));
                            if (dist > 0.5) discard;
                            
                            float alpha = opacity * (1.0 - dist * 2.0);
                            gl_FragColor = vec4(vColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const cloud = new THREE.Points(geometry, material);
                return cloud;
            }
            
            createDustClouds(count) {
                for (let i = 0; i < count; i++) {
                    const radius = 40 + Math.random() * 160;
                    const angle = Math.random() * Math.PI * 2;
                    
                    const x = Math.cos(angle) * radius;
                    const y = (Math.random() - 0.5) * 3;
                    const z = Math.sin(angle) * radius;
                    
                    const size = 8 + Math.random() * 12;
                    const particleCount = 150 + Math.floor(Math.random() * 200);
                    
                    const cloud = this.createParticleCloud(x, y, z, size, particleCount, 0x886633, 0.4);
                    cloud.userData = { type: 'dust_cloud', mass: 100 + Math.random() * 900 };
                    
                    this.dustClouds.push(cloud);
                }
            }
            
            createGasClouds(count) {
                for (let i = 0; i < count; i++) {
                    const radius = 60 + Math.random() * 140;
                    const angle = Math.random() * Math.PI * 2;
                    
                    const x = Math.cos(angle) * radius;
                    const y = (Math.random() - 0.5) * 4;
                    const z = Math.sin(angle) * radius;
                    
                    const size = 20 + Math.random() * 30;
                    const particleCount = 200 + Math.floor(Math.random() * 300);
                    
                    const cloud = this.createParticleCloud(x, y, z, size, particleCount, 0x44aaff, 0.3);
                    cloud.userData = { 
                        type: 'gas_cloud', 
                        mass: 5000 + Math.random() * 15000,
                        temperature: 100 + Math.random() * 900,
                        density: 0.1 + Math.random() * 0.9
                    };
                    
                    this.gasClouds.push(cloud);
                }
            }
            
            createPlanetaryNebulas(count) {
                for (let i = 0; i < count; i++) {
                    const radius = 80 + Math.random() * 120;
                    const angle = Math.random() * Math.PI * 2;
                    
                    const x = Math.cos(angle) * radius;
                    const y = (Math.random() - 0.5) * 2;
                    const z = Math.sin(angle) * radius;
                    
                    const size = 3 + Math.random() * 7;
                    const particleCount = 100 + Math.floor(Math.random() * 150);
                    
                    const nebula = this.createParticleCloud(x, y, z, size, particleCount, 0xff66aa, 0.5);
                    nebula.userData = { 
                        type: 'planetary_nebula',
                        centralStarType: 'whiteDwarf',
                        age: 100 + Math.random() * 400
                    };
                    
                    this.planetaryNebulas.push(nebula);
                }
            }
            
            createGlobularClusters() {
                // Create globular clusters in galactic halo
                const clusterCount = 8;
                
                for (let i = 0; i < clusterCount; i++) {
                    const radius = 250 + Math.random() * 250;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    const cluster = {
                        position: new THREE.Vector3(x, y, z),
                        stars: [],
                        radius: 10 + Math.random() * 20,
                        age: 10000 + Math.random() * 3000
                    };
                    
                    const starsInCluster = 200 + Math.floor(Math.random() * 300);
                    
                    for (let j = 0; j < starsInCluster; j++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * cluster.radius * 2,
                            (Math.random() - 0.5) * cluster.radius,
                            (Math.random() - 0.5) * cluster.radius * 2
                        );
                        
                        const starPos = cluster.position.clone().add(offset);
                        
                        // Globular cluster stars are very old
                        const starType = Math.random() < 0.8 ? 'redDwarf' : 
                                       Math.random() < 0.95 ? 'orangeDwarf' : 'whiteDwarf';
                        
                        const star = this.createIndividualStar(starPos.x, starPos.y, starPos.z, starType);
                        star.userData.age = cluster.age + Math.random() * 1000;
                        star.userData.isGlobularCluster = true;
                        star.userData.clusterId = i;
                        
                        cluster.stars.push(star);
                        this.statsData.totalStars++;
                    }
                    
                    this.starClusters.push(cluster);
                    this.statsData.clusterCount++;
                }
            }
            
            createDarkMatterHalo() {
                // Create dark matter halo visualization
                const haloGeometry = new THREE.SphereGeometry(500, 48, 48);
                const haloMaterial = new THREE.MeshBasicMaterial({
                    color: 0x330066,
                    transparent: true,
                    opacity: 0.03,
                    wireframe: true,
                    visible: false
                });
                
                this.darkMatterHalo = new THREE.Mesh(haloGeometry, haloMaterial);
                this.scene.add(this.darkMatterHalo);
            }
            
            createMagneticFields() {
                // Create visualization of galactic magnetic fields
                const fieldLines = 12;
                
                for (let i = 0; i < fieldLines; i++) {
                    const points = [];
                    const segments = 100;
                    
                    for (let j = 0; j <= segments; j++) {
                        const t = j / segments;
                        const radius = 50 + t * 150;
                        const angle = (i / fieldLines) * Math.PI * 2 + t * Math.PI * 4;
                        
                        // Spiral with some perturbation
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(t * Math.PI * 2) * 20;
                        const z = Math.sin(angle) * radius;
                        
                        points.push(new THREE.Vector3(x, y, z));
                    }
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: 0x44aaff,
                        transparent: true,
                        opacity: 0.1,
                        linewidth: 1
                    });
                    
                    const fieldLine = new THREE.Line(geometry, material);
                    fieldLine.userData = { type: 'magnetic_field' };
                    this.scene.add(fieldLine);
                }
            }
            
            setupEventSystem() {
                // Mouse event handlers
                this.renderer.domElement.addEventListener('click', this.onMouseClick.bind(this));
                this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.renderer.domElement.addEventListener('contextmenu', this.onContextMenu.bind(this));
                
                // Keyboard controls
                document.addEventListener('keydown', this.onKeyDown.bind(this));
                
                // Register event handlers
                this.eventHandlers.set('supernova', this.handleSupernova.bind(this));
                this.eventHandlers.set('star_formation', this.handleStarFormation.bind(this));
                this.eventHandlers.set('black_hole_formation', this.handleBlackHoleFormation.bind(this));
                this.eventHandlers.set('galaxy_collision', this.handleGalaxyCollision.bind(this));
            }
            
            setupUIEvents() {
                // Time controls
                document.getElementById('time-speed').addEventListener('input', (e) => {
                    this.timeScale = parseFloat(e.target.value) / 100;
                    document.getElementById('time-speed-value').textContent = this.timeScale.toFixed(1) + 'x';
                });
                
                document.getElementById('rotation-speed').addEventListener('input', (e) => {
                    this.rotationSpeed = parseFloat(e.target.value) / 100000;
                    document.getElementById('rotation-speed-value').textContent = (parseFloat(e.target.value) / 100).toFixed(1) + 'x';
                });
                
                // Camera controls
                document.getElementById('camera-distance').addEventListener('input', (e) => {
                    const distance = parseFloat(e.target.value);
                    document.getElementById('camera-distance-value').textContent = distance;
                    this.updateCameraDistance(distance);
                });
                
                document.getElementById('view-mode').addEventListener('change', (e) => {
                    this.changeViewMode(e.target.value);
                });
                
                // Action buttons
                document.getElementById('trigger-supernova').addEventListener('click', () => this.triggerSupernova());
                document.getElementById('form-star-cluster').addEventListener('click', () => this.formStarCluster());
                document.getElementById('create-blackhole').addEventListener('click', () => this.createBlackHole());
                document.getElementById('simulate-collision').addEventListener('click', () => this.simulateGalaxyCollision());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                document.getElementById('follow-star').addEventListener('click', () => this.toggleFollowMode());
                document.getElementById('toggle-immersion').addEventListener('click', () => this.toggleImmersionMode());
                document.getElementById('save-state').addEventListener('click', () => this.saveSimulationState());
                document.getElementById('toggle-ui').addEventListener('click', () => this.toggleUI());
                document.getElementById('toggle-help').addEventListener('click', () => this.showHelp());
                document.getElementById('toggle-stats').addEventListener('click', () => this.toggleStats());
                
                // Toggle controls
                const toggles = [
                    'show-orbits', 'show-nebulas', 'show-dark-matter',
                    'show-spiral-arms', 'show-labels', 'show-glow',
                    'auto-supernovae', 'auto-star-formation',
                    'enable-gravity', 'enable-collisions'
                ];
                
                toggles.forEach(id => {
                    document.getElementById(id).addEventListener('change', (e) => {
                        this.updateSetting(id.replace('-', '_'), e.target.checked);
                    });
                });
            }
            
            onMouseClick(event) {
                event.preventDefault();
                
                // Calculate mouse position in normalized device coordinates
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.mouse.set(x, y);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Check for intersections
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    this.selectObject(object);
                } else {
                    this.deselectObject();
                }
            }
            
            onMouseMove(event) {
                // Update tooltip position
                const tooltip = document.getElementById('tooltip');
                tooltip.style.left = (event.clientX + 10) + 'px';
                tooltip.style.top = (event.clientY + 10) + 'px';
                
                // Raycast for hover effects
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.mouse.set(x, y);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    this.showTooltip(object);
                } else {
                    this.hideTooltip();
                }
            }
            
            onContextMenu(event) {
                event.preventDefault();
                
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.mouse.set(x, y);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    this.showContextMenu(event.clientX, event.clientY, object);
                }
            }
            
            onKeyDown(event) {
                switch(event.key) {
                    case ' ':
                        this.triggerSupernova();
                        break;
                    case 'c':
                        this.formStarCluster();
                        break;
                    case 'b':
                        this.createBlackHole();
                        break;
                    case 'r':
                        this.resetView();
                        break;
                    case 'f':
                        this.toggleFollowMode();
                        break;
                    case 'i':
                        this.toggleImmersionMode();
                        break;
                    case 'u':
                        this.toggleUI();
                        break;
                    case 'h':
                        this.showHelp();
                        break;
                    case 's':
                        this.toggleStats();
                        break;
                    case 'Escape':
                        this.deselectObject();
                        break;
                    case 'p':
                    case 'P':
                        this.isPaused = !this.isPaused;
                        this.showNotification(this.isPaused ? 'Simulation Paused' : 'Simulation Resumed', 2000);
                        break;
                }
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
            
            selectObject(object) {
                // Deselect current object
                if (this.selectedObject) {
                    this.deselectObject();
                }
                
                // Select new object
                this.selectedObject = object;
                
                // Highlight object
                if (object.material) {
                    object.userData.originalEmissive = object.material.emissive ? object.material.emissive.clone() : null;
                    object.userData.originalEmissiveIntensity = object.material.emissiveIntensity || 0;
                    
                    if (object.material.emissive) {
                        object.material.emissive.set(0xffffff);
                        object.material.emissiveIntensity = 2.0;
                    }
                }
                
                // Update UI
                this.updateSelectedObjectUI();
                
                // Show notification
                this.showNotification(`Selected: ${object.userData.type || 'Unknown Object'}`, 3000);
            }
            
            deselectObject() {
                if (this.selectedObject) {
                    // Restore original appearance
                    if (this.selectedObject.material && this.selectedObject.userData.originalEmissive) {
                        this.selectedObject.material.emissive.copy(this.selectedObject.userData.originalEmissive);
                        this.selectedObject.material.emissiveIntensity = this.selectedObject.userData.originalEmissiveIntensity;
                    }
                    
                    this.selectedObject = null;
                    this.updateSelectedObjectUI();
                }
            }
            
            updateSelectedObjectUI() {
                if (this.selectedObject && this.selectedObject.userData) {
                    const data = this.selectedObject.userData;
                    document.getElementById('selected-type').textContent = data.type || 'Unknown';
                    document.getElementById('selected-mass').textContent = data.mass ? data.mass.toFixed(2) + ' Mâ˜‰' : '-';
                    document.getElementById('selected-age').textContent = data.age ? data.age.toFixed(0) + ' Myr' : '-';
                    document.getElementById('selected-temp').textContent = data.temperature ? data.temperature.toFixed(0) + ' K' : '-';
                } else {
                    document.getElementById('selected-type').textContent = 'None';
                    document.getElementById('selected-mass').textContent = '-';
                    document.getElementById('selected-age').textContent = '-';
                    document.getElementById('selected-temp').textContent = '-';
                }
            }
            
            showTooltip(object) {
                const tooltip = document.getElementById('tooltip');
                
                if (object.userData) {
                    let text = `<strong>${object.userData.type || 'Object'}</strong>`;
                    
                    if (object.userData.mass) text += `<br>Mass: ${object.userData.mass.toFixed(2)} Mâ˜‰`;
                    if (object.userData.age) text += `<br>Age: ${object.userData.age.toFixed(0)} Myr`;
                    if (object.userData.temperature) text += `<br>Temp: ${object.userData.temperature.toFixed(0)} K`;
                    if (object.userData.name) text += `<br>${object.userData.name}`;
                    
                    tooltip.innerHTML = text;
                    tooltip.style.display = 'block';
                }
            }
            
            hideTooltip() {
                document.getElementById('tooltip').style.display = 'none';
            }
            
            showContextMenu(x, y, object) {
                const menu = document.getElementById('context-menu');
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.style.display = 'block';
                
                // Set up context menu actions
                const items = menu.querySelectorAll('.context-item');
                items.forEach(item => {
                    item.onclick = () => {
                        this.handleContextAction(item.dataset.action, object);
                        menu.style.display = 'none';
                    };
                });
                
                // Close menu when clicking elsewhere
                const closeMenu = () => {
                    menu.style.display = 'none';
                    document.removeEventListener('click', closeMenu);
                };
                
                setTimeout(() => {
                    document.addEventListener('click', closeMenu);
                }, 100);
            }
            
            handleContextAction(action, object) {
                switch(action) {
                    case 'select':
                        this.selectObject(object);
                        break;
                    case 'follow':
                        this.followingObject = object;
                        this.showNotification('Now following object', 2000);
                        break;
                    case 'supernova':
                        this.triggerObjectSupernova(object);
                        break;
                    case 'blackhole':
                        this.createObjectBlackHole(object);
                        break;
                    case 'info':
                        this.showObjectInfo(object);
                        break;
                    case 'bookmark':
                        this.bookmarkLocation(object.position);
                        break;
                }
            }
            
            triggerObjectSupernova(object) {
                if (object.userData && (object.userData.type === 'blueGiant' || object.userData.type === 'redGiant')) {
                    this.createSupernova(object.position, object.userData.mass);
                } else {
                    this.showNotification('Object cannot go supernova', 3000, 'warning');
                }
            }
            
            createObjectBlackHole(object) {
                if (object.userData && object.userData.mass > 3) {
                    this.createBlackHoleAtPosition(object.position, object.userData.mass);
                } else {
                    this.showNotification('Object mass too low for black hole formation', 3000, 'warning');
                }
            }
            
            showObjectInfo(object) {
                let info = `<h3>Object Information</h3>`;
                
                for (const [key, value] of Object.entries(object.userData)) {
                    if (typeof value === 'number') {
                        info += `<br><strong>${key}:</strong> ${value.toFixed(2)}`;
                    } else {
                        info += `<br><strong>${key}:</strong> ${value}`;
                    }
                }
                
                this.showNotification(info, 5000);
            }
            
            bookmarkLocation(position) {
                const bookmarks = JSON.parse(localStorage.getItem('galaxy_bookmarks') || '[]');
                bookmarks.push({
                    position: { x: position.x, y: position.y, z: position.z },
                    time: Date.now(),
                    simulationTime: this.simulationTime
                });
                
                localStorage.setItem('galaxy_bookmarks', JSON.stringify(bookmarks));
                this.showNotification('Location bookmarked', 2000, 'success');
            }
            
            triggerSupernova() {
                // Find a suitable star for supernova
                const massiveStars = this.stars.filter(star => 
                    star.userData && 
                    (star.userData.type === 'blueGiant' || star.userData.type === 'redGiant') &&
                    star.userData.age > 50
                );
                
                if (massiveStars.length > 0) {
                    const star = massiveStars[Math.floor(Math.random() * massiveStars.length)];
                    this.createSupernova(star.position, star.userData.mass);
                } else {
                    // Create a new massive star
                    const radius = 100 + Math.random() * 100;
                    const angle = Math.random() * Math.PI * 2;
                    
                    const position = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 3,
                        Math.sin(angle) * radius
                    );
                    
                    this.createSupernova(position, 15 + Math.random() * 10);
                }
            }
            
            createSupernova(position, mass) {
                // Create supernova explosion
                this.statsData.supernovaCount++;
                
                // Visual effects
                this.createSupernovaVisuals(position, mass);
                
                // Physical effects
                if (mass > 8) {
                    // Create neutron star
                    this.createNeutronStar(position);
                } else if (mass > 3) {
                    // Create black hole
                    this.createBlackHoleAtPosition(position, Math.max(3, mass * 0.2));
                } else {
                    // Create white dwarf
                    this.createWhiteDwarf(position);
                }
                
                // Update UI
                this.updateStatistics();
                
                // Show notification
                this.showNotification(`SUPERNOVA! Mass: ${mass.toFixed(1)} Mâ˜‰`, 4000, 'warning');
            }
            
            createSupernovaVisuals(position, mass) {
                // Flash effect
                const flash = document.createElement('div');
                flash.className = 'supernova-flash';
                flash.style.left = '0';
                flash.style.top = '0';
                document.getElementById('container').appendChild(flash);
                
                setTimeout(() => {
                    flash.remove();
                }, 2000);
                
                // 3D shockwave
                const shockwaveGeometry = new THREE.SphereGeometry(1, 32, 32);
                const shockwaveMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        mass: { value: mass }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float mass;
                        varying vec3 vPosition;
                        
                        void main() {
                            vPosition = position;
                            float expansion = time * 20.0;
                            vec3 pos = position * expansion;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float mass;
                        varying vec3 vPosition;
                        
                        void main() {
                            float dist = length(vPosition);
                            float intensity = 1.0 - smoothstep(0.0, 1.0, dist);
                            
                            // Color based on mass
                            vec3 color = mix(
                                vec3(1.0, 0.5, 0.2), // Orange for lower mass
                                vec3(1.0, 0.2, 0.8), // Pink for higher mass
                                clamp(mass / 20.0, 0.0, 1.0)
                            );
                            
                            float alpha = intensity * (1.0 - time * 0.5);
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.position.copy(position);
                this.scene.add(shockwave);
                
                // Animate shockwave
                let startTime = Date.now();
                const animateShockwave = () => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    shockwaveMaterial.uniforms.time.value = elapsed;
                    
                    if (elapsed < 2) {
                        requestAnimationFrame(animateShockwave);
                    } else {
                        this.scene.remove(shockwave);
                    }
                };
                
                animateShockwave();
            }
            
            createNeutronStar(position) {
                const neutronStar = this.createIndividualStar(position.x, position.y, position.z, 'neutronStar');
                neutronStar.userData.mass = 1.4;
                neutronStar.userData.age = 0;
                
                // Make it a pulsar
                if (Math.random() < 0.7) {
                    neutronStar.userData.isPulsar = true;
                    neutronStar.userData.pulsarPeriod = 0.1 + Math.random() * 0.9;
                    this.createPulsarBeam(neutronStar);
                }
                
                this.stars.push(neutronStar);
            }
            
            createPulsarBeam(pulsar) {
                // Create periodic beam effect
                setInterval(() => {
                    if (pulsar.userData.isPulsar) {
                        const beam = document.createElement('div');
                        beam.className = 'pulsar-beam';
                        
                        // Calculate screen position
                        const vector = pulsar.position.clone();
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        beam.style.left = (x - 50) + 'px';
                        beam.style.top = (y - 50) + 'px';
                        beam.style.width = '100px';
                        beam.style.height = '100px';
                        
                        document.getElementById('container').appendChild(beam);
                        
                        setTimeout(() => {
                            beam.remove();
                        }, 500);
                    }
                }, pulsar.userData.pulsarPeriod * 1000);
            }
            
            createBlackHoleAtPosition(position, mass) {
                const blackHole = this.createIndividualStar(position.x, position.y, position.z, 'blackHole');
                blackHole.userData.mass = mass;
                blackHole.userData.age = 0;
                blackHole.userData.isStellar = true;
                
                // Create accretion disk
                this.createAccretionDisk(position.x, position.y, position.z, 2, 6, 0xff3300, 0.6);
                
                this.blackHoles.push(blackHole);
                this.statsData.blackHoleCount++;
                this.updateStatistics();
            }
            
            createWhiteDwarf(position) {
                const whiteDwarf = this.createIndividualStar(position.x, position.y, position.z, 'whiteDwarf');
                whiteDwarf.userData.mass = 0.6;
                whiteDwarf.userData.age = 0;
                
                this.stars.push(whiteDwarf);
            }
            
            formStarCluster() {
                // Find a suitable nebula
                if (this.nebulas.length === 0) return;
                
                const nebula = this.nebulas[Math.floor(Math.random() * this.nebulas.length)];
                const position = nebula.position;
                
                const clusterSize = 20 + Math.floor(Math.random() * 31);
                const cluster = {
                    position: position.clone(),
                    stars: [],
                    age: 0,
                    radius: 8 + Math.random() * 7
                };
                
                for (let i = 0; i < clusterSize; i++) {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * cluster.radius * 2,
                        (Math.random() - 0.5) * cluster.radius,
                        (Math.random() - 0.5) * cluster.radius * 2
                    );
                    
                    const starPos = position.clone().add(offset);
                    
                    // Young cluster stars
                    const starType = Math.random() < 0.3 ? 'blueGiant' : 
                                   Math.random() < 0.6 ? 'sunLike' : 
                                   Math.random() < 0.8 ? 'orangeDwarf' : 'redDwarf';
                    
                    const star = this.createIndividualStar(starPos.x, starPos.y, starPos.z, starType);
                    star.userData.age = Math.random() * 100;
                    star.userData.isCluster = true;
                    star.userData.clusterId = this.statsData.clusterCount;
                    
                    cluster.stars.push(star);
                }
                
                this.starClusters.push(cluster);
                this.statsData.clusterCount++;
                this.statsData.starFormationCount += clusterSize;
                this.updateStatistics();
                
                this.showNotification(`New star cluster formed with ${clusterSize} stars`, 3000, 'success');
            }
            
            simulateGalaxyCollision() {
                this.showNotification('Initiating galaxy collision simulation...', 4000, 'warning');
                
                // Create a dwarf galaxy
                const dwarfGalaxy = {
                    position: new THREE.Vector3(-400, 100, -400),
                    velocity: new THREE.Vector3(1, -0.2, 1),
                    stars: [],
                    darkMatter: null,
                    size: 60
                };
                
                // Create dwarf galaxy stars
                const dwarfStars = 800;
                for (let i = 0; i < dwarfStars; i++) {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * dwarfGalaxy.size * 2,
                        (Math.random() - 0.5) * dwarfGalaxy.size * 0.5,
                        (Math.random() - 0.5) * dwarfGalaxy.size * 2
                    );
                    
                    const position = dwarfGalaxy.position.clone().add(offset);
                    
                    // Dwarf galaxy has older, metal-poor stars
                    const starType = Math.random() < 0.9 ? 'redDwarf' : 
                                   Math.random() < 0.98 ? 'orangeDwarf' : 'whiteDwarf';
                    
                    const star = this.createIndividualStar(position.x, position.y, position.z, starType);
                    star.userData.isDwarfGalaxy = true;
                    star.userData.dwarfOffset = offset.clone();
                    star.userData.age = 12000 + Math.random() * 3000;
                    
                    dwarfGalaxy.stars.push(star);
                }
                
                // Create dark matter halo for dwarf galaxy
                const dwarfDarkMatter = new THREE.Mesh(
                    new THREE.SphereGeometry(dwarfGalaxy.size * 2, 32, 32),
                    new THREE.MeshBasicMaterial({
                        color: 0x220044,
                        transparent: true,
                        opacity: 0.02,
                        wireframe: true
                    })
                );
                dwarfDarkMatter.position.copy(dwarfGalaxy.position);
                dwarfGalaxy.darkMatter = dwarfDarkMatter;
                this.scene.add(dwarfDarkMatter);
                
                // Animate collision
                const animateCollision = () => {
                    // Update position
                    dwarfGalaxy.position.add(dwarfGalaxy.velocity);
                    dwarfDarkMatter.position.copy(dwarfGalaxy.position);
                    
                    // Update stars
                    dwarfGalaxy.stars.forEach(star => {
                        const newPos = dwarfGalaxy.position.clone().add(star.userData.dwarfOffset);
                        star.position.copy(newPos);
                        
                        // Add tidal effects
                        const distanceToCenter = newPos.length();
                        const tidalForce = 1 / (distanceToCenter * distanceToCenter);
                        
                        star.position.x += (Math.random() - 0.5) * tidalForce * 2;
                        star.position.y += (Math.random() - 0.5) * tidalForce;
                        star.position.z += (Math.random() - 0.5) * tidalForce * 2;
                    });
                    
                    // Check if collision is ongoing
                    if (dwarfGalaxy.position.length() < 150) {
                        // Merge with main galaxy
                        dwarfGalaxy.stars.forEach(star => {
                            star.userData.isDwarfGalaxy = false;
                            star.userData.isHalo = true;
                        });
                        
                        this.scene.remove(dwarfDarkMatter);
                        this.showNotification('Galaxy collision complete - dwarf galaxy merged', 5000, 'success');
                    } else {
                        requestAnimationFrame(animateCollision);
                    }
                };
                
                animateCollision();
            }
            
            changeViewMode(mode) {
                switch(mode) {
                    case 'free':
                        this.controls.enabled = true;
                        this.followingObject = null;
                        break;
                    case 'top':
                        this.camera.position.set(0, 400, 0);
                        this.camera.lookAt(0, 0, 0);
                        this.controls.target.set(0, 0, 0);
                        this.controls.update();
                        break;
                    case 'side':
                        this.camera.position.set(400, 0, 0);
                        this.camera.lookAt(0, 0, 0);
                        this.controls.target.set(0, 0, 0);
                        this.controls.update();
                        break;
                    case 'core':
                        this.camera.position.set(0, 50, 80);
                        this.camera.lookAt(0, 0, 0);
                        this.controls.target.set(0, 0, 0);
                        this.controls.update();
                        break;
                    case 'arm':
                        const radius = 120;
                        const angle = Math.PI / 3;
                        this.camera.position.set(
                            Math.cos(angle) * radius + 30,
                            20,
                            Math.sin(angle) * radius + 30
                        );
                        this.camera.lookAt(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                        this.controls.target.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                        this.controls.update();
                        break;
                    case 'orbit':
                        this.camera.position.set(0, 100, 300);
                        this.camera.lookAt(0, 0, 0);
                        this.controls.target.set(0, 0, 0);
                        this.controls.update();
                        break;
                }
            }
            
            updateCameraDistance(distance) {
                const direction = this.camera.position.clone().normalize();
                this.camera.position.copy(direction.multiplyScalar(distance));
                this.controls.update();
            }
            
            toggleFollowMode() {
                if (this.selectedObject) {
                    this.followingObject = this.followingObject ? null : this.selectedObject;
                    this.showNotification(
                        this.followingObject ? 'Following selected object' : 'Stopped following',
                        2000
                    );
                } else {
                    this.showNotification('Select an object to follow', 2000, 'warning');
                }
            }
            
            toggleImmersionMode() {
                this.immersionMode = !this.immersionMode;
                
                if (this.immersionMode) {
                    document.getElementById('ui-panels').style.opacity = '0';
                    document.getElementById('minimap').style.opacity = '0';
                    this.showNotification('Immersive Mode Enabled\nPress I to exit', 3000);
                } else {
                    document.getElementById('ui-panels').style.opacity = '1';
                    document.getElementById('minimap').style.opacity = '1';
                }
            }
            
            toggleUI() {
                this.uiVisible = !this.uiVisible;
                document.getElementById('ui-panels').style.display = this.uiVisible ? 'block' : 'none';
                this.showNotification(this.uiVisible ? 'UI Shown' : 'UI Hidden', 2000);
            }
            
            toggleStats() {
                const stats = this.stats.domElement;
                stats.style.display = stats.style.display === 'none' ? 'block' : 'none';
            }
            
            saveSimulationState() {
                const state = {
                    simulationTime: this.simulationTime,
                    stats: this.statsData,
                    camera: {
                        position: this.camera.position.toArray(),
                        rotation: this.camera.rotation.toArray()
                    },
                    settings: this.settings
                };
                
                localStorage.setItem('galaxy_simulation_state', JSON.stringify(state));
                this.showNotification('Simulation state saved', 2000, 'success');
            }
            
            loadSimulationState() {
                const saved = localStorage.getItem('galaxy_simulation_state');
                if (saved) {
                    const state = JSON.parse(saved);
                    // Load state...
                    this.showNotification('Simulation state loaded', 2000, 'success');
                }
            }
            
            updateSetting(setting, value) {
                // Update settings based on UI controls
                const parts = setting.split('_');
                let current = this.settings;
                
                for (let i = 0; i < parts.length - 1; i++) {
                    current = current[parts[i]];
                }
                
                current[parts[parts.length - 1]] = value;
                
                // Apply setting changes
                this.applySettings();
            }
            
            applySettings() {
                // Apply graphics settings
                if (this.bloomPass) {
                    this.bloomPass.enabled = this.settings.graphics.bloom;
                    this.bloomPass.strength = this.settings.graphics.bloomStrength;
                    this.bloomPass.radius = this.settings.graphics.bloomRadius;
                    this.bloomPass.threshold = this.settings.graphics.bloomThreshold;
                }
                
                // Apply physics settings
                // This would control simulation parameters
            }
            
            showHelp() {
                const helpText = `
                <h3>Spiral Galaxy Simulation Controls</h3>
                <br><strong>Mouse:</strong>
                <br>â€¢ Left Click: Select objects
                <br>â€¢ Right Click: Context menu
                <br>â€¢ Drag: Rotate view
                <br>â€¢ Scroll: Zoom in/out
                <br>â€¢ Right Drag: Pan view
                
                <br><br><strong>Keyboard Shortcuts:</strong>
                <br>â€¢ Space: Trigger supernova
                <br>â€¢ C: Form star cluster
                <br>â€¢ B: Create black hole
                <br>â€¢ R: Reset view
                <br>â€¢ F: Follow selected object
                <br>â€¢ I: Toggle immersive mode
                <br>â€¢ U: Toggle UI visibility
                <br>â€¢ H: Show this help
                <br>â€¢ S: Toggle statistics
                <br>â€¢ P: Pause/Resume simulation
                <br>â€¢ Escape: Deselect object
                
                <br><br><strong>Features:</strong>
                <br>â€¢ 20,000+ stars with astrophysical accuracy
                <br>â€¢ 6 spiral arms with density waves
                <br>â€¢ Stellar evolution and supernovae
                <br>â€¢ Black holes and neutron stars
                <br>â€¢ Nebulas and star formation
                <br>â€¢ Galactic collisions
                <br>â€¢ Advanced post-processing effects
                `;
                
                this.showNotification(helpText, 15000);
            }
            
            showNotification(message, duration = 3000, type = 'info') {
                const overlay = document.getElementById('notification-overlay');
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.innerHTML = message;
                
                overlay.appendChild(notification);
                
                // Show with animation
                setTimeout(() => {
                    notification.classList.add('show');
                }, 10);
                
                // Hide after duration
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 500);
                }, duration);
            }
            
            updateStatistics() {
                // Update UI with current statistics
                document.getElementById('total-stars').textContent = this.statsData.totalStars.toLocaleString();
                document.getElementById('hud-stars').textContent = this.statsData.totalStars.toLocaleString();
                document.getElementById('hud-supernovae').textContent = this.statsData.supernovaCount;
                document.getElementById('hud-blackholes').textContent = this.statsData.blackHoleCount;
                document.getElementById('hud-clusters').textContent = this.statsData.clusterCount;
                
                // Update galaxy info
                document.getElementById('galaxy-mass').textContent = (this.galaxyParams.mass / 1e12).toFixed(1) + 'T Mâ˜‰';
                document.getElementById('galaxy-diameter').textContent = (this.galaxyParams.diameter / 1000).toFixed(0) + 'k ly';
                document.getElementById('spiral-arms').textContent = '6';
            }
            
            updateTimeDisplay() {
                document.getElementById('current-time').textContent = this.simulationTime.toFixed(1) + ' Myr';
                
                // Update time progress
                const progress = (this.simulationTime % 1000) / 10;
                document.getElementById('time-progress').style.width = `${progress}%`;
                document.getElementById('time-scale').textContent = this.timeScale.toFixed(1) + 'x';
            }
            
            updateFPS() {
                this.frameCount++;
                const now = performance.now();
                
                if (now >= this.lastFPSUpdate + 1000) {
                    this.statsData.fps = Math.round((this.frameCount * 1000) / (now - this.lastFPSUpdate));
                    this.lastFPSUpdate = now;
                    this.frameCount = 0;
                    
                    document.getElementById('hud-fps').textContent = this.statsData.fps;
                }
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                if (!this.isPaused) {
                    // Update simulation time
                    this.simulationTime += 0.1 * this.timeScale;
                    this.updateTimeDisplay();
                    
                    // Update galaxy rotation
                    this.scene.rotation.y += this.rotationSpeed * this.timeScale;
                    
                    // Update post-processing effects
                    if (this.composer) {
                        this.composer.render();
                    } else {
                        this.renderer.render(this.scene, this.camera);
                    }
                    
                    // Update controls
                    this.controls.update();
                    
                    // Follow selected object
                    if (this.followingObject) {
                        const targetPosition = this.followingObject.position.clone();
                        const cameraPosition = targetPosition.clone().add(new THREE.Vector3(0, 10, 20));
                        
                        this.camera.position.lerp(cameraPosition, 0.05);
                        this.camera.lookAt(targetPosition);
                    }
                    
                    // Update FPS counter
                    this.updateFPS();
                }
                
                // Update stats
                this.stats.update();
            }
            
            // Additional utility methods...
            handleSupernova(event) {
                // Handle supernova event
            }
            
            handleStarFormation(event) {
                // Handle star formation event
            }
            
            handleBlackHoleFormation(event) {
                // Handle black hole formation event
            }
            
            handleGalaxyCollision(event) {
                // Handle galaxy collision event
            }
            
            resetView() {
                this.camera.position.set(0, 150, 250);
                this.camera.lookAt(0, 0, 0);
                this.controls.target.set(0, 0, 0);
                this.controls.update();
                this.followingObject = null;
                document.getElementById('view-mode').value = 'core';
            }
        }
        
        // Initialize the simulation when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            const simulation = new UltimateGalaxySimulation();
            
            // Make simulation available globally for debugging
            window.galaxySimulation = simulation;
        });
    </script>
</body>
</html>