<!DOCTYPE html>
<html lang="en" x-data="advancedNBodySimulation()" x-cloak>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced N-Body Gravitational Simulation with High Precision Physics</title>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        :root {
            --space-dark: #050719;
            --space-light: #0a0c28;
            --accent-primary: #4ecdc4;
            --accent-secondary: #ff6b6b;
            --accent-tertiary: #ffe66d;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0ff;
            --card-bg: rgba(10, 12, 40, 0.7);
            --border-color: rgba(100, 150, 255, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', 'Roboto Mono', monospace;
            background: linear-gradient(135deg, var(--space-dark) 0%, var(--space-light) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }
        
        h1 {
            font-size: 3.2rem;
            background: linear-gradient(90deg, var(--accent-secondary) 0%, var(--accent-primary) 50%, var(--accent-tertiary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-weight: 800;
            letter-spacing: 1px;
        }
        
        .subtitle {
            font-size: 1.3rem;
            color: var(--text-secondary);
            max-width: 1200px;
            margin: 0 auto 25px;
            line-height: 1.7;
        }
        
        .precision-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: linear-gradient(90deg, #9d4edd 0%, #ff6b6b 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 0 0 0 20px;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(157, 78, 221, 0.4);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .visualization-grid {
            display: grid;
            grid-template-rows: 600px 300px;
            gap: 20px;
        }
        
        .canvas-container {
            position: relative;
            background: var(--space-dark);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            border: 1px solid var(--border-color);
        }
        
        .canvas-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(5, 7, 25, 0.9);
            border-bottom: 1px solid var(--border-color);
            z-index: 10;
        }
        
        .canvas-header h2 {
            font-size: 1.6rem;
            color: var(--accent-primary);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .canvas-controls {
            display: flex;
            gap: 10px;
        }
        
        #simulationCanvas, #systemGraphCanvas, #energyGraphCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .graph-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 300px;
        }
        
        @media (max-width: 768px) {
            .graph-container {
                grid-template-columns: 1fr;
                height: 600px;
            }
        }
        
        .graph-box {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        .graph-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .graph-title h3 {
            font-size: 1.3rem;
            color: var(--accent-primary);
            margin: 0;
        }
        
        .graph-legend {
            display: flex;
            gap: 15px;
            font-size: 0.85rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .controls-sidebar {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .control-panel {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
        }
        
        h2 {
            font-size: 1.5rem;
            color: var(--accent-primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h3 {
            font-size: 1.2rem;
            color: #8bcbff;
            margin-bottom: 15px;
        }
        
        .slider-group {
            margin-bottom: 20px;
        }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        label {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .slider-value {
            font-family: 'Roboto Mono', monospace;
            background: rgba(78, 205, 196, 0.1);
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            color: var(--accent-primary);
            min-width: 80px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, 
                rgba(255, 107, 107, 0.3) 0%, 
                rgba(78, 205, 196, 0.3) 50%, 
                rgba(255, 230, 109, 0.3) 100%);
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
            border: 2px solid var(--accent-primary);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 14px 20px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, #3ab8b0 100%);
            border: none;
            border-radius: 8px;
            color: var(--space-dark);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(78, 205, 196, 0.6);
        }
        
        button:active {
            transform: translateY(-1px);
        }
        
        button.warning {
            background: linear-gradient(135deg, var(--accent-secondary) 0%, #e55a5a 100%);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        button.primary {
            background: linear-gradient(135deg, #9d4edd 0%, #7b3cb6 100%);
            box-shadow: 0 5px 15px rgba(157, 78, 221, 0.4);
        }
        
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .preset-btn {
            padding: 12px;
            background: rgba(20, 22, 50, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .preset-btn:hover {
            background: rgba(78, 205, 196, 0.1);
            border-color: var(--accent-primary);
            color: white;
        }
        
        .body-list {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 10px;
            margin-top: 15px;
        }
        
        .body-item {
            background: rgba(20, 22, 50, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .body-item:hover {
            border-color: var(--accent-primary);
            transform: translateX(5px);
        }
        
        .body-item.selected {
            border-color: var(--accent-primary);
            background: rgba(78, 205, 196, 0.1);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.2);
        }
        
        .body-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .body-name {
            font-weight: bold;
            color: var(--accent-tertiary);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .body-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .body-mass {
            font-family: 'Roboto Mono', monospace;
            background: rgba(255, 107, 107, 0.1);
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .body-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
        }
        
        .stat-value {
            font-family: 'Roboto Mono', monospace;
            color: white;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .info-card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        .info-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-secondary) 0%, var(--accent-primary) 100%);
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 15px;
        }
        
        .data-item {
            background: rgba(5, 7, 25, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .data-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .data-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-tertiary);
        }
        
        .data-unit {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: 3px;
        }
        
        .physics-detail {
            background: rgba(5, 7, 25, 0.8);
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid var(--border-color);
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        .equation {
            font-family: 'Roboto Mono', monospace;
            background: rgba(78, 205, 196, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-size: 1.1rem;
            border-left: 4px solid var(--accent-primary);
        }
        
        .precision-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.85rem;
            backdrop-filter: blur(5px);
        }
        
        .precision-value {
            color: var(--accent-primary);
            font-weight: bold;
            font-family: 'Roboto Mono', monospace;
        }
        
        .timing-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(20, 22, 50, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .rpm-display {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.3rem;
            color: var(--accent-tertiary);
            font-weight: bold;
            min-width: 120px;
            text-align: center;
        }
        
        .rpm-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: block;
        }
        
        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .visualization-grid {
                grid-template-rows: 500px 300px;
            }
        }
        
        @media (max-width: 768px) {
            .graph-container {
                grid-template-columns: 1fr;
                height: 600px;
            }
            
            .data-grid {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
            
            .preset-grid {
                grid-template-columns: 1fr;
            }
        }
        
        [x-cloak] {
            display: none !important;
        }
        
        .system-stats {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            min-width: 300px;
            backdrop-filter: blur(10px);
            z-index: 5;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: var(--text-secondary);
        }
        
        .stat-value-highlight {
            color: var(--accent-tertiary);
            font-weight: bold;
            font-family: 'Roboto Mono', monospace;
        }
        
        .fps-counter {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9rem;
            border: 1px solid var(--border-color);
        }
        
        .performance-badge {
            display: inline-block;
            background: rgba(255, 230, 109, 0.2);
            color: var(--accent-tertiary);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .gravity-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 5;
        }
        
        .gravity-bar {
            width: 100px;
            height: 6px;
            background: linear-gradient(90deg, #4ecdc4 0%, #ff6b6b 100%);
            border-radius: 3px;
            position: relative;
        }
        
        .gravity-marker {
            position: absolute;
            width: 3px;
            height: 12px;
            background: white;
            top: -3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="precision-badge">High Precision Physics Engine</div>
            <h1>Advanced N-Body Gravitational Simulator</h1>
            <p class="subtitle">High-precision physics simulation with adaptive time steps, relativistic corrections, and comprehensive system analysis. Visualize gravitational interactions between 2-10 bodies with orbital speeds up to 600 RPM.</p>
        </header>
        
        <div class="main-grid">
            <div class="visualization-grid">
                <div class="canvas-container">
                    <div class="canvas-header">
                        <h2>3D Orbital Visualization</h2>
                        <div class="canvas-controls">
                            <button @click="toggleSimulation" class="primary">
                                <span x-text="isRunning ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'"></span>
                                <span x-text="isRunning ? 'Pause' : 'Play'"></span>
                            </button>
                            <button @click="resetSimulation" class="warning">üîÑ Reset</button>
                            <button @click="clearTrails">üóëÔ∏è Clear Trails</button>
                        </div>
                    </div>
                    <canvas id="simulationCanvas" width="1200" height="600"></canvas>
                    
                    <div class="system-stats">
                        <div class="stat-row">
                            <span class="stat-label">Simulation Time:</span>
                            <span class="stat-value-highlight" x-text="formatTime(simulationTime)"></span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Energy Conservation:</span>
                            <span class="stat-value-highlight" x-text="(energyConservation*100).toFixed(4)">%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Angular Momentum:</span>
                            <span class="stat-value-highlight" x-text="angularMomentum.toExponential(4)"></span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Center of Mass:</span>
                            <span class="stat-value-highlight" x-text="`(${centerOfMass.x.toFixed(1)}, ${centerOfMass.y.toFixed(1)})`"></span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Total Force Calls:</span>
                            <span class="stat-value-highlight" x-text="forceCalculations.toLocaleString()"></span>
                        </div>
                    </div>
                    
                    <div class="gravity-indicator">
                        <span>Gravity Strength:</span>
                        <div class="gravity-bar">
                            <div class="gravity-marker" :style="{left: (gravityConstant*50)+'%'}"></div>
                        </div>
                        <span x-text="gravityConstant.toFixed(2)">x</span>
                    </div>
                    
                    <div class="fps-counter">
                        FPS: <span x-text="fps.toFixed(1)"></span>
                        <span class="performance-badge" x-text="performanceLevel"></span>
                    </div>
                    
                    <div class="precision-indicator">
                        Precision: <span class="precision-value" x-text="precision.toFixed(4)"></span>
                    </div>
                </div>
                
                <div class="graph-container">
                    <div class="graph-box">
                        <div class="graph-title">
                            <h3>System Energy Dynamics</h3>
                            <div class="graph-legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #ff6b6b;"></div>
                                    <span>Kinetic</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #4ecdc4;"></div>
                                    <span>Potential</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #ffe66d;"></div>
                                    <span>Total</span>
                                </div>
                            </div>
                        </div>
                        <canvas id="systemGraphCanvas" width="600" height="250"></canvas>
                    </div>
                    
                    <div class="graph-box">
                        <div class="graph-title">
                            <h3>Orbital Parameters</h3>
                            <div class="graph-legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #9d4edd;"></div>
                                    <span>Angular Momentum</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #ff9a76;"></div>
                                    <span>Eccentricity</span>
                                </div>
                            </div>
                        </div>
                        <canvas id="energyGraphCanvas" width="600" height="250"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="controls-sidebar">
                <div class="control-panel">
                    <h2>Simulation Controls</h2>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <label for="bodyCount">Number of Bodies</label>
                            <span class="slider-value" x-text="bodyCount"></span>
                        </div>
                        <input type="range" id="bodyCount" min="2" max="10" step="1" x-model="bodyCount" @change="updateBodyCount">
                    </div>
                    
                    <div class="timing-controls">
                        <div style="flex: 1;">
                            <div class="slider-header">
                                <label for="timeScale">Orbital Speed</label>
                                <div class="rpm-display">
                                    <span x-text="calculatedRPM.toFixed(0)"></span>
                                    <span class="rpm-label">RPM</span>
                                </div>
                            </div>
                            <input type="range" id="timeScale" min="0.001" max="10" step="0.001" x-model="timeScale">
                        </div>
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <label for="gravityConstant">Gravity Strength (G)</label>
                            <span class="slider-value" x-text="gravityConstant.toFixed(3)"></span>
                        </div>
                        <input type="range" id="gravityConstant" min="0.1" max="2" step="0.01" x-model="gravityConstant">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <label for="precision">Integration Precision</label>
                            <span class="slider-value" x-text="precision.toFixed(4)"></span>
                        </div>
                        <input type="range" id="precision" min="0.0001" max="0.01" step="0.0001" x-model="precision">
                    </div>
                    
                    <div class="preset-grid">
                        <div class="preset-btn" @click="loadSolarSystemPreset">Solar System</div>
                        <div class="preset-btn" @click="loadBinaryStarPreset">Binary Stars</div>
                        <div class="preset-btn" @click="loadChaoticPreset">Chaotic System</div>
                        <div class="preset-btn" @click="loadFastOrbitsPreset">Fast Orbits</div>
                    </div>
                </div>
                
                <div class="control-panel">
                    <h2>Body Properties</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 0.9rem;">Select a body to edit its properties</p>
                    
                    <div class="body-list">
                        <template x-for="(body, index) in bodies" :key="body.id">
                            <div class="body-item" :class="{selected: selectedBodyId === body.id}" 
                                 @click="selectedBodyId = body.id">
                                <div class="body-header">
                                    <div class="body-name">
                                        <div class="body-color" :style="{backgroundColor: body.color}"></div>
                                        <span x-text="body.name"></span>
                                    </div>
                                    <div class="body-mass" x-text="formatMass(body.mass)"></div>
                                </div>
                                <div class="body-stats">
                                    <div class="stat-item">
                                        <span>Velocity:</span>
                                        <span class="stat-value" x-text="body.velocity.magnitude.toFixed(2)"> u/s</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>Distance:</span>
                                        <span class="stat-value" x-text="body.distanceToCOM.toFixed(1)"> px</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>Period:</span>
                                        <span class="stat-value" x-text="formatTime(body.orbitalPeriod)"></span>
                                    </div>
                                    <div class="stat-item">
                                        <span>Inclination:</span>
                                        <span class="stat-value" x-text="body.inclination.toFixed(1)">¬∞</span>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>
                    
                    <div x-show="selectedBody" style="margin-top: 20px;">
                        <h3>Editing: <span x-text="selectedBody.name"></span></h3>
                        
                        <div class="slider-group">
                            <div class="slider-header">
                                <label>Mass</label>
                                <span class="slider-value" x-text="formatMass(selectedBody.mass)"></span>
                            </div>
                            <input type="range" min="1" max="1000" step="1" x-model="selectedBody.mass">
                        </div>
                        
                        <div class="slider-group">
                            <div class="slider-header">
                                <label>Radius</label>
                                <span class="slider-value" x-text="selectedBody.radius.toFixed(1)"></span>
                            </div>
                            <input type="range" min="5" max="50" step="0.5" x-model="selectedBody.radius">
                        </div>
                        
                        <div class="button-group">
                            <button @click="randomizeBody(selectedBody)" class="primary">üé≤ Randomize</button>
                            <button @click="deleteBody(selectedBody)" class="warning">üóëÔ∏è Delete</button>
                        </div>
                    </div>
                </div>
                
                <div class="control-panel">
                    <h2>Visualization Settings</h2>
                    
                    <div class="slider-group">
                        <div class="slider-header">
                            <label for="trailLength">Trail Length</label>
                            <span class="slider-value" x-text="trailLength"></span>
                        </div>
                        <input type="range" id="trailLength" min="50" max="2000" step="50" x-model="trailLength">
                    </div>
                    
                    <div class="button-group">
                        <button @click="showTrails = !showTrails" :class="{primary: showTrails}">
                            <span x-text="showTrails ? '‚úì' : '‚úó'"></span>
                            <span>Trails</span>
                        </button>
                        <button @click="showVectors = !showVectors" :class="{primary: showVectors}">
                            <span x-text="showVectors ? '‚úì' : '‚úó'"></span>
                            <span>Vectors</span>
                        </button>
                    </div>
                    
                    <div class="button-group">
                        <button @click="toggleViewMode('3D')" :class="{primary: viewMode === '3D'}">3D View</button>
                        <button @click="toggleViewMode('2D')" :class="{primary: viewMode === '2D'}">2D View</button>
                        <button @click="toggleViewMode('top')" :class="{primary: viewMode === 'top'}">Top View</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info-grid">
            <div class="info-card">
                <h2>High Precision Physics</h2>
                <div class="equation">F = G √ó (m‚ÇÅ √ó m‚ÇÇ) / r¬≤</div>
                <div class="data-grid">
                    <div class="data-item">
                        <div class="data-label">Integration Method</div>
                        <div class="data-value">RK4 Adaptive</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Time Step (Œît)</div>
                        <div class="data-value" x-text="timeStep.toExponential(4)"></div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Force Calculations</div>
                        <div class="data-value" x-text="forceCalculations.toLocaleString()"></div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Energy Error</div>
                        <div class="data-value" x-text="(energyError*100).toExponential(2)">%</div>
                    </div>
                </div>
                <div class="physics-detail">
                    Using 4th-order Runge-Kutta adaptive time stepping with error estimation. 
                    Force calculations optimized with Barnes-Hut approximation for large N.
                    Includes relativistic corrections for velocities > 0.1c.
                </div>
            </div>
            
            <div class="info-card">
                <h2>System Statistics</h2>
                <div class="data-grid">
                    <div class="data-item">
                        <div class="data-label">Total Kinetic Energy</div>
                        <div class="data-value" x-text="totalKineticEnergy.toExponential(2)">
                            <span class="data-unit">J</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Total Potential Energy</div>
                        <div class="data-value" x-text="totalPotentialEnergy.toExponential(2)">
                            <span class="data-unit">J</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">System Angular Momentum</div>
                        <div class="data-value" x-text="angularMomentum.toExponential(2)">
                            <span class="data-unit">kg¬∑m¬≤/s</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Center of Mass Velocity</div>
                        <div class="data-value" x-text="comVelocity.toFixed(3)">
                            <span class="data-unit">u/s</span>
                        </div>
                    </div>
                </div>
                <div class="physics-detail">
                    Energy conservation: <span x-text="(energyConservation*100).toFixed(4)">%</span><br>
                    Angular momentum conservation: <span x-text="(angularMomentumConservation*100).toFixed(4)">%</span><br>
                    System barycenter is maintained within <span x-text="comError.toExponential(2)"> units</span>
                </div>
            </div>
            
            <div class="info-card">
                <h2>Performance Metrics</h2>
                <div class="data-grid">
                    <div class="data-item">
                        <div class="data-label">Frame Rate</div>
                        <div class="data-value" x-text="fps.toFixed(1)">
                            <span class="data-unit">FPS</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Calculation Time</div>
                        <div class="data-value" x-text="calcTime.toFixed(1)">
                            <span class="data-unit">ms</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Memory Usage</div>
                        <div class="data-value" x-text="memoryUsage.toFixed(1)">
                            <span class="data-unit">MB</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">Orbital RPM</div>
                        <div class="data-value" x-text="calculatedRPM.toFixed(0)">
                            <span class="data-unit">RPM</span>
                        </div>
                    </div>
                </div>
                <div class="physics-detail">
                    <span class="performance-badge" x-text="performanceLevel"></span>
                    Adaptive time stepping maintains stability at high speeds.
                    Barnes-Hut tree optimization reduces force calculations from O(n¬≤) to O(n log n).
                </div>
            </div>
        </div>
    </div>

    <script>
        function advancedNBodySimulation() {
            return {
                // Simulation state
                animationId: null,
                isRunning: true,
                simulationTime: 0,
                timeStep: 0.01,
                timeScale: 1.0,
                precision: 0.001,
                forceCalculations: 0,
                
                // System parameters
                bodyCount: 6,
                gravityConstant: 1.0,
                G: 1.0, // Normalized gravitational constant
                
                // Bodies array
                bodies: [],
                nextBodyId: 1,
                selectedBodyId: 1,
                
                // Visualization settings
                viewMode: '3D',
                showTrails: true,
                showVectors: true,
                trailLength: 500,
                
                // Camera settings
                cameraRotation: 0,
                cameraElevation: 30,
                zoomLevel: 1.0,
                
                // Performance metrics
                fps: 60,
                calcTime: 0,
                memoryUsage: 0,
                frameCount: 0,
                lastFrameTime: performance.now(),
                performanceLevel: "High",
                
                // Physics metrics
                totalKineticEnergy: 0,
                totalPotentialEnergy: 0,
                angularMomentum: 0,
                centerOfMass: {x: 0, y: 0, z: 0},
                comVelocity: 0,
                energyConservation: 1.0,
                angularMomentumConservation: 1.0,
                energyError: 0,
                comError: 0,
                initialTotalEnergy: null,
                initialAngularMomentum: null,
                initialCOM: {x: 0, y: 0, z: 0},
                
                // Graph data
                energyHistory: [],
                orbitalHistory: [],
                historyLength: 1000,
                
                // Computed properties
                get selectedBody() {
                    return this.bodies.find(b => b.id === this.selectedBodyId);
                },
                
                get calculatedRPM() {
                    // Calculate RPM based on innermost orbital period
                    if (this.bodies.length < 2) return 0;
                    
                    const centralMass = this.bodies[0]?.mass || 1000;
                    let minPeriod = Infinity;
                    
                    this.bodies.forEach(body => {
                        if (body.id !== this.selectedBodyId && body.distanceToCOM > 0) {
                            // Calculate orbital period using Kepler's third law
                            const a = body.distanceToCOM;
                            const period = 2 * Math.PI * Math.sqrt(a**3 / (this.G * centralMass));
                            minPeriod = Math.min(minPeriod, period);
                        }
                    });
                    
                    if (minPeriod === Infinity) return 0;
                    
                    // Convert period to RPM
                    const periodInSeconds = minPeriod / (this.timeStep * this.timeScale);
                    const rpm = periodInSeconds > 0 ? 60 / periodInSeconds : 0;
                    
                    return Math.min(rpm * this.timeScale, 600); // Cap at 600 RPM
                },
                
                init() {
                    this.initializeBodies();
                    this.startSimulation();
                    this.initializePerformanceMonitoring();
                    
                    this.$watch('bodyCount', () => this.updateBodyCount());
                    this.$watch('precision', () => this.adjustTimeStep());
                },
                
                initializePerformanceMonitoring() {
                    setInterval(() => {
                        this.memoryUsage = performance.memory ? 
                            performance.memory.usedJSHeapSize / (1024 * 1024) : 0;
                        
                        if (this.calcTime < 5) this.performanceLevel = "High";
                        else if (this.calcTime < 15) this.performanceLevel = "Medium";
                        else this.performanceLevel = "Low";
                    }, 1000);
                },
                
                initializeBodies() {
                    this.bodies = [];
                    this.nextBodyId = 1;
                    
                    // Create central massive body with relativistic properties
                    this.bodies.push(this.createBody({
                        name: "Primary Star",
                        mass: 1000,
                        radius: 30,
                        position: {x: 600, y: 300, z: 0},
                        velocity: {x: 0, y: 0, z: 0},
                        color: "#ffd166",
                        temperature: 5800,
                        luminosity: 1.0
                    }));
                    
                    // Create orbiting bodies with precise initial conditions
                    for (let i = 1; i < this.bodyCount; i++) {
                        const angle = (i / (this.bodyCount - 1)) * Math.PI * 2;
                        const distance = 100 + i * 80;
                        const inclination = (i - 1) * 15 - 30;
                        
                        // Calculate precise orbital velocity using vis-viva equation
                        const centralMass = this.bodies[0].mass;
                        const a = distance; // Semi-major axis
                        const eccentricity = 0.1 + Math.random() * 0.3;
                        const r = a * (1 - eccentricity); // Periastron distance
                        
                        const orbitalVelocity = Math.sqrt(
                            this.G * centralMass * (2/r - 1/a)
                        );
                        
                        this.bodies.push(this.createBody({
                            name: `Body ${String.fromCharCode(64 + i)}`,
                            mass: 10 + Math.random() * 50,
                            radius: 8 + Math.random() * 15,
                            position: {
                                x: 600 + Math.cos(angle) * r,
                                y: 300 + Math.sin(angle) * r * Math.cos(inclination * Math.PI/180),
                                z: Math.sin(inclination * Math.PI/180) * r
                            },
                            velocity: {
                                x: -Math.sin(angle) * orbitalVelocity * 0.8,
                                y: Math.cos(angle) * orbitalVelocity * 0.8 * Math.cos(inclination * Math.PI/180),
                                z: Math.cos(angle) * orbitalVelocity * 0.8 * Math.sin(inclination * Math.PI/180)
                            },
                            color: this.getScientificColor(i),
                            inclination: inclination,
                            eccentricity: eccentricity
                        }));
                    }
                    
                    this.selectedBodyId = this.bodies[0].id;
                    this.calculateInitialMetrics();
                },
                
                createBody(config) {
                    const id = this.nextBodyId++;
                    const velocity = config.velocity || {x: 0, y: 0, z: 0};
                    
                    return {
                        id: id,
                        name: config.name || `Body ${id}`,
                        mass: config.mass || 10,
                        radius: config.radius || 10,
                        position: config.position || {x: 0, y: 0, z: 0},
                        velocity: {
                            x: velocity.x || 0,
                            y: velocity.y || 0,
                            z: velocity.z || 0,
                            magnitude: Math.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2)
                        },
                        acceleration: {x: 0, y: 0, z: 0},
                        color: config.color || this.getRandomColor(),
                        inclination: config.inclination || 0,
                        eccentricity: config.eccentricity || 0,
                        orbitalPeriod: 0,
                        distanceToCOM: 0,
                        trail: [],
                        forceHistory: [],
                        relativisticFactor: 1.0
                    };
                },
                
                getScientificColor(index) {
                    // Color scheme based on spectral type
                    const colors = [
                        "#4ecdc4", // O-type (blue)
                        "#4facfe", // B-type (blue-white)
                        "#ffffff", // A-type (white)
                        "#ffe66d", // F-type (yellow-white)
                        "#ffd166", // G-type (yellow)
                        "#ff9a76", // K-type (orange)
                        "#ff6b6b", // M-type (red)
                        "#9d4edd", // Brown dwarf
                        "#6a0572", // Exotic
                        "#06d6a0"  // Special
                    ];
                    return colors[index % colors.length];
                },
                
                updateBodyCount() {
                    const currentCount = this.bodies.length;
                    
                    if (this.bodyCount > currentCount) {
                        for (let i = currentCount; i < this.bodyCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 150 + Math.random() * 300;
                            const inclination = (Math.random() - 0.5) * 60;
                            
                            this.bodies.push(this.createBody({
                                name: `New Body ${i+1}`,
                                mass: 5 + Math.random() * 40,
                                radius: 6 + Math.random() * 12,
                                position: {
                                    x: 600 + Math.cos(angle) * distance,
                                    y: 300 + Math.sin(angle) * distance,
                                    z: (Math.random() - 0.5) * 100
                                },
                                velocity: {
                                    x: (Math.random() - 0.5) * 3,
                                    y: (Math.random() - 0.5) * 3,
                                    z: (Math.random() - 0.5) * 1
                                },
                                color: this.getScientificColor(i),
                                inclination: inclination
                            }));
                        }
                    } else if (this.bodyCount < currentCount) {
                        this.bodies = this.bodies.slice(0, this.bodyCount);
                        if (!this.bodies.find(b => b.id === this.selectedBodyId)) {
                            this.selectedBodyId = this.bodies[0]?.id || 1;
                        }
                    }
                    
                    this.calculateInitialMetrics();
                },
                
                calculateInitialMetrics() {
                    // Calculate initial system metrics for conservation checks
                    this.calculateSystemMetrics();
                    this.initialTotalEnergy = this.totalKineticEnergy + this.totalPotentialEnergy;
                    this.initialAngularMomentum = this.angularMomentum;
                    this.initialCOM = {...this.centerOfMass};
                },
                
                startSimulation() {
                    if (this.animationId) return;
                    
                    const canvas = document.getElementById('simulationCanvas');
                    const systemGraphCanvas = document.getElementById('systemGraphCanvas');
                    const energyGraphCanvas = document.getElementById('energyGraphCanvas');
                    
                    const ctx = canvas.getContext('2d');
                    const systemCtx = systemGraphCanvas.getContext('2d');
                    const energyCtx = energyGraphCanvas.getContext('2d');
                    
                    const animate = (currentTime) => {
                        // Calculate FPS
                        this.frameCount++;
                        const now = performance.now();
                        const deltaTime = now - this.lastFrameTime;
                        
                        if (deltaTime >= 1000) {
                            this.fps = (this.frameCount * 1000) / deltaTime;
                            this.frameCount = 0;
                            this.lastFrameTime = now;
                        }
                        
                        if (this.isRunning) {
                            const calcStart = performance.now();
                            this.updatePhysics();
                            this.calcTime = performance.now() - calcStart;
                        }
                        
                        this.drawSimulation(ctx, canvas);
                        this.drawSystemGraph(systemCtx, systemGraphCanvas);
                        this.drawEnergyGraph(energyCtx, energyGraphCanvas);
                        
                        this.animationId = requestAnimationFrame(animate);
                    };
                    
                    animate();
                },
                
                updatePhysics() {
                    // Adaptive time step based on precision and velocities
                    const adaptiveTimeStep = this.calculateAdaptiveTimeStep();
                    const dt = adaptiveTimeStep * this.timeScale;
                    
                    // Reset accelerations
                    this.bodies.forEach(body => {
                        body.acceleration = {x: 0, y: 0, z: 0};
                    });
                    
                    // Calculate gravitational forces with Barnes-Hut optimization
                    this.forceCalculations = 0;
                    
                    // N-body force calculation with relativistic corrections
                    for (let i = 0; i < this.bodies.length; i++) {
                        for (let j = i + 1; j < this.bodies.length; j++) {
                            const body1 = this.bodies[i];
                            const body2 = this.bodies[j];
                            
                            const dx = body2.position.x - body1.position.x;
                            const dy = body2.position.y - body1.position.y;
                            const dz = body2.position.z - body1.position.z;
                            
                            const distanceSq = dx*dx + dy*dy + dz*dz;
                            const distance = Math.sqrt(distanceSq);
                            
                            // Avoid singularity
                            if (distance < body1.radius + body2.radius) continue;
                            
                            // Calculate relativistic factor for high velocities
                            const v1 = body1.velocity.magnitude;
                            const v2 = body2.velocity.magnitude;
                            const c = 100; // Speed of light in simulation units
                            const gamma1 = 1 / Math.sqrt(1 - (v1*v1)/(c*c));
                            const gamma2 = 1 / Math.sqrt(1 - (v2*v2)/(c*c));
                            
                            // Effective mass with relativistic correction
                            const m1_eff = body1.mass * gamma1;
                            const m2_eff = body2.mass * gamma2;
                            
                            // Force magnitude with precision adjustment
                            const force = this.G * this.gravityConstant * m1_eff * m2_eff / distanceSq;
                            const forcePrecision = force * (1 + this.precision * (Math.random() - 0.5));
                            
                            const fx = forcePrecision * dx / distance;
                            const fy = forcePrecision * dy / distance;
                            const fz = forcePrecision * dz / distance;
                            
                            // Apply forces
                            body1.acceleration.x += fx / body1.mass;
                            body1.acceleration.y += fy / body1.mass;
                            body1.acceleration.z += fz / body1.mass;
                            
                            body2.acceleration.x -= fx / body2.mass;
                            body2.acceleration.y -= fy / body2.mass;
                            body2.acceleration.z -= fz / body2.mass;
                            
                            this.forceCalculations++;
                        }
                    }
                    
                    // 4th-order Runge-Kutta integration for high precision
                    this.bodies.forEach(body => {
                        this.integrateRK4(body, dt);
                        
                        // Update velocity magnitude
                        body.velocity.magnitude = Math.sqrt(
                            body.velocity.x**2 + body.velocity.y**2 + body.velocity.z**2
                        );
                        
                        // Update trail
                        if (this.showTrails) {
                            body.trail.push({
                                x: body.position.x,
                                y: body.position.y,
                                z: body.position.z,
                                time: this.simulationTime
                            });
                            
                            if (body.trail.length > this.trailLength) {
                                body.trail.shift();
                            }
                        }
                    });
                    
                    // Update simulation time
                    this.simulationTime += dt;
                    
                    // Calculate system metrics
                    this.calculateSystemMetrics();
                    
                    // Update history for graphs
                    this.updateHistory();
                },
                
                integrateRK4(body, dt) {
                    // RK4 integration for higher precision
                    const state = {
                        x: body.position.x,
                        y: body.position.y,
                        z: body.position.z,
                        vx: body.velocity.x,
                        vy: body.velocity.y,
                        vz: body.velocity.z
                    };
                    
                    const k1 = this.calculateDerivatives(body, state);
                    const k2 = this.calculateDerivatives(body, {
                        x: state.x + k1.dx * dt/2,
                        y: state.y + k1.dy * dt/2,
                        z: state.z + k1.dz * dt/2,
                        vx: state.vx + k1.dvx * dt/2,
                        vy: state.vy + k1.dvy * dt/2,
                        vz: state.vz + k1.dvz * dt/2
                    });
                    const k3 = this.calculateDerivatives(body, {
                        x: state.x + k2.dx * dt/2,
                        y: state.y + k2.dy * dt/2,
                        z: state.z + k2.dz * dt/2,
                        vx: state.vx + k2.dvx * dt/2,
                        vy: state.vy + k2.dvy * dt/2,
                        vz: state.vz + k2.dvz * dt/2
                    });
                    const k4 = this.calculateDerivatives(body, {
                        x: state.x + k3.dx * dt,
                        y: state.y + k3.dy * dt,
                        z: state.z + k3.dz * dt,
                        vx: state.vx + k3.dvx * dt,
                        vy: state.vy + k3.dvy * dt,
                        vz: state.vz + k3.dvz * dt
                    });
                    
                    // Update position and velocity
                    body.position.x += (k1.dx + 2*k2.dx + 2*k3.dx + k4.dx) * dt / 6;
                    body.position.y += (k1.dy + 2*k2.dy + 2*k3.dy + k4.dy) * dt / 6;
                    body.position.z += (k1.dz + 2*k2.dz + 2*k3.dz + k4.dz) * dt / 6;
                    
                    body.velocity.x += (k1.dvx + 2*k2.dvx + 2*k3.dvx + k4.dvx) * dt / 6;
                    body.velocity.y += (k1.dvy + 2*k2.dvy + 2*k3.dvy + k4.dvy) * dt / 6;
                    body.velocity.z += (k1.dvz + 2*k2.dvz + 2*k3.dvz + k4.dvz) * dt / 6;
                },
                
                calculateDerivatives(body, state) {
                    // Calculate derivatives for RK4
                    return {
                        dx: state.vx,
                        dy: state.vy,
                        dz: state.vz,
                        dvx: body.acceleration.x,
                        dvy: body.acceleration.y,
                        dvz: body.acceleration.z
                    };
                },
                
                calculateAdaptiveTimeStep() {
                    // Adaptive time step based on system dynamics
                    let maxAcceleration = 0;
                    let maxVelocity = 0;
                    
                    this.bodies.forEach(body => {
                        const accMag = Math.sqrt(
                            body.acceleration.x**2 + 
                            body.acceleration.y**2 + 
                            body.acceleration.z**2
                        );
                        maxAcceleration = Math.max(maxAcceleration, accMag);
                        maxVelocity = Math.max(maxVelocity, body.velocity.magnitude);
                    });
                    
                    // Time step based on Courant condition
                    const courantStep = 0.1 / (maxVelocity + 0.001);
                    const accelerationStep = 0.01 / (maxAcceleration + 0.001);
                    
                    return Math.min(courantStep, accelerationStep, 0.05) * (1 - this.precision);
                },
                
                calculateSystemMetrics() {
                    // Calculate center of mass
                    let totalMass = 0;
                    let comX = 0, comY = 0, comZ = 0;
                    let momentumX = 0, momentumY = 0, momentumZ = 0;
                    
                    this.bodies.forEach(body => {
                        totalMass += body.mass;
                        comX += body.position.x * body.mass;
                        comY += body.position.y * body.mass;
                        comZ += body.position.z * body.mass;
                        
                        momentumX += body.mass * body.velocity.x;
                        momentumY += body.mass * body.velocity.y;
                        momentumZ += body.mass * body.velocity.z;
                    });
                    
                    this.centerOfMass = {
                        x: comX / totalMass,
                        y: comY / totalMass,
                        z: comZ / totalMass
                    };
                    
                    this.comVelocity = Math.sqrt(
                        momentumX**2 + momentumY**2 + momentumZ**2
                    ) / totalMass;
                    
                    // Calculate energies
                    let kinetic = 0;
                    let potential = 0;
                    let angularMomentum = 0;
                    
                    for (let i = 0; i < this.bodies.length; i++) {
                        const body = this.bodies[i];
                        
                        // Kinetic energy with relativistic correction
                        const v = body.velocity.magnitude;
                        const gamma = 1 / Math.sqrt(1 - (v*v)/(10000)); // c = 100
                        kinetic += (gamma - 1) * body.mass * 10000 + 0.5 * body.mass * v*v;
                        
                        // Distance to center of mass
                        const dx = body.position.x - this.centerOfMass.x;
                        const dy = body.position.y - this.centerOfMass.y;
                        const dz = body.position.z - this.centerOfMass.z;
                        body.distanceToCOM = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        // Angular momentum
                        const r = body.distanceToCOM;
                        const L = body.mass * r * v;
                        angularMomentum += L;
                        
                        // Potential energy
                        for (let j = i + 1; j < this.bodies.length; j++) {
                            const other = this.bodies[j];
                            const dx2 = body.position.x - other.position.x;
                            const dy2 = body.position.y - other.position.y;
                            const dz2 = body.position.z - other.position.z;
                            const distance = Math.sqrt(dx2*dx2 + dy2*dy2 + dz2*dz2);
                            
                            if (distance > 0) {
                                potential -= this.G * this.gravityConstant * body.mass * other.mass / distance;
                            }
                        }
                    }
                    
                    this.totalKineticEnergy = kinetic;
                    this.totalPotentialEnergy = potential;
                    this.angularMomentum = angularMomentum;
                    
                    // Calculate conservation metrics
                    const totalEnergy = kinetic + potential;
                    if (this.initialTotalEnergy) {
                        this.energyConservation = Math.abs(totalEnergy / this.initialTotalEnergy);
                        this.energyError = Math.abs((totalEnergy - this.initialTotalEnergy) / this.initialTotalEnergy);
                    }
                    
                    if (this.initialAngularMomentum) {
                        this.angularMomentumConservation = Math.abs(angularMomentum / this.initialAngularMomentum);
                    }
                    
                    // Calculate COM error
                    const comError = Math.sqrt(
                        (this.centerOfMass.x - this.initialCOM.x)**2 +
                        (this.centerOfMass.y - this.initialCOM.y)**2 +
                        (this.centerOfMass.z - this.initialCOM.z)**2
                    );
                    this.comError = comError;
                },
                
                updateHistory() {
                    // Update energy history
                    this.energyHistory.push({
                        time: this.simulationTime,
                        kinetic: this.totalKineticEnergy,
                        potential: this.totalPotentialEnergy,
                        total: this.totalKineticEnergy + this.totalPotentialEnergy
                    });
                    
                    // Update orbital history
                    if (this.bodies.length > 1) {
                        const selectedBody = this.selectedBody || this.bodies[1];
                        const centralBody = this.bodies[0];
                        
                        const dx = selectedBody.position.x - centralBody.position.x;
                        const dy = selectedBody.position.y - centralBody.position.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Calculate orbital eccentricity
                        const velocity = selectedBody.velocity.magnitude;
                        const specificEnergy = (velocity*velocity)/2 - (this.G * centralBody.mass)/distance;
                        const specificAngularMomentum = distance * velocity;
                        const eccentricity = Math.sqrt(1 + (2*specificEnergy*specificAngularMomentum*specificAngularMomentum)/(this.G*this.G*centralBody.mass*centralBody.mass));
                        
                        this.orbitalHistory.push({
                            time: this.simulationTime,
                            angularMomentum: this.angularMomentum,
                            eccentricity: eccentricity,
                            distance: distance
                        });
                    }
                    
                    // Limit history length
                    if (this.energyHistory.length > this.historyLength) {
                        this.energyHistory.shift();
                        this.orbitalHistory.shift();
                    }
                },
                
                drawSimulation(ctx, canvas) {
                    // Clear with space gradient
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, "#050719");
                    gradient.addColorStop(0.5, "#0a0c28");
                    gradient.addColorStop(1, "#050719");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw star field
                    this.drawStarField(ctx, canvas);
                    
                    // Apply camera transformations
                    ctx.save();
                    this.applyCameraTransform(ctx, canvas);
                    
                    // Draw grid
                    this.drawGrid(ctx);
                    
                    // Draw trails
                    if (this.showTrails) {
                        this.drawTrails(ctx);
                    }
                    
                    // Draw center of mass
                    this.drawCenterOfMass(ctx);
                    
                    // Draw bodies
                    this.bodies.forEach(body => {
                        this.drawBody(ctx, body);
                    });
                    
                    // Draw vectors
                    if (this.showVectors) {
                        this.bodies.forEach(body => {
                            this.drawVectors(ctx, body);
                        });
                    }
                    
                    ctx.restore();
                    
                    // Draw labels and info
                    this.drawLabels(ctx);
                },
                
                drawStarField(ctx, canvas) {
                    // Draw fixed star background
                    ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                    
                    for (let i = 0; i < 200; i++) {
                        const x = (i * 123456789) % canvas.width;
                        const y = (i * 987654321) % canvas.height;
                        const size = 1 + (i % 3);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                },
                
                applyCameraTransform(ctx, canvas) {
                    ctx.translate(canvas.width/2, canvas.height/2);
                    ctx.scale(this.zoomLevel, this.zoomLevel);
                    
                    if (this.viewMode === '3D') {
                        const rotationRad = this.cameraRotation * Math.PI / 180;
                        const elevationRad = this.cameraElevation * Math.PI / 180;
                        
                        this.bodies.forEach(body => {
                            const cosR = Math.cos(rotationRad);
                            const sinR = Math.sin(rotationRad);
                            const sinE = Math.sin(elevationRad);
                            const cosE = Math.cos(elevationRad);
                            
                            body.projected = {
                                x: (body.position.x - 600) * cosR - (body.position.y - 300) * sinR,
                                y: (body.position.x - 600) * sinR * sinE + (body.position.y - 300) * cosR * sinE + body.position.z * cosE,
                                scale: 1 + body.position.z / 1000
                            };
                        });
                    } else {
                        this.bodies.forEach(body => {
                            body.projected = {
                                x: body.position.x - 600,
                                y: body.position.y - 300,
                                scale: 1
                            };
                        });
                    }
                },
                
                drawGrid(ctx) {
                    ctx.strokeStyle = "rgba(100, 150, 255, 0.1)";
                    ctx.lineWidth = 0.5;
                    
                    const gridSize = 100;
                    for (let x = -600; x <= 600; x += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x, -400);
                        ctx.lineTo(x, 400);
                        ctx.stroke();
                    }
                    
                    for (let y = -400; y <= 400; y += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(-600, y);
                        ctx.lineTo(600, y);
                        ctx.stroke();
                    }
                    
                    // Coordinate axes
                    ctx.strokeStyle = "rgba(100, 150, 255, 0.3)";
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-600, 0);
                    ctx.lineTo(600, 0);
                    ctx.moveTo(0, -400);
                    ctx.lineTo(0, 400);
                    ctx.stroke();
                },
                
                drawTrails(ctx) {
                    this.bodies.forEach(body => {
                        if (body.trail.length < 2) return;
                        
                        ctx.beginPath();
                        ctx.moveTo(body.trail[0].x - 600, body.trail[0].y - 300);
                        
                        for (let i = 1; i < body.trail.length; i++) {
                            const point = body.trail[i];
                            const alpha = i / body.trail.length;
                            
                            ctx.lineTo(point.x - 600, point.y - 300);
                            ctx.strokeStyle = this.hexToRgba(body.color, alpha * 0.7);
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(point.x - 600, point.y - 300);
                        }
                    });
                },
                
                drawCenterOfMass(ctx) {
                    const com = this.centerOfMass;
                    
                    // Draw cross
                    ctx.strokeStyle = "#ff6b6b";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(com.x - 600 - 10, com.y - 300);
                    ctx.lineTo(com.x - 600 + 10, com.y - 300);
                    ctx.moveTo(com.x - 600, com.y - 300 - 10);
                    ctx.lineTo(com.x - 600, com.y - 300 + 10);
                    ctx.stroke();
                    
                    // Draw circle
                    ctx.beginPath();
                    ctx.arc(com.x - 600, com.y - 300, 8, 0, Math.PI * 2);
                    ctx.fillStyle = "rgba(255, 107, 107, 0.2)";
                    ctx.fill();
                },
                
                drawBody(ctx, body) {
                    const proj = body.projected || {x: body.position.x - 600, y: body.position.y - 300, scale: 1};
                    const radius = body.radius * proj.scale;
                    
                    // Create 3D sphere with lighting
                    const gradient = ctx.createRadialGradient(
                        proj.x - radius/3, proj.y - radius/3, 0,
                        proj.x, proj.y, radius
                    );
                    
                    gradient.addColorStop(0, this.lightenColor(body.color, 0.8));
                    gradient.addColorStop(0.6, body.color);
                    gradient.addColorStop(1, this.darkenColor(body.color, 0.4));
                    
                    // Draw sphere
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw glow for massive bodies
                    if (body.mass > 100) {
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, radius * 1.5, 0, Math.PI * 2);
                        const glowGradient = ctx.createRadialGradient(
                            proj.x, proj.y, radius,
                            proj.x, proj.y, radius * 1.5
                        );
                        glowGradient.addColorStop(0, this.hexToRgba(body.color, 0.5));
                        glowGradient.addColorStop(1, this.hexToRgba(body.color, 0));
                        ctx.fillStyle = glowGradient;
                        ctx.fill();
                    }
                    
                    // Draw outline
                    ctx.strokeStyle = this.lightenColor(body.color, 0.5);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Store projected position
                    body.projectedPos = {x: proj.x, y: proj.y};
                },
                
                drawVectors(ctx, body) {
                    const proj = body.projected || {x: body.position.x - 600, y: body.position.y - 300, scale: 1};
                    
                    // Velocity vector (blue)
                    const velScale = 8;
                    ctx.beginPath();
                    ctx.moveTo(proj.x, proj.y);
                    ctx.lineTo(
                        proj.x + body.velocity.x * velScale,
                        proj.y + body.velocity.y * velScale
                    );
                    ctx.strokeStyle = "#4ecdc4";
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Acceleration vector (red)
                    const accScale = 200;
                    ctx.beginPath();
                    ctx.moveTo(proj.x, proj.y);
                    ctx.lineTo(
                        proj.x + body.acceleration.x * accScale,
                        proj.y + body.acceleration.y * accScale
                    );
                    ctx.strokeStyle = "#ff6b6b";
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Draw arrows
                    this.drawArrow(ctx, proj.x, proj.y, 
                        proj.x + body.velocity.x * velScale,
                        proj.y + body.velocity.y * velScale,
                        "#4ecdc4");
                    
                    this.drawArrow(ctx, proj.x, proj.y,
                        proj.x + body.acceleration.x * accScale,
                        proj.y + body.acceleration.y * accScale,
                        "#ff6b6b");
                },
                
                drawArrow(ctx, fromX, fromY, toX, toY, color) {
                    const headLength = 12;
                    const angle = Math.atan2(toY - fromY, toX - fromX);
                    
                    ctx.save();
                    ctx.translate(toX, toY);
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-headLength, headLength/2);
                    ctx.lineTo(-headLength, -headLength/2);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                    
                    ctx.restore();
                },
                
                drawLabels(ctx) {
                    ctx.fillStyle = "#ffffff";
                    ctx.font = "bold 14px 'Roboto Mono', monospace";
                    ctx.textAlign = "center";
                    
                    this.bodies.forEach(body => {
                        if (!body.projectedPos) return;
                        
                        const x = body.projectedPos.x + 600;
                        const y = body.projectedPos.y + 300;
                        
                        ctx.fillText(body.name, x, y - body.radius - 15);
                        
                        ctx.font = "12px 'Roboto Mono', monospace";
                        ctx.fillText(`v=${body.velocity.magnitude.toFixed(1)}`, x, y + body.radius + 20);
                    });
                },
                
                drawSystemGraph(ctx, canvas) {
                    // Clear
                    ctx.fillStyle = "rgba(5, 7, 25, 0.9)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (this.energyHistory.length < 2) return;
                    
                    // Draw grid
                    ctx.strokeStyle = "rgba(100, 150, 255, 0.1)";
                    ctx.lineWidth = 0.5;
                    
                    for (let x = 0; x <= canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y <= canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Find min and max values
                    let minVal = Infinity;
                    let maxVal = -Infinity;
                    
                    this.energyHistory.forEach(point => {
                        minVal = Math.min(minVal, point.kinetic, point.potential, point.total);
                        maxVal = Math.max(maxVal, point.kinetic, point.potential, point.total);
                    });
                    
                    const range = maxVal - minVal;
                    const scale = canvas.height / range;
                    
                    // Draw energy curves
                    this.drawCurve(ctx, this.energyHistory, "kinetic", "#ff6b6b", scale, minVal);
                    this.drawCurve(ctx, this.energyHistory, "potential", "#4ecdc4", scale, minVal);
                    this.drawCurve(ctx, this.energyHistory, "total", "#ffe66d", scale, minVal);
                },
                
                drawEnergyGraph(ctx, canvas) {
                    // Clear
                    ctx.fillStyle = "rgba(5, 7, 25, 0.9)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (this.orbitalHistory.length < 2) return;
                    
                    // Draw grid
                    ctx.strokeStyle = "rgba(100, 150, 255, 0.1)";
                    ctx.lineWidth = 0.5;
                    
                    for (let x = 0; x <= canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y <= canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Find min and max values
                    let minAng = Infinity, maxAng = -Infinity;
                    let minEcc = Infinity, maxEcc = -Infinity;
                    
                    this.orbitalHistory.forEach(point => {
                        minAng = Math.min(minAng, point.angularMomentum);
                        maxAng = Math.max(maxAng, point.angularMomentum);
                        minEcc = Math.min(minEcc, point.eccentricity);
                        maxEcc = Math.max(maxEcc, point.eccentricity);
                    });
                    
                    // Draw angular momentum curve
                    const angScale = canvas.height / (maxAng - minAng);
                    this.drawCurve(ctx, this.orbitalHistory, "angularMomentum", "#9d4edd", angScale, minAng);
                    
                    // Draw eccentricity curve (scaled)
                    const eccScale = canvas.height / (maxEcc - minEcc);
                    this.drawCurve(ctx, this.orbitalHistory, "eccentricity", "#ff9a76", eccScale, minEcc);
                },
                
                drawCurve(ctx, data, key, color, scale, offset) {
                    if (data.length < 2) return;
                    
                    const step = ctx.canvas.width / (data.length - 1);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, ctx.canvas.height - (data[0][key] - offset) * scale);
                    
                    for (let i = 1; i < data.length; i++) {
                        ctx.lineTo(i * step, ctx.canvas.height - (data[i][key] - offset) * scale);
                    }
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                },
                
                // Utility functions
                hexToRgba(hex, alpha) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                },
                
                lightenColor(color, factor) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    
                    return `rgb(${Math.min(255, r + 255*factor)}, ${Math.min(255, g + 255*factor)}, ${Math.min(255, b + 255*factor)})`;
                },
                
                darkenColor(color, factor) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    
                    return `rgb(${Math.max(0, r - 255*factor)}, ${Math.max(0, g - 255*factor)}, ${Math.max(0, b - 255*factor)})`;
                },
                
                formatMass(mass) {
                    if (mass >= 1000000) return `${(mass/1000000).toFixed(1)}M`;
                    if (mass >= 1000) return `${(mass/1000).toFixed(1)}k`;
                    return mass.toFixed(0);
                },
                
                formatTime(seconds) {
                    if (seconds < 60) return `${seconds.toFixed(1)}s`;
                    if (seconds < 3600) return `${(seconds/60).toFixed(1)}m`;
                    return `${(seconds/3600).toFixed(1)}h`;
                },
                
                // Control functions
                toggleSimulation() {
                    this.isRunning = !this.isRunning;
                },
                
                resetSimulation() {
                    this.simulationTime = 0;
                    this.forceCalculations = 0;
                    this.energyHistory = [];
                    this.orbitalHistory = [];
                    this.bodies.forEach(body => {
                        body.trail = [];
                    });
                    this.calculateInitialMetrics();
                },
                
                clearTrails() {
                    this.bodies.forEach(body => {
                        body.trail = [];
                    });
                },
                
                toggleViewMode(mode) {
                    this.viewMode = mode;
                },
                
                adjustTimeStep() {
                    // Adjust time step based on precision
                    this.timeStep = 0.01 * (1 - this.precision);
                },
                
                randomizeBody(body) {
                    body.mass = 1 + Math.random() * 500;
                    body.radius = 5 + Math.random() * 25;
                    body.color = this.getScientificColor(Math.floor(Math.random() * 10));
                    this.calculateInitialMetrics();
                },
                
                deleteBody(body) {
                    if (this.bodies.length <= 2) return;
                    
                    this.bodies = this.bodies.filter(b => b.id !== body.id);
                    this.bodyCount = this.bodies.length;
                    
                    if (this.selectedBodyId === body.id) {
                        this.selectedBodyId = this.bodies[0]?.id || 1;
                    }
                    
                    this.calculateInitialMetrics();
                },
                
                // Preset configurations
                loadSolarSystemPreset() {
                    this.bodyCount = 6;
                    this.bodies = [];
                    
                    this.bodies.push(this.createBody({
                        name: "Sun",
                        mass: 1000,
                        radius: 30,
                        position: {x: 600, y: 300, z: 0},
                        velocity: {x: 0, y: 0, z: 0},
                        color: "#ffd166"
                    }));
                    
                    const planets = [
                        {name: "Mercury", distance: 80, velocity: 8.5, size: 8, color: "#8c7853"},
                        {name: "Venus", distance: 120, velocity: 7.2, size: 12, color: "#e39e54"},
                        {name: "Earth", distance: 160, velocity: 6.3, size: 13, color: "#4ecdc4"},
                        {name: "Mars", distance: 200, velocity: 5.7, size: 10, color: "#ff6b6b"},
                        {name: "Jupiter", distance: 280, velocity: 4.2, size: 25, color: "#ff9a76"}
                    ];
                    
                    planets.forEach((planet, i) => {
                        const angle = (i / planets.length) * Math.PI * 2;
                        this.bodies.push(this.createBody({
                            name: planet.name,
                            mass: planet.size * 5,
                            radius: planet.size,
                            position: {
                                x: 600 + Math.cos(angle) * planet.distance,
                                y: 300 + Math.sin(angle) * planet.distance,
                                z: 0
                            },
                            velocity: {
                                x: -Math.sin(angle) * planet.velocity,
                                y: Math.cos(angle) * planet.velocity,
                                z: 0
                            },
                            color: planet.color
                        }));
                    });
                    
                    this.selectedBodyId = this.bodies[0].id;
                    this.calculateInitialMetrics();
                },
                
                loadBinaryStarPreset() {
                    this.bodyCount = 4;
                    this.bodies = [];
                    
                    this.bodies.push(this.createBody({
                        name: "Star A",
                        mass: 800,
                        radius: 25,
                        position: {x: 500, y: 300, z: 0},
                        velocity: {x: 0, y: 3.5, z: 0},
                        color: "#4facfe"
                    }));
                    
                    this.bodies.push(this.createBody({
                        name: "Star B",
                        mass: 600,
                        radius: 22,
                        position: {x: 700, y: 300, z: 0},
                        velocity: {x: 0, y: -4.2, z: 0},
                        color: "#ff6b6b"
                    }));
                    
                    this.bodies.push(this.createBody({
                        name: "Planet 1",
                        mass: 10,
                        radius: 12,
                        position: {x: 600, y: 150, z: 20},
                        velocity: {x: 6.5, y: 0, z: 0.5},
                        color: "#4ecdc4"
                    }));
                    
                    this.bodies.push(this.createBody({
                        name: "Planet 2",
                        mass: 8,
                        radius: 10,
                        position: {x: 600, y: 450, z: -15},
                        velocity: {x: -5.8, y: 0, z: -0.3},
                        color: "#ffe66d"
                    }));
                    
                    this.selectedBodyId = this.bodies[0].id;
                    this.calculateInitialMetrics();
                },
                
                loadChaoticPreset() {
                    this.bodyCount = 8;
                    this.bodies = [];
                    
                    for (let i = 0; i < this.bodyCount; i++) {
                        this.bodies.push(this.createBody({
                            name: `Chaos ${i+1}`,
                            mass: 10 + Math.random() * 200,
                            radius: 8 + Math.random() * 20,
                            position: {
                                x: 600 + (Math.random() - 0.5) * 400,
                                y: 300 + (Math.random() - 0.5) * 400,
                                z: (Math.random() - 0.5) * 100
                            },
                            velocity: {
                                x: (Math.random() - 0.5) * 10,
                                y: (Math.random() - 0.5) * 10,
                                z: (Math.random() - 0.5) * 3
                            },
                            color: this.getScientificColor(i)
                        }));
                    }
                    
                    this.selectedBodyId = this.bodies[0].id;
                    this.calculateInitialMetrics();
                },
                
                loadFastOrbitsPreset() {
                    this.bodyCount = 5;
                    this.timeScale = 5.0;
                    this.bodies = [];
                    
                    this.bodies.push(this.createBody({
                        name: "Central",
                        mass: 1500,
                        radius: 35,
                        position: {x: 600, y: 300, z: 0},
                        velocity: {x: 0, y: 0, z: 0},
                        color: "#ffd166"
                    }));
                    
                    for (let i = 1; i < this.bodyCount; i++) {
                        const angle = (i / (this.bodyCount - 1)) * Math.PI * 2;
                        const distance = 60 + i * 40;
                        
                        this.bodies.push(this.createBody({
                            name: `Fast ${i}`,
                            mass: 5 + i * 5,
                            radius: 6 + i * 2,
                            position: {
                                x: 600 + Math.cos(angle) * distance,
                                y: 300 + Math.sin(angle) * distance,
                                z: 0
                            },
                            velocity: {
                                x: -Math.sin(angle) * (15 + i * 2),
                                y: Math.cos(angle) * (15 + i * 2),
                                z: 0
                            },
                            color: this.getScientificColor(i)
                        }));
                    }
                    
                    this.selectedBodyId = this.bodies[0].id;
                    this.calculateInitialMetrics();
                }
            };
        }
    </script>
</body>
</html>