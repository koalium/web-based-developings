<!DOCTYPE html>
<html lang="en" x-data="nBodySimulation()" x-cloak>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-Body Gravitational Simulation with Highly Elliptical Orbits</title>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #151530 100%);
            color: #e0e0ff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        h1 {
            font-size: 2.8rem;
            background: linear-gradient(90deg, #ff6b6b 0%, #4ecdc4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #a0a0ff;
            max-width: 1200px;
            margin: 0 auto 20px;
            line-height: 1.6;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .simulation-area {
            background: rgba(15, 15, 35, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.1);
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            margin-bottom: 20px;
            overflow: hidden;
            border-radius: 10px;
        }
        
        #simulationCanvas {
            background: radial-gradient(circle at center, #050515 0%, #020210 100%);
            border-radius: 10px;
            width: 100%;
            height: 100%;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 20px;
            pointer-events: none;
            z-index: 10;
        }
        
        .info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 300px;
        }
        
        .info-overlay h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.3);
            padding-bottom: 5px;
        }
        
        .control-panel {
            background: rgba(15, 15, 35, 0.8);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .control-section {
            background: rgba(10, 10, 30, 0.6);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.1);
        }
        
        h2 {
            font-size: 1.5rem;
            color: #ff6b6b;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        h3 {
            font-size: 1.2rem;
            color: #4ecdc4;
            margin-bottom: 10px;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .preset-button {
            padding: 12px;
            background: linear-gradient(90deg, rgba(255, 107, 107, 0.2) 0%, rgba(78, 205, 196, 0.2) 100%);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 8px;
            color: #e0e0ff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .preset-button:hover {
            background: linear-gradient(90deg, rgba(255, 107, 107, 0.4) 0%, rgba(78, 205, 196, 0.4) 100%);
            transform: translateY(-2px);
        }
        
        .preset-button.active {
            background: linear-gradient(90deg, #ff6b6b 0%, #4ecdc4 100%);
            color: #0a0a1a;
            font-weight: bold;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #b0d0ff;
            font-size: 0.9rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #ff6b6b 0%, #4ecdc4 100%);
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
        }
        
        .value-display {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(255, 107, 107, 0.2);
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
            margin-left: 10px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            padding: 12px 20px;
            background: linear-gradient(90deg, #ff6b6b 0%, #4ecdc4 100%);
            border: none;
            border-radius: 8px;
            color: #0a0a1a;
            font-weight: bold;
            cursor: pointer;
            flex: 1;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.reset {
            background: linear-gradient(90deg, #ff8a00 0%, #ffcc00 100%);
            box-shadow: 0 5px 15px rgba(255, 138, 0, 0.3);
        }
        
        button.speed-control {
            background: linear-gradient(90deg, #9d4edd 0%, #ff6b6b 100%);
        }
        
        .body-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            background: rgba(5, 5, 20, 0.6);
            border-radius: 8px;
            padding: 10px;
        }
        
        .body-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .body-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .body-item.selected {
            background: rgba(255, 107, 107, 0.2);
            border-left: 3px solid #ff6b6b;
        }
        
        .body-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .body-info {
            flex: 1;
            font-size: 0.9rem;
        }
        
        .body-name {
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .body-stats {
            font-size: 0.8rem;
            color: #a0a0ff;
        }
        
        .status-display {
            font-family: monospace;
            background: rgba(5, 5, 20, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .status-label {
            color: #4ecdc4;
        }
        
        .status-value {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .visualization-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .visualization-card {
            background: rgba(15, 15, 35, 0.8);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.1);
        }
        
        .energy-graph-container {
            height: 250px;
            margin-top: 15px;
            position: relative;
        }
        
        #energyCanvas {
            background: rgba(5, 5, 20, 0.9);
            border-radius: 8px;
            width: 100%;
            height: 100%;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .physics-explanation {
            margin-top: 20px;
            padding: 20px;
            background: rgba(10, 10, 30, 0.6);
            border-radius: 10px;
            border-left: 4px solid #ff6b6b;
        }
        
        .physics-title {
            color: #ff6b6b;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .physics-text {
            color: #b0d0ff;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .highlight {
            color: #4ecdc4;
            font-weight: bold;
        }
        
        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .visualization-section {
                grid-template-columns: 1fr;
            }
        }
        
        [x-cloak] {
            display: none !important;
        }
        
        .time-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .time-display {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 100px;
            text-align: center;
        }
        
        .trail-length-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .visual-effect-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .toggle-label {
            color: #b0d0ff;
            font-size: 0.9rem;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background: linear-gradient(90deg, #ff6b6b 0%, #4ecdc4 100%);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>N-Body Gravitational Simulation</h1>
            <p class="subtitle">Visualizing highly elliptical orbits, double-star systems, and complex gravitational interactions with fast-forward time control. Watch asymmetric orbits stretch and dance under Newtonian gravity.</p>
        </header>
        
        <div class="main-content">
            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="simulationCanvas" width="1200" height="600"></canvas>
                    <div class="canvas-overlay">
                        <div class="info-overlay">
                            <h3>System Status</h3>
                            <div class="status-row">
                                <span>Bodies:</span>
                                <span x-text="bodies.length"></span>
                            </div>
                            <div class="status-row">
                                <span>Time:</span>
                                <span x-text="formatTime(simulationTime)"></span>
                            </div>
                            <div class="status-row">
                                <span>Speed:</span>
                                <span x-text="timeScale.toFixed(1) + 'x'"></span>
                            </div>
                            <div class="status-row">
                                <span>Energy Error:</span>
                                <span x-text="(energyError*100).toFixed(3) + '%'"></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="button-group">
                    <button @click="toggleSimulation">‚è∏Ô∏è Pause</button>
                    <button @click="resetSimulation">üîÑ Reset</button>
                    <button @click="clearTrails">üóëÔ∏è Clear Trails</button>
                    <button @click="addRandomBody" class="speed-control">‚ûï Add Body</button>
                </div>
            </div>
            
            <div class="control-panel">
                <div class="control-section">
                    <h2>Simulation Presets</h2>
                    <div class="preset-buttons">
                        <div class="preset-button" :class="{'active': currentPreset === 'binary'}" @click="loadBinarySystem">
                            Binary Star
                        </div>
                        <div class="preset-button" :class="{'active': currentPreset === 'triple'}" @click="loadTripleSystem">
                            Triple System
                        </div>
                        <div class="preset-button" :class="{'active': currentPreset === 'highlyElliptical'}" @click="loadHighlyElliptical">
                            Highly Elliptical
                        </div>
                        <div class="preset-button" :class="{'active': currentPreset === 'chaotic'}" @click="loadChaoticSystem">
                            Chaotic Dance
                        </div>
                        <div class="preset-button" :class="{'active': currentPreset === 'solarSystem'}" @click="loadSolarSystem">
                            Mini Solar System
                        </div>
                        <div class="preset-button" :class="{'active': currentPreset === 'figure8'}" @click="loadFigure8">
                            Figure-8 Orbit
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2>Time Control</h2>
                    <div class="slider-container">
                        <label for="timeScale">Time Scale: <span class="value-display" x-text="timeScale.toFixed(1) + 'x'"></span></label>
                        <input type="range" id="timeScale" min="0.1" max="100" step="0.1" x-model="timeScale">
                        <div class="physics-text">Faster speeds reveal orbital patterns</div>
                    </div>
                    
                    <div class="time-control">
                        <button @click="timeScale = Math.max(0.1, timeScale / 2)" class="speed-control">‚è™ Slow Down</button>
                        <div class="time-display" x-text="formatTime(simulationTime)"></div>
                        <button @click="timeScale = Math.min(100, timeScale * 2)" class="speed-control">‚è© Speed Up</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2>Visualization</h2>
                    <div class="slider-container">
                        <label for="trailLength">Trail Length: <span class="value-display" x-text="trailLength"></span></label>
                        <input type="range" id="trailLength" min="50" max="2000" step="50" x-model="trailLength">
                    </div>
                    
                    <div class="visual-effect-toggle">
                        <span class="toggle-label">3D Effects</span>
                        <label class="toggle-switch">
                            <input type="checkbox" x-model="use3DEffects">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="visual-effect-toggle">
                        <span class="toggle-label">Show Orbits</span>
                        <label class="toggle-switch">
                            <input type="checkbox" x-model="showOrbits">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="visual-effect-toggle">
                        <span class="toggle-label">Velocity Vectors</span>
                        <label class="toggle-switch">
                            <input type="checkbox" x-model="showVectors">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="control-section">
                    <h2>Body Properties</h2>
                    <div class="slider-container">
                        <label for="selectedMass">Selected Body Mass: <span class="value-display" x-text="selectedBody ? selectedBody.mass.toFixed(2) + ' M‚òâ' : 'N/A'"></span></label>
                        <input type="range" id="selectedMass" min="0.1" max="10" step="0.1" 
                               x-model="selectedBody.mass" :disabled="!selectedBody"
                               @input="updateSelectedBody">
                    </div>
                    
                    <div class="slider-container">
                        <label for="gravityConstant">Gravity Constant: <span class="value-display" x-text="G.toExponential(2)"></span></label>
                        <input type="range" id="gravityConstant" min="-13" max="-10" step="0.1" 
                               x-model="logG" @input="updateGravityConstant">
                    </div>
                    
                    <div class="body-list">
                        <div class="body-item" 
                             :class="{'selected': body === selectedBody}"
                             @click="selectBody(body)"
                             x-for="body in bodies" :key="body.id">
                            <div class="body-color" :style="`background-color: ${body.color}`"></div>
                            <div class="body-info">
                                <div class="body-name" x-text="body.name"></div>
                                <div class="body-stats">
                                    Mass: <span x-text="body.mass.toFixed(2)"></span> M‚òâ | 
                                    Speed: <span x-text="Math.sqrt(body.vx**2 + body.vy**2).toFixed(2)"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-section">
            <div class="visualization-card">
                <h2>System Energy</h2>
                <div class="energy-graph-container">
                    <canvas id="energyCanvas" width="600" height="250"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff6b6b;"></div>
                        <span>Kinetic Energy</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4ecdc4;"></div>
                        <span>Potential Energy</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffe66d;"></div>
                        <span>Total Energy</span>
                    </div>
                </div>
                <div class="status-display">
                    <div class="status-row">
                        <span class="status-label">Total Energy:</span>
                        <span class="status-value" x-text="totalEnergy.toExponential(2) + ' J'"></span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Energy Conservation:</span>
                        <span class="status-value" x-text="(energyConservation*100).toFixed(3) + '%'"></span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Center of Mass:</span>
                        <span class="status-value" x-text="`(${centerOfMassX.toFixed(1)}, ${centerOfMassY.toFixed(1)})`"></span>
                    </div>
                </div>
            </div>
            
            <div class="visualization-card">
                <h2>Physics of N-Body Systems</h2>
                <div class="physics-explanation">
                    <div class="physics-title">Newton's Law of Universal Gravitation</div>
                    <div class="physics-text">
                        Each body attracts every other body with a force: 
                        <span class="highlight">F = G √ó (m‚ÇÅ √ó m‚ÇÇ) / r¬≤</span>
                        where G is the gravitational constant, m are masses, and r is distance.
                    </div>
                </div>
                
                <div class="physics-explanation">
                    <div class="physics-title">Highly Elliptical Orbits</div>
                    <div class="physics-text">
                        Elliptical orbits occur when eccentricity e > 0. As e approaches 1, 
                        orbits become extremely stretched. In asymmetric systems, 
                        gravitational perturbations create <span class="highlight">precession</span> and 
                        <span class="highlight">orbital resonance</span> patterns.
                    </div>
                </div>
                
                <div class="physics-explanation">
                    <div class="physics-title">Chaos in N-Body Systems</div>
                    <div class="physics-text">
                        Systems with 3 or more bodies are generally chaotic - 
                        small changes in initial conditions lead to dramatically 
                        different outcomes. This is the <span class="highlight">N-body problem</span> 
                        with no general analytical solution.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function nBodySimulation() {
            return {
                // Simulation state
                animationId: null,
                isRunning: true,
                simulationTime: 0,
                timeScale: 1.0,
                trailLength: 500,
                
                // Visualization settings
                use3DEffects: true,
                showOrbits: true,
                showVectors: true,
                
                // Physics constants
                G: 4.67430e4,
                logG: -11,
                bodies: [],
                selectedBody: null,
                currentPreset: 'binary',
                
                // Energy tracking
                energyHistory: [],
                totalEnergy: 0,
                kineticEnergy: 0,
                potentialEnergy: 0,
                energyConservation: 1.0,
                energyError: 0,
                centerOfMassX: 0,
                centerOfMassY: 0,
                
                // Body counter for naming
                bodyCounter: 0,
                
                init() {
                    this.loadBinarySystem();
                    this.startSimulation();
                    
                    // Initialize energy tracking
                    this.calculateEnergies();
                    
                    // Set up event listeners
                    window.addEventListener('keydown', (e) => {
                        if (e.code === 'Space') {
                            e.preventDefault();
                            this.toggleSimulation();
                        }
                    });
                },
                
                startSimulation() {
                    const canvas = document.getElementById('simulationCanvas');
                    const energyCanvas = document.getElementById('energyCanvas');
                    const ctx = canvas.getContext('2d');
                    const energyCtx = energyCanvas.getContext('2d');
                    
                    const animate = () => {
                        if (this.isRunning) {
                            // Update physics multiple times for stability
                            const steps = Math.max(1, Math.floor(this.timeScale));
                            for (let i = 0; i < steps; i++) {
                                this.updatePhysics(0.016 / steps);
                            }
                            
                            this.drawSimulation(ctx, canvas);
                            this.drawEnergyGraph(energyCtx, energyCanvas);
                        }
                        this.animationId = requestAnimationFrame(animate);
                    };
                    
                    animate();
                },
                
                updatePhysics(dt) {
                    // Calculate forces between all bodies
                    const forces = new Array(this.bodies.length);
                    for (let i = 0; i < this.bodies.length; i++) {
                        forces[i] = { fx: 0, fy: 0 };
                    }
                    
                    // N^2 force calculation (simplified - for small N it's fine)
                    for (let i = 0; i < this.bodies.length; i++) {
                        for (let j = i + 1; j < this.bodies.length; j++) {
                            const body1 = this.bodies[i];
                            const body2 = this.bodies[j];
                            
                            const dx = body2.x - body1.x;
                            const dy = body2.y - body1.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // Avoid division by zero and extreme forces
                            if (distance < 10) continue;
                            
                            const force = this.G * body1.mass * body2.mass / (distance * distance);
                            const fx = force * dx / distance;
                            const fy = force * dy / distance;
                            
                            forces[i].fx += fx;
                            forces[i].fy += fy;
                            forces[j].fx -= fx;
                            forces[j].fy -= fy;
                        }
                    }
                    
                    // Update velocities and positions
                    for (let i = 0; i < this.bodies.length; i++) {
                        const body = this.bodies[i];
                        const force = forces[i];
                        dt=0.001;
                        // Update velocity (F = ma, so a = F/m)
                        body.vx += force.fx/ body.mass * dt;
                        body.vy += force.fy / body.mass * dt;
                        
                        // Update position
                        body.x += body.vx * dt * 100; // Scale for visualization
                        body.y += body.vy * dt * 100;
                        
                        // Add to trail
                        body.trail.push({ x: body.x, y: body.y });
                        if (body.trail.length > this.trailLength) {
                            body.trail.shift();
                        }
                    }
                    
                    // Update simulation time
                    this.simulationTime += dt * this.timeScale;
                    
                    // Calculate energies and center of mass
                    this.calculateEnergies();
                },
                
                calculateEnergies() {
                    this.kineticEnergy = 0;
                    this.potentialEnergy = 0;
                    
                    let totalMass = 0;
                    this.centerOfMassX = 0;
                    this.centerOfMassY = 0;
                    
                    // Calculate kinetic energy and center of mass
                    for (const body of this.bodies) {
                        const v2 = body.vx * body.vx + body.vy * body.vy;
                        this.kineticEnergy += 0.5 * body.mass * v2;
                        
                        totalMass += body.mass;
                        this.centerOfMassX += body.x * body.mass;
                        this.centerOfMassY += body.y * body.mass;
                    }
                    
                    // Calculate potential energy
                    for (let i = 0; i < this.bodies.length; i++) {
                        for (let j = i + 1; j < this.bodies.length; j++) {
                            const body1 = this.bodies[i];
                            const body2 = this.bodies[j];
                            
                            const dx = body2.x - body1.x;
                            const dy = body2.y - body1.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 10) {
                                this.potentialEnergy -= this.G * body1.mass * body2.mass / distance;
                            }
                        }
                    }
                    
                    // Update center of mass
                    this.centerOfMassX /= totalMass;
                    this.centerOfMassY /= totalMass;
                    
                    // Calculate total energy
                    const newTotalEnergy = this.kineticEnergy + this.potentialEnergy;
                    
                    // Track energy conservation
                    if (this.energyHistory.length > 0) {
                        const firstEnergy = this.energyHistory[0].total;
                        this.energyError = Math.abs((newTotalEnergy - firstEnergy) / firstEnergy);
                        this.energyConservation = 1 - this.energyError;
                    }
                    
                    this.totalEnergy = newTotalEnergy;
                    
                    // Store energy history
                    this.energyHistory.push({
                        time: this.simulationTime,
                        kinetic: this.kineticEnergy,
                        potential: this.potentialEnergy,
                        total: newTotalEnergy
                    });
                    
                    // Keep history manageable
                    if (this.energyHistory.length > 500) {
                        this.energyHistory.shift();
                    }
                },
                
                drawSimulation(ctx, canvas) {
                    // Clear with space gradient
                    const gradient = ctx.createRadialGradient(
                        canvas.width/2, canvas.height/2, 0,
                        canvas.width/2, canvas.height/2, canvas.width
                    );
                    gradient.addColorStop(0, '#050515');
                    gradient.addColorStop(1, '#020210');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw grid
                    ctx.strokeStyle = 'rgba(100, 120, 255, 0.05)';
                    ctx.lineWidth = 1;
                    const gridSize = 50;
                    
                    for (let x = 0; x <= canvas.width; x += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y <= canvas.height; y += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Draw center of mass
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.centerOfMassX, this.centerOfMassY, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw body trails
                    for (const body of this.bodies) {
                        this.drawTrail(ctx, body);
                    }
                    
                    // Draw bodies
                    for (const body of this.bodies) {
                        this.drawBody(ctx, body);
                    }
                    
                    // Draw orbits if enabled
                    if (this.showOrbits) {
                        for (const body of this.bodies) {
                            this.drawOrbit(ctx, body);
                        }
                    }
                    
                    // Draw velocity vectors if enabled
                    if (this.showVectors) {
                        for (const body of this.bodies) {
                            this.drawVelocityVector(ctx, body);
                        }
                    }
                    
                    // Draw labels for selected body
                    if (this.selectedBody) {
                        this.drawBodyLabel(ctx, this.selectedBody);
                    }
                },
                
                drawTrail(ctx, body) {
                    if (body.trail.length < 2) return;
                    
                    ctx.beginPath();
                    ctx.moveTo(body.trail[0].x, body.trail[0].y);
                    
                    // Draw trail with fading color
                    for (let i = 1; i < body.trail.length; i++) {
                        const alpha = i / body.trail.length;
                        const point = body.trail[i];
                        
                        ctx.lineTo(point.x, point.y);
                        ctx.strokeStyle = `${body.color}${Math.floor(alpha * 60).toString(16).padStart(2, '0')}`;
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                    }
                },
                
                drawBody(ctx, body) {
                    const isSelected = body === this.selectedBody;
                    const radius = Math.max(5, Math.log(body.mass) * 4);
                    
                    if (this.use3DEffects) {
                        // 3D gradient effect
                        const gradient = ctx.createRadialGradient(
                            body.x - radius/3, body.y - radius/3, 0,
                            body.x, body.y, radius * 1.5
                        );
                        gradient.addColorStop(0, body.color);
                        gradient.addColorStop(0.7, this.darkenColor(body.color, 0.5));
                        gradient.addColorStop(1, this.darkenColor(body.color, 0.8));
                        
                        ctx.fillStyle = gradient;
                    } else {
                        ctx.fillStyle = body.color;
                    }
                    
                    // Draw body
                    ctx.beginPath();
                    ctx.arc(body.x, body.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw glow for large bodies
                    if (body.mass > 2) {
                        ctx.beginPath();
                        ctx.arc(body.x, body.y, radius * 1.5, 0, Math.PI * 2);
                        const glowGradient = ctx.createRadialGradient(
                            body.x, body.y, radius,
                            body.x, body.y, radius * 1.5
                        );
                        glowGradient.addColorStop(0, body.color + '80');
                        glowGradient.addColorStop(1, body.color + '00');
                        ctx.fillStyle = glowGradient;
                        ctx.fill();
                    }
                    
                    // Highlight selected body
                    if (isSelected) {
                        ctx.beginPath();
                        ctx.arc(body.x, body.y, radius + 3, 0, Math.PI * 2);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(body.x, body.y, radius + 6, 0, Math.PI * 2);
                        ctx.strokeStyle = '#ffffff40';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // Draw rotation for large bodies
                    if (body.mass > 1) {
                        const rotationAngle = this.simulationTime * 2;
                        ctx.beginPath();
                        ctx.arc(
                            body.x + Math.cos(rotationAngle) * radius * 0.7,
                            body.y + Math.sin(rotationAngle) * radius * 0.7,
                            radius * 0.3, 0, Math.PI * 2
                        );
                        ctx.fillStyle = this.lightenColor(body.color, 0.3);
                        ctx.fill();
                    }
                },
                
                drawOrbit(ctx, body) {
                    if (body.trail.length < 50) return;
                    
                    // Calculate approximate orbital ellipse from trail
                    const recentTrail = body.trail.slice(-100);
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    
                    for (const point of recentTrail) {
                        minX = Math.min(minX, point.x);
                        maxX = Math.max(maxX, point.x);
                        minY = Math.min(minY, point.y);
                        maxY = Math.max(maxY, point.y);
                    }
                    
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    const radiusX = (maxX - minX) / 2;
                    const radiusY = (maxY - minY) / 2;
                    
                    // Draw elliptical orbit
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = body.color + '40';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Draw foci (approximate)
                    const eccentricity = Math.sqrt(1 - (Math.min(radiusY, radiusX) ** 2) / (Math.max(radiusY, radiusX) ** 2));
                    const focusDistance = eccentricity * Math.max(radiusX, radiusY);
                    
                    ctx.fillStyle = '#ffffff40';
                    ctx.beginPath();
                    ctx.arc(centerX - focusDistance, centerY, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(centerX + focusDistance, centerY, 2, 0, Math.PI * 2);
                    ctx.fill();
                },
                
                drawVelocityVector(ctx, body) {
                    const speed = Math.sqrt(body.vx * body.vx + body.vy * body.vy);
                    const vectorScale = 20;
                    
                    ctx.beginPath();
                    ctx.moveTo(body.x, body.y);
                    ctx.lineTo(body.x + body.vx * vectorScale, body.y + body.vy * vectorScale);
                    ctx.strokeStyle = '#ffff0080';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Draw arrowhead
                    const angle = Math.atan2(body.vy, body.vx);
                    ctx.save();
                    ctx.translate(body.x + body.vx * vectorScale, body.y + body.vy * vectorScale);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-5, -3);
                    ctx.lineTo(-5, 3);
                    ctx.closePath();
                    ctx.fillStyle = '#ffff00';
                    ctx.fill();
                    ctx.restore();
                    
                    // Draw speed indicator
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '10px Arial';
                    ctx.fillText(`${speed.toFixed(2)}`, body.x + body.vx * vectorScale + 5, body.y + body.vy * vectorScale - 5);
                },
                
                drawBodyLabel(ctx, body) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    
                    const lines = [
                        body.name,
                        `Mass: ${body.mass.toFixed(2)} M‚òâ`,
                        `Speed: ${Math.sqrt(body.vx**2 + body.vy**2).toFixed(2)}`,
                        `Position: (${body.x.toFixed(0)}, ${body.y.toFixed(0)})`
                    ];
                    
                    const radius = Math.max(5, Math.log(body.mass) * 4);
                    const yStart = body.y - radius - 60;
                    
                    // Draw background for label
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(body.x - 80, yStart, 160, 55);
                    
                    // Draw text
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < lines.length; i++) {
                        ctx.fillText(lines[i], body.x, yStart + 15 + i * 12);
                    }
                },
                
                drawEnergyGraph(ctx, canvas) {
                    if (this.energyHistory.length < 2) return;
                    
                    // Clear canvas
                    ctx.fillStyle = 'rgba(5, 5, 20, 0.9)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Find min and max values
                    let minE = Infinity, maxE = -Infinity;
                    for (const data of this.energyHistory) {
                        minE = Math.min(minE, data.kinetic, data.potential, data.total);
                        maxE = Math.max(maxE, data.kinetic, data.potential, data.total);
                    }
                    
                    const padding = (maxE - minE) * 0.1;
                    minE -= padding;
                    maxE += padding;
                    
                    // Helper function to map value to y coordinate
                    const mapY = (value) => {
                        return canvas.height - ((value - minE) / (maxE - minE)) * canvas.height;
                    };
                    
                    // Draw grid
                    ctx.strokeStyle = 'rgba(100, 120, 255, 0.1)';
                    ctx.lineWidth = 0.5;
                    
                    for (let x = 0; x <= canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y <= canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Draw energy curves
                    this.drawEnergyCurve(ctx, canvas, this.energyHistory, 'kinetic', '#ff6b6b', mapY);
                    this.drawEnergyCurve(ctx, canvas, this.energyHistory, 'potential', '#4ecdc4', mapY);
                    this.drawEnergyCurve(ctx, canvas, this.energyHistory, 'total', '#ffe66d', mapY);
                    
                    // Draw axis labels
                    ctx.fillStyle = '#b0d0ff';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('Time ‚Üí', 10, canvas.height - 5);
                    ctx.save();
                    ctx.translate(5, canvas.height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('Energy (J)', 0, 0);
                    ctx.restore();
                },
                
                drawEnergyCurve(ctx, canvas, data, key, color, mapY) {
                    ctx.beginPath();
                    const step = canvas.width / (data.length - 1);
                    
                    for (let i = 0; i < data.length; i++) {
                        const x = i * step;
                        const y = mapY(data[i][key]);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                },
                
                // Color utilities
                darkenColor(color, amount) {
                    const hex = color.replace('#', '');
                    let r = parseInt(hex.substr(0, 2), 16);
                    let g = parseInt(hex.substr(2, 2), 16);
                    let b = parseInt(hex.substr(4, 2), 16);
                    
                    r = Math.floor(r * (1 - amount));
                    g = Math.floor(g * (1 - amount));
                    b = Math.floor(b * (1 - amount));
                    
                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                },
                
                lightenColor(color, amount) {
                    const hex = color.replace('#', '');
                    let r = parseInt(hex.substr(0, 2), 16);
                    let g = parseInt(hex.substr(2, 2), 16);
                    let b = parseInt(hex.substr(4, 2), 16);
                    
                    r = Math.min(255, Math.floor(r * (1 + amount)));
                    g = Math.min(255, Math.floor(g * (1 + amount)));
                    b = Math.min(255, Math.floor(b * (1 + amount)));
                    
                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                },
                
                // Preset systems
                loadBinarySystem() {
                    this.currentPreset = 'binary';
                    this.bodies = [];
                    this.bodyCounter = 0;
                    
                    // Two stars in binary orbit
                    this.addBody(600, 300, 0, -0.8, 3.0, '#ff6b6b', 'Alpha Star');
                    this.addBody(400, 300, 0, 1.2, 2.0, '#4ecdc4', 'Beta Star');
                    
                    // Add a planet with highly elliptical orbit
                    this.addBody(800, 300, 0, -1.5, 0.2, '#ffe66d', 'Planet');
                    
                    this.resetSimulation();
                },
                
                loadTripleSystem() {
                    this.currentPreset = 'triple';
                    this.bodies = [];
                    this.bodyCounter = 0;
                    
                    // Three-body system (like Alpha Centauri)
                    this.addBody(500, 300, 0.5, -0.6, 2.5, '#ff6b6b', 'Star A');
                    this.addBody(700, 300, -0.5, 0.4, 2.0, '#4ecdc4', 'Star B');
                    this.addBody(600, 450, 0.8, 0, 1.5, '#9d4edd', 'Star C');
                    
                    this.resetSimulation();
                },
                
                loadHighlyElliptical() {
                    this.currentPreset = 'highlyElliptical';
                    this.bodies = [];
                    this.bodyCounter = 0;
                    
                    // Central massive body
                    this.addBody(600, 300, 0, 0, 5.0, '#ffff00', 'Central Star');
                    
                    // Highly elliptical orbits with different orientations
                    this.addBody(900, 300, 0, -0.9, 0.3, '#ff6b6b', 'Elliptical 1');
                    this.addBody(300, 300, 0, 1.1, 0.4, '#4ecdc4', 'Elliptical 2');
                    this.addBody(600, 100, 1.2, 0, 0.2, '#ffe66d', 'Elliptical 3');
                    this.addBody(600, 500, -0.8, 0, 0.25, '#9d4edd', 'Elliptical 4');
                    
                    this.resetSimulation();
                },
                
                loadChaoticSystem() {
                    this.currentPreset = 'chaotic';
                    this.bodies = [];
                    this.bodyCounter = 0;
                    
                    // Chaotic N-body system
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2) / 8;
                        const distance = 200 + Math.random() * 100;
                        const x = 600 + Math.cos(angle) * distance;
                        const y = 300 + Math.sin(angle) * distance;
                        const vx = Math.sin(angle) * (0.5 + Math.random() * 0.5);
                        const vy = -Math.cos(angle) * (0.5 + Math.random() * 0.5);
                        const mass = 0.5 + Math.random() * 1.5;
                        const color = this.getRandomColor();
                        
                        this.addBody(x, y, vx, vy, mass, color, `Body ${i + 1}`);
                    }
                    
                    this.resetSimulation();
                },
                
                loadSolarSystem() {
                    this.currentPreset = 'solarSystem';
                    this.bodies = [];
                    this.bodyCounter = 0;
                    
                    // Sun
                    this.addBody(600, 300, 0, 0, 5.0, '#ffff00', 'Sun');
                    
                    // Planets with different orbital characteristics
                    const planets = [
                        { distance: 100, speed: 1.2, mass: 0.1, color: '#ff9999', name: 'Mercury' },
                        { distance: 150, speed: 0.9, mass: 0.2, color: '#ffcc99', name: 'Venus' },
                        { distance: 200, speed: 0.7, mass: 0.3, color: '#99ccff', name: 'Earth' },
                        { distance: 250, speed: 0.6, mass: 0.15, color: '#ff6666', name: 'Mars' },
                        { distance: 350, speed: 0.4, mass: 2.5, color: '#ff9966', name: 'Jupiter' },
                        { distance: 450, speed: 0.3, mass: 2.0, color: '#ffff99', name: 'Saturn' },
                    ];
                    
                    for (const planet of planets) {
                        const x = 600 + planet.distance;
                        const y = 300;
                        const vx = 0;
                        const vy = -planet.speed;
                        
                        this.addBody(x, y, vx, vy, planet.mass, planet.color, planet.name);
                    }
                    
                    this.resetSimulation();
                },
                
                loadFigure8() {
                    this.currentPreset = 'figure8';
                    this.bodies = [];
                    this.bodyCounter = 0;
                    
                    // Figure-8 three-body solution
                    this.addBody(600 - 100, 300, 0.347111, 0.532728, 1.0, '#ff6b6b', 'Body A');
                    this.addBody(600 + 100, 300, 0.347111, 0.532728, 1.0, '#4ecdc4', 'Body B');
                    this.addBody(600, 300 + 173.2, -0.694222, 0, 1.0, '#ffe66d', 'Body C');
                    
                    this.resetSimulation();
                },
                
                addRandomBody() {
                    const x = 300 + Math.random() * 600;
                    const y = 100 + Math.random() * 400;
                    const vx = (Math.random() - 0.5) * 2;
                    const vy = (Math.random() - 0.5) * 2;
                    const mass = 0.5 + Math.random() * 2;
                    const color = this.getRandomColor();
                    const name = `Body ${++this.bodyCounter}`;
                    
                    this.addBody(x, y, vx, vy, mass, color, name);
                    this.selectBody(this.bodies[this.bodies.length - 1]);
                },
                
                addBody(x, y, vx, vy, mass, color, name) {
                    this.bodies.push({
                        id: Date.now() + Math.random(),
                        x, y, vx, vy, mass, color, name,
                        trail: []
                    });
                },
                
                selectBody(body) {
                    this.selectedBody = body;
                },
                
                updateSelectedBody() {
                    // Body mass is already updated via x-model
                    // We just need to trigger a re-render
                },
                
                updateGravityConstant() {
                    this.G = Math.pow(10, this.logG);
                },
                
                getRandomColor() {
                    const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#9d4edd', '#ff8a00', '#00bbf9'];
                    return colors[Math.floor(Math.random() * colors.length)];
                },
                
                formatTime(seconds) {
                    const days = Math.floor(seconds / 86400);
                    const hours = Math.floor((seconds % 86400) / 3600);
                    const mins = Math.floor((seconds % 3600) / 60);
                    const secs = Math.floor(seconds % 60);
                    
                    if (days > 0) return `${days}d ${hours}h`;
                    if (hours > 0) return `${hours}h ${mins}m`;
                    if (mins > 0) return `${mins}m ${secs}s`;
                    return `${secs}s`;
                },
                
                // Control methods
                toggleSimulation() {
                    this.isRunning = !this.isRunning;
                },
                
                resetSimulation() {
                    this.simulationTime = 0;
                    this.energyHistory = [];
                    
                    for (const body of this.bodies) {
                        body.trail = [];
                    }
                    
                    this.calculateEnergies();
                },
                
                clearTrails() {
                    for (const body of this.bodies) {
                        body.trail = [];
                    }
                }
            };
        }
    </script>
</body>
</html>