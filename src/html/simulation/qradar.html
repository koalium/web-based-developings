<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM-PASSIVE RADAR SYSTEM | CLASSIFIED | LEVEL: OMEGA</title>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --quantum-blue: #00e0ff;
            --neon-green: #00ff9d;
            --plasma-purple: #bd00ff;
            --warm-white: #fff0e0;
            --cold-white: #e0f0ff;
            --dark-space: #0a0a14;
            --deep-space: #050510;
            --grid-alpha: rgba(0, 224, 255, 0.05);
            --grid-beta: rgba(189, 0, 255, 0.03);
            --alert-red: #ff2a2a;
            --warning-amber: #ffaa00;
            --safe-green: #00ff55;
            --critical-glow: rgba(255, 0, 0, 0.4);
        }
        
        /* Quantum Physics Effects */
        @property --quantum-phase {
            syntax: '<angle>';
            inherits: false;
            initial-value: 0deg;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', 'Cascadia Code', 'Roboto Mono', monospace;
            background: 
                radial-gradient(ellipse at 10% 10%, var(--deep-space) 0%, transparent 50%),
                radial-gradient(ellipse at 90% 90%, #001122 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, #000a1a 0%, #000000 100%);
            color: var(--warm-white);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        /* Quantum Field Effect */
        .quantum-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            background: 
                repeating-conic-gradient(from 0deg, transparent 0deg 1deg, var(--grid-alpha) 1deg 2deg),
                repeating-conic-gradient(from 45deg, transparent 0deg 2deg, var(--grid-beta) 2deg 4deg);
            animation: quantumSpin 600s linear infinite;
            opacity: 0.1;
        }
        
        @keyframes quantumSpin {
            to { transform: rotate(360deg); }
        }
        
        /* Main Container - Quantum Lattice */
        .quantum-container {
            display: grid;
            grid-template-columns: 280px 1fr 350px;
            grid-template-rows: 70px 1fr 220px 100px;
            gap: 1px;
            height: 100vh;
            padding: 1px;
            background: 
                linear-gradient(45deg, transparent 49%, var(--quantum-blue) 50%, transparent 51%),
                linear-gradient(135deg, transparent 49%, var(--plasma-purple) 50%, transparent 51%);
            background-size: 20px 20px;
            position: relative;
            z-index: 1;
        }
        
        /* Quantum Entanglement Effect */
        .entanglement-field {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
                    rgba(0, 224, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at calc(100% - var(--mouse-x, 50%)) var(--mouse-y, 50%), 
                    rgba(189, 0, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        /* Quantum Header - Superluminal */
        .quantum-header {
            grid-column: 1 / 4;
            background: 
                linear-gradient(90deg, 
                    transparent 0%, 
                    rgba(0, 224, 255, 0.1) 10%, 
                    rgba(0, 224, 255, 0.2) 50%, 
                    rgba(0, 224, 255, 0.1) 90%, 
                    transparent 100%),
                rgba(5, 10, 20, 0.95);
            border-bottom: 2px solid var(--quantum-blue);
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            padding: 0 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 0 50px rgba(0, 224, 255, 0.3),
                inset 0 0 100px rgba(0, 224, 255, 0.1);
        }
        
        .header-quantum-flux {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent, 
                var(--neon-green),
                var(--quantum-blue),
                var(--plasma-purple),
                transparent);
            animation: superluminalFlux 3s linear infinite;
            filter: blur(1px);
        }
        
        @keyframes superluminalFlux {
            to { left: 100%; }
        }
        
        .system-title {
            font-size: 1.6rem;
            font-weight: 900;
            background: linear-gradient(90deg, 
                var(--neon-green),
                var(--quantum-blue),
                var(--plasma-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 
                0 0 20px rgba(0, 224, 255, 0.5),
                0 0 40px rgba(0, 224, 255, 0.3);
            letter-spacing: 2px;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            animation: quantumTitleGlow 5s ease-in-out infinite;
        }
        
        @keyframes quantumTitleGlow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        /* Quantum Status Matrix */
        .quantum-status {
            display: grid;
            grid-template-columns: repeat(4, auto);
            gap: 20px;
            justify-content: end;
        }
        
        .status-qubit {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 10px;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 5px;
            border: 1px solid var(--grid-alpha);
            position: relative;
            overflow: hidden;
        }
        
        .status-qubit::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent,
                rgba(0, 224, 255, 0.2),
                transparent);
            animation: statusScan 3s linear infinite;
        }
        
        @keyframes statusScan {
            to { left: 100%; }
        }
        
        /* Quantum Control Matrix (Left Panel) */
        .quantum-control-matrix {
            grid-row: 2 / 4;
            background: 
                linear-gradient(180deg, 
                    rgba(5, 15, 30, 0.95) 0%,
                    rgba(2, 8, 20, 0.98) 100%),
                repeating-linear-gradient(0deg, 
                    transparent 0px,
                    var(--grid-alpha) 1px,
                    transparent 2px);
            border-right: 1px solid var(--grid-alpha);
            display: flex;
            flex-direction: column;
            padding: 15px;
            position: relative;
            overflow-y: auto;
        }
        
        /* Quantum Control Entanglement Groups */
        .control-entanglement {
            background: rgba(0, 10, 25, 0.7);
            border: 1px solid var(--grid-alpha);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .control-entanglement:hover {
            border-color: var(--quantum-blue);
            box-shadow: 
                0 0 20px rgba(0, 224, 255, 0.2),
                inset 0 0 20px rgba(0, 224, 255, 0.1);
        }
        
        /* Quantum Control Knobs - Superposition */
        .quantum-knob {
            position: relative;
            width: 70px;
            height: 70px;
            margin: 10px auto;
        }
        
        .knob-superposition {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                var(--deep-space) 0deg,
                var(--quantum-blue) 90deg,
                var(--plasma-purple) 180deg,
                var(--neon-green) 270deg,
                var(--deep-space) 360deg
            );
            animation: knobSuperposition 10s linear infinite;
            filter: blur(5px);
            opacity: 0.3;
        }
        
        @keyframes knobSuperposition {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        /* Quantum Radar Display - Holographic */
        .quantum-radar-display {
            grid-row: 2 / 3;
            background: 
                radial-gradient(ellipse at center,
                    rgba(0, 10, 25, 0.9) 0%,
                    rgba(0, 5, 15, 0.95) 50%,
                    rgba(0, 2, 10, 0.98) 100%),
                repeating-radial-gradient(
                    circle at 50% 50%,
                    transparent 0,
                    rgba(0, 224, 255, 0.02) 1px,
                    transparent 2px
                );
            position: relative;
            overflow: hidden;
            border: 1px solid var(--grid-alpha);
        }
        
        /* Quantum Grid - Non-Euclidean */
        .quantum-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 224, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 224, 255, 0.05) 1px, transparent 1px),
                linear-gradient(rgba(189, 0, 255, 0.03) 2px, transparent 2px),
                linear-gradient(90deg, rgba(189, 0, 255, 0.03) 2px, transparent 2px);
            background-size: 
                100px 100px,
                100px 100px,
                50px 50px,
                50px 50px;
            animation: gridWarp 20s linear infinite;
        }
        
        @keyframes gridWarp {
            0%, 100% { transform: perspective(1000px) rotateX(0deg) rotateY(0deg); }
            25% { transform: perspective(1000px) rotateX(5deg) rotateY(5deg); }
            50% { transform: perspective(1000px) rotateX(0deg) rotateY(10deg); }
            75% { transform: perspective(1000px) rotateX(5deg) rotateY(5deg); }
        }
        
        /* Quantum Sweep - Tachyon Beam */
        .tachyon-sweep {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1000px;
            height: 1000px;
            transform-origin: left center;
            animation: tachyonSweep 3s linear infinite;
            filter: blur(1px);
        }
        
        @keyframes tachyonSweep {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .sweep-tachyon {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 500px;
            height: 2px;
            background: linear-gradient(90deg,
                transparent 0%,
                var(--neon-green) 10%,
                var(--quantum-blue) 50%,
                var(--plasma-purple) 90%,
                transparent 100%
            );
            filter: 
                drop-shadow(0 0 10px var(--neon-green))
                drop-shadow(0 0 20px var(--quantum-blue))
                drop-shadow(0 0 30px var(--plasma-purple));
            transform-origin: left center;
        }
        
        /* Quantum Target - Wave-Particle Duality */
        .quantum-target {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s ease;
            z-index: 10;
            pointer-events: all;
        }
        
        .target-wave {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid;
            animation: wavePropagation 2s linear infinite;
            opacity: 0;
        }
        
        @keyframes wavePropagation {
            to {
                transform: translate(-50%, -50%) scale(3);
                opacity: 0;
            }
        }
        
        .target-particle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: currentColor;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 10px currentColor,
                0 0 20px currentColor,
                0 0 30px currentColor;
            animation: particleOscillation 1s ease-in-out infinite;
        }
        
        @keyframes particleOscillation {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        
        /* Quantum Information Matrix (Right Panel) */
        .quantum-info-matrix {
            grid-row: 2 / 4;
            background: 
                linear-gradient(180deg, 
                    rgba(5, 15, 30, 0.95) 0%,
                    rgba(2, 8, 20, 0.98) 100%),
                repeating-linear-gradient(90deg, 
                    transparent 0px,
                    var(--grid-alpha) 1px,
                    transparent 2px);
            border-left: 1px solid var(--grid-alpha);
            display: flex;
            flex-direction: column;
            padding: 15px;
            position: relative;
            overflow-y: auto;
        }
        
        /* Quantum State Card - Entangled Information */
        .quantum-state-card {
            background: 
                linear-gradient(145deg, 
                    rgba(0, 20, 40, 0.6),
                    rgba(0, 10, 25, 0.8)),
                radial-gradient(circle at 0% 0%, 
                    rgba(0, 224, 255, 0.1) 0%, 
                    transparent 50%);
            border: 1px solid var(--grid-alpha);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .quantum-state-card:hover {
            border-color: var(--quantum-blue);
            box-shadow: 
                0 0 30px rgba(0, 224, 255, 0.2),
                inset 0 0 30px rgba(0, 224, 255, 0.1);
            transform: translateX(-5px);
        }
        
        /* Quantum Data Stream - Decoherence Display */
        .quantum-data-stream {
            grid-column: 1 / 4;
            background: rgba(0, 5, 15, 0.95);
            border-top: 1px solid var(--grid-alpha);
            border-bottom: 1px solid var(--grid-alpha);
            padding: 10px;
            font-family: 'Cascadia Code', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-y: auto;
            position: relative;
        }
        
        .stream-decoherence {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg,
                transparent 0%,
                rgba(0, 224, 255, 0.05) 10%,
                rgba(0, 224, 255, 0.1) 50%,
                rgba(0, 224, 255, 0.05) 90%,
                transparent 100%
            );
            animation: decoherenceScan 10s linear infinite;
            pointer-events: none;
        }
        
        @keyframes decoherenceScan {
            from { transform: translateY(-100%); }
            to { transform: translateY(100%); }
        }
        
        /* Quantum Analysis Matrix (Bottom Panel) */
        .quantum-analysis-matrix {
            grid-column: 1 / 4;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1px;
            background: linear-gradient(45deg, 
                rgba(0, 224, 255, 0.1), 
                rgba(189, 0, 255, 0.1));
            padding: 1px;
        }
        
        /* Quantum Visualization Chambers */
        .quantum-visualization {
            background: rgba(0, 5, 15, 0.95);
            border: 1px solid var(--grid-alpha);
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .visualization-quantum {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at var(--vis-x, 50%) var(--vis-y, 50%),
                    rgba(0, 224, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at calc(100% - var(--vis-x, 50%)) var(--vis-y, 50%),
                    rgba(189, 0, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }
        
        /* Quantum Alert System - Critical Decoherence */
        .quantum-alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at center,
                    rgba(255, 0, 0, 0.2) 0%,
                    rgba(255, 0, 0, 0.1) 50%,
                    transparent 100%),
                repeating-linear-gradient(45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 0, 0, 0.1) 10px,
                    rgba(255, 0, 0, 0.1) 20px);
            backdrop-filter: blur(10px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: criticalDecoherence 0.5s infinite;
        }
        
        @keyframes criticalDecoherence {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Quantum Terminal Output */
        .quantum-terminal {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 400px;
            height: 150px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--quantum-blue);
            border-radius: 5px;
            padding: 10px;
            font-family: 'Cascadia Code', monospace;
            font-size: 0.8rem;
            line-height: 1.3;
            overflow: hidden;
            z-index: 1000;
            box-shadow: 
                0 0 50px rgba(0, 224, 255, 0.3),
                inset 0 0 30px rgba(0, 224, 255, 0.1);
        }
        
        .terminal-quantum {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg,
                transparent,
                var(--neon-green),
                var(--quantum-blue),
                var(--plasma-purple),
                transparent);
            animation: terminalScan 2s linear infinite;
        }
        
        @keyframes terminalScan {
            to { top: 100%; }
        }
        
        /* Quantum Measurement Effect */
        .quantum-measurement {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background: radial-gradient(circle at var(--measure-x, 50%) var(--measure-y, 50%),
                rgba(255, 255, 255, 0.3) 0%,
                rgba(255, 255, 255, 0.1) 10%,
                transparent 30%
            );
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        /* Quantum Ripple Effect */
        .quantum-ripple {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle,
                rgba(0, 224, 255, 0.5) 0%,
                rgba(0, 224, 255, 0.2) 30%,
                transparent 70%
            );
            transform: scale(0);
            animation: rippleExpand 1s ease-out;
        }
        
        @keyframes rippleExpand {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        
        /* Responsive Quantum Collapse */
        @media (max-width: 1920px) {
            .quantum-container {
                grid-template-columns: 250px 1fr 300px;
            }
        }
        
        @media (max-width: 1600px) {
            .quantum-container {
                grid-template-columns: 200px 1fr 250px;
                grid-template-rows: 70px 1fr 180px 80px;
            }
        }
        
        /* Quantum Loading State */
        .quantum-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--deep-space);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100000;
        }
        
        .loading-quantum {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: var(--quantum-blue);
            border-right-color: var(--plasma-purple);
            border-bottom-color: var(--neon-green);
            animation: quantumSpin 2s linear infinite;
        }
    </style>
</head>
<body>
    <div class="quantum-field"></div>
    <div class="entanglement-field" id="entanglementField"></div>
    <div class="quantum-measurement" id="quantumMeasurement"></div>
    
    <div class="quantum-container" x-data="quantumRadar()" x-init="init()">
        <!-- Quantum Header -->
        <div class="quantum-header">
            <div class="header-quantum-flux"></div>
            
            <div class="system-status-quantum">
                <div class="status-qubit">
                    <div class="status-label">QUANTUM STATE</div>
                    <div class="status-value" x-text="`Œ® = ${quantumState.amplitude.toFixed(3)}|0‚ü© + ${(1-quantumState.amplitude).toFixed(3)}|1‚ü©`"></div>
                </div>
            </div>
            
            <div class="system-title">QUANTUM-PASSIVE RADAR SYSTEM</div>
            
            <div class="quantum-status">
                <div class="status-qubit">
                    <div class="status-label">ENTANGLEMENT</div>
                    <div class="status-value" x-text="`${(system.entanglement * 100).toFixed(1)}%`"></div>
                </div>
                <div class="status-qubit">
                    <div class="status-label">DECOHERENCE</div>
                    <div class="status-value" x-text="`${system.decoherence.toFixed(1)}%`"></div>
                </div>
                <div class="status-qubit">
                    <div class="status-label">SUPERPOSITION</div>
                    <div class="status-value" x-text="`${system.superposition} STATES`"></div>
                </div>
                <div class="status-qubit">
                    <div class="status-label">TARGETS</div>
                    <div class="status-value" x-text="targets.length"></div>
                </div>
            </div>
        </div>
        
        <!-- Quantum Control Matrix -->
        <div class="quantum-control-matrix">
            <div class="control-entanglement">
                <div class="control-title">QUANTUM CONTROL</div>
                <div class="quantum-controls">
                    <div class="control-group">
                        <div class="quantum-knob" @mousedown="startQuantumControl($event, 'entanglement')">
                            <div class="knob-superposition"></div>
                            <div class="knob-interface"></div>
                        </div>
                        <div class="control-label">ENTANGLEMENT</div>
                        <div class="control-value" x-text="`${(system.entanglement * 100).toFixed(1)}%`"></div>
                    </div>
                    
                    <div class="control-group">
                        <div class="quantum-knob" @mousedown="startQuantumControl($event, 'coherence')">
                            <div class="knob-superposition"></div>
                            <div class="knob-interface"></div>
                        </div>
                        <div class="control-label">COHERENCE</div>
                        <div class="control-value" x-text="`${((1-system.decoherence/100) * 100).toFixed(1)}%`"></div>
                    </div>
                </div>
            </div>
            
            <div class="control-entanglement">
                <div class="control-title">QUANTUM PROCESSING</div>
                <div class="quantum-processors">
                    <div class="processor-core" 
                         :class="{'active': processor.active}"
                         @click="toggleProcessor(processor.id)"
                         x-for="processor in quantumProcessors" :key="processor.id">
                        <div class="core-quantum" :style="`background: ${processor.color}`"></div>
                        <div class="core-label" x-text="processor.name"></div>
                        <div class="core-load" x-text="`${processor.load}%`"></div>
                    </div>
                </div>
            </div>
            
            <div class="control-entanglement">
                <div class="control-title">QUANTUM ALGORITHMS</div>
                <div class="quantum-algorithms">
                    <div class="algorithm-qubit"
                         :class="{'entangled': algorithm.entangled}"
                         @click="toggleAlgorithm(algorithm.id)"
                         x-for="algorithm in quantumAlgorithms" :key="algorithm.id">
                        <div class="algorithm-icon" x-text="algorithm.icon"></div>
                        <div class="algorithm-name" x-text="algorithm.name"></div>
                        <div class="algorithm-status">
                            <div class="status-quantum" :style="`background: ${algorithm.active ? '#00ff55' : '#ff2a2a'}`"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-entanglement">
                <div class="control-title">QUANTUM SIMULATION</div>
                <div class="quantum-simulation-controls">
                    <button class="btn-quantum" @click="createQuantumTarget()">
                        <div class="btn-quantum-effect"></div>
                        <span>QUANTUM TARGET</span>
                    </button>
                    <button class="btn-quantum btn-quantum-danger" @click="triggerQuantumEvent()">
                        <div class="btn-quantum-effect"></div>
                        <span>QUANTUM EVENT</span>
                    </button>
                    <button class="btn-quantum btn-quantum-warning" @click="measureSystem()">
                        <div class="btn-quantum-effect"></div>
                        <span>QUANTUM MEASURE</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Quantum Radar Display -->
        <div class="quantum-radar-display" id="quantumRadar">
            <div class="quantum-grid"></div>
            <div class="tachyon-sweep">
                <div class="sweep-tachyon"></div>
                <div class="sweep-tachyon" style="transform: rotate(120deg); opacity: 0.7;"></div>
                <div class="sweep-tachyon" style="transform: rotate(240deg); opacity: 0.5;"></div>
            </div>
            
            <!-- Quantum Targets -->
            <template x-for="target in targets" :key="target.id">
                <div class="quantum-target"
                     :style="`
                        left: ${target.position.x}%;
                        top: ${target.position.y}%;
                        color: ${target.color};
                     `"
                     @mouseenter="hoverQuantumTarget(target)"
                     @mouseleave="unhoverQuantumTarget()"
                     @click="measureTarget(target)">
                    
                    <!-- Wave Function -->
                    <div class="target-wave" :style="`border-color: ${target.color}; animation-delay: ${target.id * 0.2}s;`"></div>
                    <div class="target-wave" :style="`border-color: ${target.color}; animation-delay: ${target.id * 0.4}s;`"></div>
                    <div class="target-wave" :style="`border-color: ${target.color}; animation-delay: ${target.id * 0.6}s;`"></div>
                    
                    <!-- Particle State -->
                    <div class="target-particle"></div>
                    
                    <!-- Quantum Information -->
                    <div class="target-quantum-info" x-show="hoveredTarget === target">
                        <div class="quantum-info" x-text="target.id"></div>
                        <div class="quantum-state" x-text="`|Œ®‚ü© = ${target.quantumState}`"></div>
                    </div>
                </div>
            </template>
            
            <!-- Quantum Entanglement Lines -->
            <svg class="quantum-entanglement-lines" width="100%" height="100%">
                <template x-for="connection in quantumConnections" :key="connection.id">
                    <line class="entanglement-line"
                          :x1="connection.source.x"
                          :y1="connection.source.y"
                          :x2="connection.target.x"
                          :y2="connection.target.y"
                          :stroke="connection.color"
                          stroke-width="1"
                          stroke-dasharray="5,5"
                          opacity="0.3">
                        <animate attributeName="stroke-dashoffset"
                                 from="0" to="10"
                                 dur="1s"
                                 repeatCount="indefinite" />
                    </line>
                </template>
            </svg>
        </div>
        
        <!-- Quantum Information Matrix -->
        <div class="quantum-info-matrix">
            <div class="info-title">QUANTUM INFORMATION</div>
            
            <div class="quantum-state-card" 
                 :style="`border-color: ${target.color};`"
                 x-for="target in targets" :key="target.id">
                <div class="quantum-state-header">
                    <div class="state-id" x-text="target.id"></div>
                    <div class="state-type" :style="`color: ${target.color}`" x-text="target.type"></div>
                </div>
                
                <div class="quantum-state-body">
                    <div class="state-vector">
                        <div class="vector-label">QUANTUM STATE</div>
                        <div class="vector-value" x-text="`|Œ®‚ü© = ${target.quantumState}`"></div>
                    </div>
                    
                    <div class="state-probability">
                        <div class="probability-label">PROBABILITY DENSITY</div>
                        <div class="probability-wave">
                            <template x-for="(prob, index) in target.probabilityDensity" :key="index">
                                <div class="probability-bar"
                                     :style="`
                                        height: ${prob * 100}%;
                                        background: ${target.color};
                                     `"></div>
                            </template>
                        </div>
                    </div>
                    
                    <div class="state-observables">
                        <div class="observable-group">
                            <div class="observable">
                                <span class="observable-label">POSITION Œîx</span>
                                <span class="observable-value" x-text="`${target.uncertainty.position.toFixed(3)}`"></span>
                            </div>
                            <div class="observable">
                                <span class="observable-label">MOMENTUM Œîp</span>
                                <span class="observable-value" x-text="`${target.uncertainty.momentum.toFixed(3)}`"></span>
                            </div>
                        </div>
                        <div class="heisenberg-inequality" 
                             :style="`color: ${target.uncertainty.violation ? '#ff2a2a' : '#00ff55'}`"
                             x-text="`Œîx¬∑Œîp = ${(target.uncertainty.position * target.uncertainty.momentum).toFixed(3)} ‚â• ƒß/2`"></div>
                    </div>
                    
                    <div class="state-entanglement">
                        <div class="entanglement-label">ENTANGLEMENT ENTROPY</div>
                        <div class="entanglement-value" x-text="`S = ${target.entanglementEntropy.toFixed(3)}`"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Quantum Data Stream -->
        <div class="quantum-data-stream">
            <div class="stream-decoherence"></div>
            <div class="stream-content">
                <template x-for="event in quantumEvents" :key="event.id">
                    <div class="stream-event" :style="`color: ${event.color}`">
                        <span class="event-time" x-text="`[${event.time}]`"></span>
                        <span class="event-type" x-text="`${event.type}:`"></span>
                        <span class="event-message" x-text="event.message"></span>
                    </div>
                </template>
            </div>
        </div>
        
        <!-- Quantum Analysis Matrix -->
        <div class="quantum-analysis-matrix">
            <div class="quantum-visualization">
                <div class="visualization-title">WAVE FUNCTION</div>
                <div class="visualization-quantum"></div>
                <canvas id="waveFunctionCanvas"></canvas>
            </div>
            
            <div class="quantum-visualization">
                <div class="visualization-title">PROBABILITY DENSITY</div>
                <div class="visualization-quantum"></div>
                <canvas id="probabilityCanvas"></canvas>
            </div>
            
            <div class="quantum-visualization">
                <div class="visualization-title">PHASE SPACE</div>
                <div class="visualization-quantum"></div>
                <canvas id="phaseSpaceCanvas"></canvas>
            </div>
            
            <div class="quantum-visualization">
                <div class="visualization-title">QUANTUM TOMOGRAPHY</div>
                <div class="visualization-quantum"></div>
                <canvas id="tomographyCanvas"></canvas>
            </div>
        </div>
        
        <!-- Quantum Alert Overlay -->
        <template x-if="quantumAlert.active">
            <div class="quantum-alert-overlay">
                <div class="quantum-alert-container">
                    <div class="alert-quantum-icon">‚öõÔ∏è</div>
                    <h2 class="alert-quantum-title" x-text="quantumAlert.title"></h2>
                    <p class="alert-quantum-message" x-text="quantumAlert.message"></p>
                    <div class="alert-quantum-equation" x-text="quantumAlert.equation"></div>
                    <button class="btn-quantum-alert" @click="quantumAlert.active = false">
                        COLLAPSE WAVE FUNCTION
                    </button>
                </div>
            </div>
        </template>
        
        <!-- Quantum Terminal -->
        <div class="quantum-terminal">
            <div class="terminal-quantum"></div>
            <div class="terminal-output">
                <div class="output-line" x-text="`> Quantum System Initialized`"></div>
                <div class="output-line" x-text="`> Hilbert Space Dimension: ${system.hilbertDimension}`"></div>
                <div class="output-line" x-text="`> Entanglement Generated: ${(system.entanglement * 100).toFixed(1)}%`"></div>
                <div class="output-line" x-text="`> Decoherence Rate: ${system.decoherence.toFixed(2)}%`"></div>
                <div class="output-line" x-text="`> Quantum Gates Applied: ${quantumGates}`"></div>
            </div>
        </div>
    </div>

    <script>
        function quantumRadar() {
            return {
                // Quantum System State
                system: {
                    entanglement: 0.85,
                    decoherence: 12.3,
                    superposition: 256,
                    hilbertDimension: 1024,
                    quantumNoise: 0.05,
                    measurementPrecision: 0.001,
                    coherenceTime: 1500 // ms
                },
                
                // Quantum State Vector
                quantumState: {
                    amplitude: 0.707, // 1/‚àö2
                    phase: 0,
                    densityMatrix: [],
                    purity: 0.95,
                    vonNeumannEntropy: 0.12
                },
                
                // Quantum Targets (Wave-Particle Duality)
                targets: [
                    {
                        id: 'QŒ®-001',
                        type: 'quantum-drone',
                        color: '#00e0ff',
                        position: { x: 35, y: 40 },
                        quantumState: 'Œ±|0‚ü© + Œ≤|1‚ü©',
                        probabilityDensity: [0.3, 0.7, 0.9, 0.7, 0.3, 0.1, 0.4, 0.8],
                        uncertainty: {
                            position: 0.15,
                            momentum: 0.22,
                            violation: false
                        },
                        entanglementEntropy: 0.45,
                        waveFunction: [],
                        phaseSpace: [],
                        tomography: []
                    },
                    {
                        id: 'QŒ®-002',
                        type: 'entangled-pair',
                        color: '#bd00ff',
                        position: { x: 65, y: 30 },
                        quantumState: '(|00‚ü© + |11‚ü©)/‚àö2',
                        probabilityDensity: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
                        uncertainty: {
                            position: 0.08,
                            momentum: 0.35,
                            violation: true
                        },
                        entanglementEntropy: 1.0,
                        waveFunction: [],
                        phaseSpace: [],
                        tomography: []
                    },
                    {
                        id: 'QŒ®-003',
                        type: 'superposition-state',
                        color: '#00ff9d',
                        position: { x: 50, y: 60 },
                        quantumState: '(1/‚àö3)(|0‚ü© + |1‚ü© + |2‚ü©)',
                        probabilityDensity: [0.33, 0.33, 0.33, 0.33, 0.33, 0.33, 0.33, 0.33],
                        uncertainty: {
                            position: 0.25,
                            momentum: 0.18,
                            violation: false
                        },
                        entanglementEntropy: 0.78,
                        waveFunction: [],
                        phaseSpace: [],
                        tomography: []
                    }
                ],
                
                // Quantum Connections (Entanglement)
                quantumConnections: [],
                
                // Quantum Processors
                quantumProcessors: [
                    { id: 1, name: 'QPU-A', color: '#00e0ff', active: true, load: 75 },
                    { id: 2, name: 'QPU-B', color: '#bd00ff', active: true, load: 60 },
                    { id: 3, name: 'QPU-C', color: '#00ff9d', active: false, load: 0 },
                    { id: 4, name: 'QPU-D', color: '#ff2a2a', active: true, load: 90 }
                ],
                
                // Quantum Algorithms
                quantumAlgorithms: [
                    { id: 1, name: 'Shor', icon: 'üî¢', active: true, entangled: true },
                    { id: 2, name: 'Grover', icon: 'üîç', active: true, entangled: false },
                    { id: 3, name: 'HHL', icon: 'üßÆ', active: false, entangled: true },
                    { id: 4, name: 'QAOA', icon: '‚ö°', active: true, entangled: true },
                    { id: 5, name: 'VQE', icon: 'üß™', active: false, entangled: true }
                ],
                
                // Quantum Events Timeline
                quantumEvents: [],
                
                // Quantum Alert System
                quantumAlert: {
                    active: false,
                    title: '',
                    message: '',
                    equation: ''
                },
                
                // Quantum Counters
                quantumGates: 0,
                quantumMeasurements: 0,
                
                // Hover State
                hoveredTarget: null,
                
                // Quantum Animations
                quantumInterval: null,
                animationFrame: null,
                
                // Quantum Canvases
                quantumCanvases: {},
                
                init() {
                    this.initializeQuantumSystem();
                    this.createQuantumConnections();
                    this.initializeQuantumCanvases();
                    this.startQuantumEvolution();
                    this.initializeMouseTracking();
                    
                    // Initial quantum event
                    this.addQuantumEvent('System Initialization', 'Quantum radar system online', '#00e0ff');
                    this.addQuantumEvent('Entanglement Generated', 'Bell state preparation complete', '#bd00ff');
                },
                
                initializeQuantumSystem() {
                    // Initialize quantum state density matrix
                    this.quantumState.densityMatrix = this.createDensityMatrix();
                    
                    // Initialize target wave functions
                    this.targets.forEach(target => {
                        target.waveFunction = this.generateWaveFunction();
                        target.phaseSpace = this.generatePhaseSpace();
                        target.tomography = this.generateTomographyData();
                    });
                },
                
                createDensityMatrix() {
                    // Create a 2x2 density matrix for a mixed state
                    const rho = [];
                    for (let i = 0; i < 2; i++) {
                        rho[i] = [];
                        for (let j = 0; j < 2; j++) {
                            rho[i][j] = {
                                real: Math.random() * 0.5,
                                imag: Math.random() * 0.5
                            };
                        }
                    }
                    // Ensure trace = 1
                    const trace = rho[0][0].real + rho[1][1].real;
                    rho[0][0].real /= trace;
                    rho[1][1].real /= trace;
                    return rho;
                },
                
                generateWaveFunction() {
                    // Generate complex wave function values
                    const wave = [];
                    const N = 100;
                    for (let i = 0; i < N; i++) {
                        const x = (i - N/2) / 10;
                        const psi = {
                            real: Math.exp(-x*x/2) * Math.cos(x),
                            imag: Math.exp(-x*x/2) * Math.sin(x)
                        };
                        wave.push(psi);
                    }
                    return wave;
                },
                
                generatePhaseSpace() {
                    // Generate Wigner function data
                    const phase = [];
                    const size = 50;
                    for (let i = 0; i < size; i++) {
                        phase[i] = [];
                        for (let j = 0; j < size; j++) {
                            const x = (i - size/2) / 5;
                            const p = (j - size/2) / 5;
                            phase[i][j] = Math.exp(-x*x - p*p) * (1 + 0.1 * Math.sin(x*p));
                        }
                    }
                    return phase;
                },
                
                generateTomographyData() {
                    // Generate quantum state tomography data
                    const tomo = [];
                    const angles = 8;
                    for (let a = 0; a < angles; a++) {
                        tomo[a] = [];
                        for (let p = 0; p < angles; p++) {
                            tomo[a][p] = {
                                value: 0.5 + 0.4 * Math.sin(a * Math.PI/4) * Math.cos(p * Math.PI/4),
                                phase: (a + p) * Math.PI/4
                            };
                        }
                    }
                    return tomo;
                },
                
                createQuantumConnections() {
                    // Create entanglement connections between targets
                    this.quantumConnections = [];
                    for (let i = 0; i < this.targets.length; i++) {
                        for (let j = i + 1; j < this.targets.length; j++) {
                            const source = {
                                x: 50 + this.targets[i].position.x * 0.8,
                                y: 50 + this.targets[i].position.y * 0.8
                            };
                            const target = {
                                x: 50 + this.targets[j].position.x * 0.8,
                                y: 50 + this.targets[j].position.y * 0.8
                            };
                            
                            this.quantumConnections.push({
                                id: `${i}-${j}`,
                                source: source,
                                target: target,
                                color: this.blendColors(this.targets[i].color, this.targets[j].color),
                                strength: Math.random() * 0.5 + 0.5
                            });
                        }
                    }
                },
                
                blendColors(color1, color2) {
                    // Simple color blending
                    const c1 = this.hexToRgb(color1);
                    const c2 = this.hexToRgb(color2);
                    const r = Math.round((c1.r + c2.r) / 2);
                    const g = Math.round((c1.g + c2.g) / 2);
                    const b = Math.round((c1.b + c2.b) / 2);
                    return `rgb(${r}, ${g}, ${b})`;
                },
                
                hexToRgb(hex) {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : { r: 0, g: 0, b: 0 };
                },
                
                initializeQuantumCanvases() {
                    // Initialize all quantum visualization canvases
                    const canvases = [
                        'waveFunctionCanvas',
                        'probabilityCanvas',
                        'phaseSpaceCanvas',
                        'tomographyCanvas'
                    ];
                    
                    canvases.forEach(canvasId => {
                        const canvas = document.getElementById(canvasId);
                        if (canvas) {
                            canvas.width = canvas.parentElement.clientWidth - 20;
                            canvas.height = canvas.parentElement.clientHeight - 40;
                            this.quantumCanvases[canvasId] = {
                                canvas: canvas,
                                ctx: canvas.getContext('2d')
                            };
                        }
                    });
                },
                
                startQuantumEvolution() {
                    const evolve = () => {
                        this.evolveQuantumSystem();
                        this.updateQuantumVisualizations();
                        this.updateQuantumDisplays();
                        this.performQuantumMeasurements();
                        
                        this.animationFrame = requestAnimationFrame(evolve);
                    };
                    
                    evolve();
                    
                    // Quantum event generator
                    this.quantumInterval = setInterval(() => {
                        this.generateQuantumEvent();
                    }, 3000);
                },
                
                evolveQuantumSystem() {
                    // Time evolution of quantum system
                    const time = Date.now() / 1000;
                    
                    // Update quantum state
                    this.quantumState.phase = (this.quantumState.phase + 0.01) % (2 * Math.PI);
                    this.quantumState.amplitude = 0.707 + 0.1 * Math.sin(time * 0.5);
                    
                    // Update system parameters
                    this.system.entanglement = 0.8 + 0.1 * Math.sin(time * 0.3);
                    this.system.decoherence = 10 + 2 * Math.sin(time * 0.2);
                    this.system.quantumNoise = 0.03 + 0.02 * Math.sin(time * 0.4);
                    
                    // Update targets
                    this.targets.forEach((target, index) => {
                        // Quantum motion
                        const phase = time * 0.1 + index * Math.PI / 3;
                        target.position.x = 30 + 40 * Math.sin(phase);
                        target.position.y = 30 + 30 * Math.cos(phase * 1.3);
                        
                        // Update quantum state
                        target.quantumState = this.generateQuantumState(target);
                        
                        // Update uncertainty relations
                        target.uncertainty.position = 0.1 + 0.1 * Math.sin(time * 0.5 + index);
                        target.uncertainty.momentum = 0.2 + 0.1 * Math.cos(time * 0.5 + index);
                        target.uncertainty.violation = 
                            target.uncertainty.position * target.uncertainty.momentum < 0.5;
                        
                        // Update probability density
                        target.probabilityDensity = target.probabilityDensity.map((p, i) => {
                            return Math.max(0.1, Math.min(0.9, 
                                p + 0.01 * Math.sin(time + i * 0.5 + index)));
                        });
                        
                        // Update entanglement entropy
                        target.entanglementEntropy = 0.3 + 0.4 * Math.sin(time * 0.2 + index);
                        
                        // Apply quantum gates periodically
                        if (Math.random() < 0.01) {
                            this.applyQuantumGate(target);
                        }
                    });
                    
                    // Update connections
                    this.updateQuantumConnections();
                },
                
                generateQuantumState(target) {
                    const states = [
                        'Œ±|0‚ü© + Œ≤|1‚ü©',
                        '(|00‚ü© + |11‚ü©)/‚àö2',
                        '(1/‚àö3)(|0‚ü© + |1‚ü© + |2‚ü©)',
                        'cos(Œ∏)|0‚ü© + e^{iœÜ}sin(Œ∏)|1‚ü©',
                        '‚àöp|0‚ü©‚ü®0| + ‚àö(1-p)|1‚ü©‚ü®1|'
                    ];
                    const index = Math.floor(Math.random() * states.length);
                    return states[index];
                },
                
                applyQuantumGate(target) {
                    this.quantumGates++;
                    const gates = ['H', 'X', 'Y', 'Z', 'CNOT', 'SWAP'];
                    const gate = gates[Math.floor(Math.random() * gates.length)];
                    
                    this.addQuantumEvent(
                        'Quantum Gate Applied',
                        `${gate} gate applied to ${target.id}`,
                        target.color
                    );
                },
                
                updateQuantumConnections() {
                    this.quantumConnections.forEach(conn => {
                        // Update connection strength
                        conn.strength = 0.3 + 0.4 * Math.sin(Date.now() / 2000 + parseInt(conn.id));
                        
                        // Update positions
                        const sourceIdx = parseInt(conn.id[0]);
                        const targetIdx = parseInt(conn.id[2]);
                        conn.source.x = 50 + this.targets[sourceIdx]?.position.x * 0.8 || conn.source.x;
                        conn.source.y = 50 + this.targets[sourceIdx]?.position.y * 0.8 || conn.source.y;
                        conn.target.x = 50 + this.targets[targetIdx]?.position.x * 0.8 || conn.target.x;
                        conn.target.y = 50 + this.targets[targetIdx]?.position.y * 0.8 || conn.target.y;
                    });
                },
                
                updateQuantumVisualizations() {
                    // Update wave function visualization
                    this.drawWaveFunction();
                    
                    // Update probability density
                    this.drawProbabilityDensity();
                    
                    // Update phase space
                    this.drawPhaseSpace();
                    
                    // Update quantum tomography
                    this.drawQuantumTomography();
                },
                
                drawWaveFunction() {
                    const canvas = this.quantumCanvases.waveFunctionCanvas;
                    if (!canvas) return;
                    
                    const ctx = canvas.ctx;
                    const width = canvas.canvas.width;
                    const height = canvas.canvas.height;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw wave function
                    const target = this.targets[0]; // Use first target
                    if (!target.waveFunction) return;
                    
                    const N = target.waveFunction.length;
                    const dx = width / N;
                    
                    // Draw real part
                    ctx.beginPath();
                    ctx.strokeStyle = '#00e0ff';
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < N; i++) {
                        const x = i * dx;
                        const y = height/2 - target.waveFunction[i].real * height/3;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Draw imaginary part
                    ctx.beginPath();
                    ctx.strokeStyle = '#bd00ff';
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < N; i++) {
                        const x = i * dx;
                        const y = height/2 - target.waveFunction[i].imag * height/3;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Draw probability amplitude
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(0, 224, 255, 0.2)';
                    for (let i = 0; i < N; i++) {
                        const x = i * dx;
                        const prob = target.waveFunction[i].real ** 2 + target.waveFunction[i].imag ** 2;
                        const y = height/2 - prob * height/3;
                        const h = prob * height/3;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(x, y + h);
                    }
                    ctx.closePath();
                    ctx.fill();
                },
                
                drawProbabilityDensity() {
                    const canvas = this.quantumCanvases.probabilityCanvas;
                    if (!canvas) return;
                    
                    const ctx = canvas.ctx;
                    const width = canvas.canvas.width;
                    const height = canvas.canvas.height;
                    
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw probability density bars
                    const target = this.targets[0];
                    const N = target.probabilityDensity.length;
                    const barWidth = width / N;
                    
                    for (let i = 0; i < N; i++) {
                        const prob = target.probabilityDensity[i];
                        const barHeight = prob * height * 0.8;
                        
                        ctx.fillStyle = target.color;
                        ctx.fillRect(
                            i * barWidth,
                            height - barHeight,
                            barWidth - 2,
                            barHeight
                        );
                        
                        // Add quantum uncertainty bars
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            i * barWidth,
                            height - barHeight * (1 + target.uncertainty.position),
                            barWidth - 2,
                            barHeight * target.uncertainty.position * 2
                        );
                    }
                },
                
                drawPhaseSpace() {
                    const canvas = this.quantumCanvases.phaseSpaceCanvas;
                    if (!canvas) return;
                    
                    const ctx = canvas.ctx;
                    const width = canvas.canvas.width;
                    const height = canvas.canvas.height;
                    
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw phase space (Wigner function)
                    const target = this.targets[0];
                    if (!target.phaseSpace) return;
                    
                    const size = target.phaseSpace.length;
                    const cellSize = Math.min(width, height) / size;
                    
                    // Find max value for normalization
                    let maxVal = 0;
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            maxVal = Math.max(maxVal, target.phaseSpace[i][j]);
                        }
                    }
                    
                    // Draw phase space
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const value = target.phaseSpace[i][j] / maxVal;
                            const hue = 240 + value * 120; // Blue to red
                            
                            ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${value})`;
                            ctx.fillRect(
                                i * cellSize,
                                j * cellSize,
                                cellSize,
                                cellSize
                            );
                        }
                    }
                },
                
                drawQuantumTomography() {
                    const canvas = this.quantumCanvases.tomographyCanvas;
                    if (!canvas) return;
                    
                    const ctx = canvas.ctx;
                    const width = canvas.canvas.width;
                    const height = canvas.canvas.height;
                    
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw quantum state tomography
                    const target = this.targets[0];
                    if (!target.tomography) return;
                    
                    const angles = target.tomography.length;
                    const radius = Math.min(width, height) * 0.4;
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    // Draw tomography circles
                    for (let a = 0; a < angles; a++) {
                        const angle = (a * 2 * Math.PI) / angles;
                        for (let p = 0; p < angles; p++) {
                            const phase = target.tomography[a][p].phase;
                            const value = target.tomography[a][p].value;
                            
                            const x = centerX + radius * Math.cos(angle) * value;
                            const y = centerY + radius * Math.sin(angle) * value;
                            
                            // Draw point with phase-dependent color
                            const hue = (phase * 180 / Math.PI) % 360;
                            ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.8)`;
                            ctx.beginPath();
                            ctx.arc(x, y, 4, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            // Draw phase indicator
                            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.5)`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(centerX, centerY);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        }
                    }
                    
                    // Draw quantum state sphere
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                },
                
                updateQuantumDisplays() {
                    // Update quantum processors load
                    this.quantumProcessors.forEach(proc => {
                        proc.load = Math.min(100, Math.max(0, 
                            proc.load + (Math.random() - 0.5) * 10));
                    });
                    
                    // Update quantum algorithms status
                    this.quantumAlgorithms.forEach(algo => {
                        if (Math.random() < 0.01) {
                            algo.active = !algo.active;
                            algo.entangled = Math.random() > 0.5;
                        }
                    });
                },
                
                performQuantumMeasurements() {
                    // Perform random quantum measurements
                    if (Math.random() < 0.005) {
                        const target = this.targets[Math.floor(Math.random() * this.targets.length)];
                        this.measureTarget(target);
                    }
                },
                
                startQuantumControl(event, parameter) {
                    const startX = event.clientX;
                    const startValue = this.system[parameter];
                    
                    const onMouseMove = (moveEvent) => {
                        const deltaX = moveEvent.clientX - startX;
                        const newValue = Math.max(0, Math.min(1, startValue + deltaX / 100));
                        this.system[parameter] = newValue;
                        
                        // Add quantum effect
                        this.createQuantumRipple(event.clientX, event.clientY, this.system[parameter] > startValue ? '#00e0ff' : '#bd00ff');
                    };
                    
                    const onMouseUp = () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                        this.addQuantumEvent('Quantum Control', `${parameter} adjusted`, '#00ff9d');
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                },
                
                createQuantumRipple(x, y, color) {
                    const ripple = document.createElement('div');
                    ripple.className = 'quantum-ripple';
                    ripple.style.left = x + 'px';
                    ripple.style.top = y + 'px';
                    ripple.style.backgroundColor = color;
                    document.body.appendChild(ripple);
                    
                    setTimeout(() => {
                        ripple.remove();
                    }, 1000);
                },
                
                toggleProcessor(processorId) {
                    const processor = this.quantumProcessors.find(p => p.id === processorId);
                    if (processor) {
                        processor.active = !processor.active;
                        processor.load = processor.active ? 50 : 0;
                        
                        this.addQuantumEvent(
                            'Quantum Processor',
                            `${processor.name} ${processor.active ? 'activated' : 'deactivated'}`,
                            processor.color
                        );
                    }
                },
                
                toggleAlgorithm(algorithmId) {
                    const algorithm = this.quantumAlgorithms.find(a => a.id === algorithmId);
                    if (algorithm) {
                        algorithm.active = !algorithm.active;
                        algorithm.entangled = algorithm.active ? Math.random() > 0.3 : false;
                        
                        this.addQuantumEvent(
                            'Quantum Algorithm',
                            `${algorithm.name} algorithm ${algorithm.active ? 'enabled' : 'disabled'}`,
                            algorithm.active ? '#00ff55' : '#ff2a2a'
                        );
                    }
                },
                
                createQuantumTarget() {
                    const types = ['quantum-drone', 'entangled-pair', 'superposition-state', 'coherent-state', 'squeezed-state'];
                    const colors = ['#00e0ff', '#bd00ff', '#00ff9d', '#ffaa00', '#ff2a2a'];
                    const typeIndex = Math.floor(Math.random() * types.length);
                    
                    const newTarget = {
                        id: `QŒ®-${(this.targets.length + 100).toString().padStart(3, '0')}`,
                        type: types[typeIndex],
                        color: colors[typeIndex],
                        position: {
                            x: Math.random() * 60 + 20,
                            y: Math.random() * 60 + 20
                        },
                        quantumState: this.generateQuantumState({}),
                        probabilityDensity: Array.from({length: 8}, () => Math.random()),
                        uncertainty: {
                            position: Math.random() * 0.3,
                            momentum: Math.random() * 0.3,
                            violation: Math.random() > 0.7
                        },
                        entanglementEntropy: Math.random(),
                        waveFunction: this.generateWaveFunction(),
                        phaseSpace: this.generatePhaseSpace(),
                        tomography: this.generateTomographyData()
                    };
                    
                    this.targets.push(newTarget);
                    this.createQuantumConnections();
                    
                    this.addQuantumEvent(
                        'Quantum Target Created',
                        `${newTarget.type} ${newTarget.id} manifested`,
                        newTarget.color
                    );
                },
                
                triggerQuantumEvent() {
                    const events = [
                        {
                            title: 'QUANTUM ENTANGLEMENT',
                            message: 'Spontaneous entanglement generation detected',
                            equation: '|Œ®‚ü© = (|00‚ü© + |11‚ü©)/‚àö2',
                            color: '#bd00ff'
                        },
                        {
                            title: 'DECOHERENCE EVENT',
                            message: 'Quantum state collapse imminent',
                            equation: 'œÅ ‚Üí ‚àë Œ†·µ¢œÅŒ†·µ¢',
                            color: '#ff2a2a'
                        },
                        {
                            title: 'SUPERPOSITION BREAK',
                            message: 'Wave function collapse detected',
                            equation: '|Œ®‚ü© ‚Üí |k‚ü© with probability |‚ü®k|Œ®‚ü©|¬≤',
                            color: '#ffaa00'
                        },
                        {
                            title: 'QUANTUM TUNNELING',
                            message: 'Target exhibiting quantum tunneling behavior',
                            equation: 'T ‚âà exp(-2d‚àö(2m(V-E))/ƒß)',
                            color: '#00ff9d'
                        }
                    ];
                    
                    const event = events[Math.floor(Math.random() * events.length)];
                    
                    this.quantumAlert = {
                        active: true,
                        title: event.title,
                        message: event.message,
                        equation: event.equation
                    };
                    
                    this.addQuantumEvent(event.title, event.message, event.color);
                    
                    // Auto-collapse after 5 seconds
                    setTimeout(() => {
                        this.quantumAlert.active = false;
                    }, 5000);
                },
                
                measureTarget(target) {
                    this.quantumMeasurements++;
                    
                    // Perform quantum measurement
                    const outcomes = ['|0‚ü©', '|1‚ü©', '|+‚ü©', '|-‚ü©', '|‚Üª‚ü©', '|‚Ü∫‚ü©'];
                    const outcome = outcomes[Math.floor(Math.random() * outcomes.length)];
                    
                    // Update target state (wave function collapse)
                    target.quantumState = outcome;
                    
                    // Increase decoherence
                    this.system.decoherence += 0.5;
                    
                    // Create measurement effect
                    this.showMeasurementEffect(target.position.x, target.position.y);
                    
                    this.addQuantumEvent(
                        'Quantum Measurement',
                        `${target.id} collapsed to ${outcome}`,
                        target.color
                    );
                },
                
                showMeasurementEffect(x, y) {
                    const measurement = document.getElementById('quantumMeasurement');
                    measurement.style.setProperty('--measure-x', x + '%');
                    measurement.style.setProperty('--measure-y', y + '%');
                    measurement.style.opacity = '1';
                    
                    setTimeout(() => {
                        measurement.style.opacity = '0';
                    }, 500);
                },
                
                measureSystem() {
                    // Perform full quantum state tomography
                    const measurements = [
                        'X basis',
                        'Y basis', 
                        'Z basis',
                        'Diagonal basis',
                        'Circular basis'
                    ];
                    
                    const measurement = measurements[Math.floor(Math.random() * measurements.length)];
                    const fidelity = (0.8 + Math.random() * 0.19).toFixed(3);
                    
                    this.quantumAlert = {
                        active: true,
                        title: 'QUANTUM STATE TOMOGRAPHY',
                        message: `Complete quantum state reconstruction performed in ${measurement}`,
                        equation: `‚Ñ± = ${fidelity}`
                    };
                    
                    this.addQuantumEvent(
                        'Quantum Tomography',
                        `State tomography complete (Fidelity: ${fidelity})`,
                        '#00e0ff'
                    );
                    
                    setTimeout(() => {
                        this.quantumAlert.active = false;
                    }, 4000);
                },
                
                addQuantumEvent(type, message, color) {
                    const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                    this.quantumEvents.unshift({
                        id: Date.now(),
                        time: time,
                        type: type,
                        message: message,
                        color: color
                    });
                    
                    // Keep only recent events
                    if (this.quantumEvents.length > 20) {
                        this.quantumEvents = this.quantumEvents.slice(0, 20);
                    }
                },
                
                generateQuantumEvent() {
                    const events = [
                        {
                            type: 'Quantum Fluctuation',
                            message: 'Vacuum energy fluctuations detected',
                            color: '#00e0ff'
                        },
                        {
                            type: 'Entanglement Swap',
                            message: 'Quantum entanglement distribution complete',
                            color: '#bd00ff'
                        },
                        {
                            type: 'Coherence Loss',
                            message: 'Minor decoherence event recorded',
                            color: '#ffaa00'
                        },
                        {
                            type: 'Superposition',
                            message: 'New superposition state created',
                            color: '#00ff9d'
                        }
                    ];
                    
                    if (Math.random() < 0.3) {
                        const event = events[Math.floor(Math.random() * events.length)];
                        this.addQuantumEvent(event.type, event.message, event.color);
                    }
                },
                
                hoverQuantumTarget(target) {
                    this.hoveredTarget = target;
                    
                    // Update visualization focus
                    this.quantumCanvases.waveFunctionCanvas.target = target;
                    this.quantumCanvases.probabilityCanvas.target = target;
                    this.quantumCanvases.phaseSpaceCanvas.target = target;
                    this.quantumCanvases.tomographyCanvas.target = target;
                },
                
                unhoverQuantumTarget() {
                    this.hoveredTarget = null;
                },
                
                initializeMouseTracking() {
                    document.addEventListener('mousemove', (e) => {
                        const x = (e.clientX / window.innerWidth) * 100;
                        const y = (e.clientY / window.innerHeight) * 100;
                        
                        document.documentElement.style.setProperty('--mouse-x', x + '%');
                        document.documentElement.style.setProperty('--mouse-y', y + '%');
                        
                        // Update visualization effects
                        document.querySelectorAll('.visualization-quantum').forEach(el => {
                            const rect = el.getBoundingClientRect();
                            const localX = ((e.clientX - rect.left) / rect.width) * 100;
                            const localY = ((e.clientY - rect.top) / rect.height) * 100;
                            
                            el.style.setProperty('--vis-x', localX + '%');
                            el.style.setProperty('--vis-y', localY + '%');
                        });
                    });
                },
                
                // Cleanup
                beforeDestroy() {
                    if (this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                    }
                    if (this.quantumInterval) {
                        clearInterval(this.quantumInterval);
                    }
                }
            }
        }
    </script>
</body>
</html>