<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Rubik's Cube Solver | Advanced Visualization & AI Solving</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/tween.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --primary: #3498db;
            --secondary: #9b59b6;
            --accent: #e74c3c;
            --success: #2ecc71;
            --warning: #f39c12;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --bg: #121830;
            --panel: #1a1f38;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0c1027 0%, var(--bg) 100%);
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 2000px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0 40px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 3.5rem;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 15px;
            letter-spacing: 2px;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .tagline {
            font-size: 1.4rem;
            color: var(--light);
            font-weight: 300;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 2.5fr 1.5fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .cube-section {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .cube-wrapper {
            position: relative;
            background: linear-gradient(135deg, var(--panel), #141933);
            border-radius: 25px;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
            min-height: 600px;
        }

        #cube-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .cube-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.2) 100%);
        }

        .stats-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            min-width: 100px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .control-section {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .control-panel {
            background: linear-gradient(135deg, var(--panel), #141933);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-size: 1.5rem;
            color: var(--light);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .panel-title i {
            color: var(--primary);
            font-size: 1.3rem;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 5px;
            border-radius: 10px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .mode-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .face-controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .face-btn {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(155, 89, 182, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }

        .face-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .face-btn:hover:before {
            left: 100%;
        }

        .face-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border-color: var(--primary);
        }

        .face-color {
            width: 30px;
            height: 30px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .algorithm-panel {
            background: linear-gradient(135deg, var(--panel), #141933);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .algorithm-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .algorithm-list::-webkit-scrollbar {
            width: 6px;
        }

        .algorithm-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .algorithm-list::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
        }

        .algorithm-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .algorithm-item:hover {
            background: rgba(52, 152, 219, 0.1);
            border-color: var(--primary);
            transform: translateX(5px);
        }

        .algorithm-name {
            font-weight: bold;
            color: var(--light);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .algorithm-moves {
            font-family: 'Courier New', monospace;
            color: var(--primary);
            font-size: 0.9rem;
        }

        .solve-controls {
            background: linear-gradient(135deg, var(--panel), #141933);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.05);
            margin-top: 25px;
        }

        .solve-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .solve-btn {
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .solve-btn.primary {
            background: linear-gradient(135deg, var(--primary), #2980b9);
            color: white;
        }

        .solve-btn.secondary {
            background: linear-gradient(135deg, var(--secondary), #8e44ad);
            color: white;
        }

        .solve-btn.warning {
            background: linear-gradient(135deg, var(--warning), #d35400);
            color: white;
        }

        .solve-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .solving-progress {
            margin-top: 25px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }

        .footer {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 40px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .cube-wrapper {
                min-height: 500px;
            }
            
            .stats-overlay {
                position: relative;
                top: 0;
                left: 0;
                margin-bottom: 20px;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .tagline {
                font-size: 1.1rem;
            }
            
            .face-controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .solve-buttons {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .face-controls-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
        }

        .cube-sticker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border-radius: 10%;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-cube"></i> Advanced Rubik's Cube Solver</h1>
            <p class="tagline">Professional 3D visualization with AI-powered solving and mathematical color tracking</p>
        </header>
        
        <div class="main-grid">
            <div class="cube-section">
                <div class="cube-wrapper">
                    <canvas id="cube-canvas"></canvas>
                    <div class="cube-overlay"></div>
                    
                    <div class="stats-overlay">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="move-count">0</div>
                                <div class="stat-label">MOVES</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="timer">00:00.00</div>
                                <div class="stat-label">TIME</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="cube-state">SOLVED</div>
                                <div class="stat-label">STATE</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-panel">
                    <div class="panel-header">
                        <div class="panel-title">
                            <i class="fas fa-gamepad"></i> Cube Controls
                        </div>
                        <div class="mode-selector">
                            <button class="mode-btn active" data-mode="face">Face Rotation</button>
                            <button class="mode-btn" data-mode="slice">Slice Moves</button>
                            <button class="mode-btn" data-mode="wide">Wide Moves</button>
                        </div>
                    </div>
                    
                    <div class="face-controls-grid" id="face-controls">
                        <!-- Face controls will be generated dynamically -->
                    </div>
                    
                    <div class="rotation-controls">
                        <div class="solve-buttons">
                            <button class="solve-btn primary" id="scramble-btn">
                                <i class="fas fa-random"></i> Scramble
                            </button>
                            <button class="solve-btn secondary" id="solve-btn">
                                <i class="fas fa-robot"></i> Auto Solve
                            </button>
                            <button class="solve-btn warning" id="reset-btn">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="algorithm-panel">
                    <div class="panel-title">
                        <i class="fas fa-brain"></i> Solving Algorithms
                    </div>
                    <div class="algorithm-list" id="algorithm-list">
                        <!-- Algorithms will be populated dynamically -->
                    </div>
                </div>
                
                <div class="solve-controls">
                    <div class="panel-title">
                        <i class="fas fa-cogs"></i> Solver Settings
                    </div>
                    
                    <div class="solve-buttons">
                        <button class="solve-btn primary" id="cfop-btn">
                            <i class="fas fa-layer-group"></i> CFOP Method
                        </button>
                        <button class="solve-btn secondary" id="beginner-btn">
                            <i class="fas fa-graduation-cap"></i> Beginner
                        </button>
                        <button class="solve-btn warning" id="optimal-btn">
                            <i class="fas fa-bolt"></i> Optimal
                        </button>
                    </div>
                    
                    <div class="solving-progress" id="solving-progress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                        <div class="progress-text">
                            <span id="progress-step">Initializing...</span>
                            <span id="progress-percent">0%</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-panel">
                    <div class="panel-title">
                        <i class="fas fa-code"></i> Notation Input
                    </div>
                    <div class="notation-input" style="margin-top: 20px;">
                        <input type="text" id="notation-input" 
                               placeholder="Enter WCA notation (e.g., R U R' U')" 
                               style="width: 100%; padding: 15px; background: rgba(255,255,255,0.05); 
                                      border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; 
                                      color: white; font-size: 1rem;">
                        <div class="solve-buttons" style="margin-top: 15px; grid-template-columns: 1fr 1fr;">
                            <button class="solve-btn primary" id="execute-btn">
                                <i class="fas fa-play"></i> Execute
                            </button>
                            <button class="solve-btn secondary" id="reverse-btn">
                                <i class="fas fa-undo"></i> Reverse
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Professional Rubik's Cube Solver | Advanced 3D Engine | AI-Powered Solving Algorithms | Mathematical Color Tracking</p>
        </div>
    </div>

    <script>
        // ============================================
        // ADVANCED RUBIK'S CUBE ENGINE
        // With Mathematical Color Tracking and AI Solving
        // ============================================

        // Main Three.js variables
        let scene, camera, renderer, controls;
        let cubeGroup;
        let animationQueue = [];
        let isAnimating = false;
        
        // Cube state variables
        let cubeState = {
            // 3D array representation of the cube
            pieces: [],
            // Current orientation
            orientation: { x: 0, y: 0, z: 0 },
            // Move history
            history: [],
            // Timer
            startTime: null,
            timer: null,
            // Solving state
            isSolving: false,
            solvingStep: 0,
            totalSteps: 0,
            solution: []
        };
        
        // Cube dimensions and colors
        const CUBE_SIZE = 3;
        const PIECE_SIZE = 0.95;
        const GAP = 0.05;
        const TOTAL_SIZE = PIECE_SIZE + GAP;
        
        // Standard Rubik's Cube colors (WCA standard)
        const CUBE_COLORS = {
            U: 0xFFFFFF, // White
            D: 0xFFFF00, // Yellow
            F: 0x00FF00, // Green
            B: 0x0000FF, // Blue
            R: 0xFF0000, // Red
            L: 0xFF9900  // Orange
        };
        
        // Color names for display
        const COLOR_NAMES = {
            U: 'White',
            D: 'Yellow',
            F: 'Green',
            B: 'Blue',
            R: 'Red',
            L: 'Orange'
        };
        
        // WCA Notation mapping
        const WCA_MOVES = {
            // Basic face moves
            'R': { axis: 'x', layer: 2, direction: 1, slices: 1 },
            'R\'': { axis: 'x', layer: 2, direction: -1, slices: 1 },
            'R2': { axis: 'x', layer: 2, direction: 1, slices: 2 },
            'L': { axis: 'x', layer: 0, direction: -1, slices: 1 },
            'L\'': { axis: 'x', layer: 0, direction: 1, slices: 1 },
            'L2': { axis: 'x', layer: 0, direction: -1, slices: 2 },
            'U': { axis: 'y', layer: 2, direction: 1, slices: 1 },
            'U\'': { axis: 'y', layer: 2, direction: -1, slices: 1 },
            'U2': { axis: 'y', layer: 2, direction: 1, slices: 2 },
            'D': { axis: 'y', layer: 0, direction: -1, slices: 1 },
            'D\'': { axis: 'y', layer: 0, direction: 1, slices: 1 },
            'D2': { axis: 'y', layer: 0, direction: -1, slices: 2 },
            'F': { axis: 'z', layer: 2, direction: 1, slices: 1 },
            'F\'': { axis: 'z', layer: 2, direction: -1, slices: 1 },
            'F2': { axis: 'z', layer: 2, direction: 1, slices: 2 },
            'B': { axis: 'z', layer: 0, direction: -1, slices: 1 },
            'B\'': { axis: 'z', layer: 0, direction: 1, slices: 1 },
            'B2': { axis: 'z', layer: 0, direction: -1, slices: 2 },
            
            // Slice moves
            'M': { axis: 'x', layer: 1, direction: -1, slices: 1 },
            'M\'': { axis: 'x', layer: 1, direction: 1, slices: 1 },
            'M2': { axis: 'x', layer: 1, direction: -1, slices: 2 },
            'E': { axis: 'y', layer: 1, direction: -1, slices: 1 },
            'E\'': { axis: 'y', layer: 1, direction: 1, slices: 1 },
            'E2': { axis: 'y', layer: 1, direction: -1, slices: 2 },
            'S': { axis: 'z', layer: 1, direction: 1, slices: 1 },
            'S\'': { axis: 'z', layer: 1, direction: -1, slices: 1 },
            'S2': { axis: 'z', layer: 1, direction: 1, slices: 2 },
            
            // Wide moves
            'r': { axis: 'x', layer: 2, direction: 1, slices: 1, wide: true },
            'r\'': { axis: 'x', layer: 2, direction: -1, slices: 1, wide: true },
            'r2': { axis: 'x', layer: 2, direction: 1, slices: 2, wide: true },
            'l': { axis: 'x', layer: 0, direction: -1, slices: 1, wide: true },
            'l\'': { axis: 'x', layer: 0, direction: 1, slices: 1, wide: true },
            'l2': { axis: 'x', layer: 0, direction: -1, slices: 2, wide: true },
            
            // Cube rotations
            'x': { rotation: 'x', direction: 1 },
            'x\'': { rotation: 'x', direction: -1 },
            'y': { rotation: 'y', direction: 1 },
            'y\'': { rotation: 'y', direction: -1 },
            'z': { rotation: 'z', direction: 1 },
            'z\'': { rotation: 'z', direction: -1 }
        };
        
        // Initialize the application
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
            camera.position.set(12, 10, 12);
            
            // Create renderer
            const canvas = document.getElementById('cube-canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 30;
            
            // Setup lighting
            setupAdvancedLighting();
            
            // Initialize cube
            initializeCube();
            
            // Setup UI
            generateFaceControls();
            populateAlgorithms();
            setupEventListeners();
            
            // Start animation loop
            animate();
            
            // Start timer
            startTimer();
        }
        
        // Setup advanced lighting system
        function setupAdvancedLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.9);
            mainLight.position.set(15, 25, 15);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            scene.add(mainLight);
            
            // Fill light
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
            
            // Rim light
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(-5, -5, 10);
            scene.add(rimLight);
            
            // Accent light
            const accentLight = new THREE.PointLight(0x3498db, 0.5, 50);
            accentLight.position.set(5, 15, 5);
            scene.add(accentLight);
        }
        
        // Initialize the cube with mathematical color tracking
        function initializeCube() {
            // Remove existing cube if present
            if (cubeGroup) {
                scene.remove(cubeGroup);
            }
            
            // Create new cube group
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            // Initialize 3D array for cube state
            cubeState.pieces = new Array(CUBE_SIZE);
            for (let x = 0; x < CUBE_SIZE; x++) {
                cubeState.pieces[x] = new Array(CUBE_SIZE);
                for (let y = 0; y < CUBE_SIZE; y++) {
                    cubeState.pieces[x][y] = new Array(CUBE_SIZE);
                    for (let z = 0; z < CUBE_SIZE; z++) {
                        // Skip center core
                        if (x === 1 && y === 1 && z === 1) continue;
                        
                        // Create piece with accurate color tracking
                        const piece = createCubePiece(x, y, z);
                        cubeState.pieces[x][y][z] = piece;
                        cubeGroup.add(piece.mesh);
                    }
                }
            }
            
            // Reset state
            cubeState.history = [];
            cubeState.isSolving = false;
            updateDisplay();
        }
        
        // Create a single cube piece with accurate color tracking
        function createCubePiece(x, y, z) {
            // Determine piece type and colors
            const pieceData = {
                position: { x, y, z },
                logicalPos: { x: x - 1, y: y - 1, z: z - 1 },
                colors: getPieceColors(x, y, z),
                orientation: { x: 0, y: 0, z: 0 },
                type: getPieceType(x, y, z)
            };
            
            // Create materials with proper colors
            const materials = createPieceMaterials(pieceData.colors);
            
            // Create geometry
            const geometry = new THREE.BoxGeometry(PIECE_SIZE, PIECE_SIZE, PIECE_SIZE);
            
            // Increase geometry detail for better visuals
            geometry.computeVertexNormals();
            
            // Create mesh
            const mesh = new THREE.Mesh(geometry, materials);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Position piece
            mesh.position.set(
                pieceData.logicalPos.x * TOTAL_SIZE,
                pieceData.logicalPos.y * TOTAL_SIZE,
                pieceData.logicalPos.z * TOTAL_SIZE
            );
            
            // Store reference to piece data
            mesh.userData = pieceData;
            
            return { mesh, data: pieceData };
        }
        
        // Get colors for a piece based on position
        function getPieceColors(x, y, z) {
            const colors = {
                R: null, L: null, U: null, D: null, F: null, B: null
            };
            
            // Determine which faces are visible
            if (x === CUBE_SIZE - 1) colors.R = 'R';
            if (x === 0) colors.L = 'L';
            if (y === CUBE_SIZE - 1) colors.U = 'U';
            if (y === 0) colors.D = 'D';
            if (z === CUBE_SIZE - 1) colors.F = 'F';
            if (z === 0) colors.B = 'B';
            
            return colors;
        }
        
        // Create materials for piece faces
        function createPieceMaterials(colorFaces) {
            const materials = [];
            const faceOrder = ['R', 'L', 'U', 'D', 'F', 'B'];
            
            faceOrder.forEach(face => {
                if (colorFaces[face]) {
                    // Visible face with color
                    const color = CUBE_COLORS[colorFaces[face]];
                    materials.push(new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.3,
                        metalness: 0.2,
                        emissive: new THREE.Color(color).multiplyScalar(0.1),
                        emissiveIntensity: 0.5
                    }));
                } else {
                    // Internal face (black)
                    materials.push(new THREE.MeshStandardMaterial({
                        color: 0x111111,
                        roughness: 0.8,
                        metalness: 0.1
                    }));
                }
            });
            
            return materials;
        }
        
        // Get piece type (corner, edge, or center)
        function getPieceType(x, y, z) {
            const isCorner = [0, CUBE_SIZE - 1].includes(x) && 
                            [0, CUBE_SIZE - 1].includes(y) && 
                            [0, CUBE_SIZE - 1].includes(z);
            const isEdge = ([0, CUBE_SIZE - 1].includes(x) && [0, CUBE_SIZE - 1].includes(y)) ||
                          ([0, CUBE_SIZE - 1].includes(x) && [0, CUBE_SIZE - 1].includes(z)) ||
                          ([0, CUBE_SIZE - 1].includes(y) && [0, CUBE_SIZE - 1].includes(z));
            
            return isCorner ? 'corner' : isEdge ? 'edge' : 'center';
        }
        
        // Generate face control buttons
        function generateFaceControls() {
            const faceControls = document.getElementById('face-controls');
            faceControls.innerHTML = '';
            
            const faces = [
                { notation: 'R', name: 'Right', color: '#FF0000' },
                { notation: 'L', name: 'Left', color: '#FF9900' },
                { notation: 'U', name: 'Up', color: '#FFFFFF' },
                { notation: 'D', name: 'Down', color: '#FFFF00' },
                { notation: 'F', name: 'Front', color: '#00FF00' },
                { notation: 'B', name: 'Back', color: '#0000FF' }
            ];
            
            faces.forEach(face => {
                // Clockwise button
                const cwBtn = document.createElement('button');
                cwBtn.className = 'face-btn';
                cwBtn.innerHTML = `
                    <div class="face-color" style="background: ${face.color};"></div>
                    <span>${face.notation}</span>
                    <small><i class="fas fa-redo"></i></small>
                `;
                cwBtn.onclick = () => performMove(face.notation);
                faceControls.appendChild(cwBtn);
                
                // Counter-clockwise button
                const ccwBtn = document.createElement('button');
                ccwBtn.className = 'face-btn';
                ccwBtn.innerHTML = `
                    <div class="face-color" style="background: ${face.color};"></div>
                    <span>${face.notation}'</span>
                    <small><i class="fas fa-undo"></i></small>
                `;
                ccwBtn.onclick = () => performMove(face.notation + "'");
                faceControls.appendChild(ccwBtn);
                
                // Double turn button
                const dblBtn = document.createElement('button');
                dblBtn.className = 'face-btn';
                dblBtn.innerHTML = `
                    <div class="face-color" style="background: ${face.color};"></div>
                    <span>${face.notation}2</span>
                    <small><i class="fas fa-retweet"></i></small>
                `;
                dblBtn.onclick = () => performMove(face.notation + '2');
                faceControls.appendChild(dblBtn);
            });
        }
        
        // Populate algorithm list
        function populateAlgorithms() {
            const algorithmList = document.getElementById('algorithm-list');
            
            const algorithms = [
                {
                    name: "Sexy Move",
                    moves: "R U R' U'",
                    category: "basic",
                    description: "Most common algorithm"
                },
                {
                    name: "Sune",
                    moves: "R U R' U R U2 R'",
                    category: "oll",
                    description: "OLL algorithm"
                },
                {
                    name: "Anti-Sune",
                    moves: "R U2 R' U' R U' R'",
                    category: "oll",
                    description: "OLL algorithm"
                },
                {
                    name: "T-Permutation",
                    moves: "R U R' U' R' F R2 U' R' U' R U R' F'",
                    category: "pll",
                    description: "Swaps two corners and two edges"
                },
                {
                    name: "Y-Permutation",
                    moves: "F R U' R' U' R U R' F' R U R' U' R' F R F'",
                    category: "pll",
                    description: "Cycles three corners"
                },
                {
                    name: "H-Permutation",
                    moves: "M2 U M2 U2 M2 U M2",
                    category: "pll",
                    description: "Swaps opposite edges"
                },
                {
                    name: "U-Permutation (a)",
                    moves: "R U' R U R U R U' R' U' R2",
                    category: "pll",
                    description: "Cycles three edges clockwise"
                },
                {
                    name: "U-Permutation (b)",
                    moves: "R2 U R U R' U' R' U' R' U R'",
                    category: "pll",
                    description: "Cycles three edges counter-clockwise"
                }
            ];
            
            algorithmList.innerHTML = '';
            
            algorithms.forEach(alg => {
                const item = document.createElement('div');
                item.className = 'algorithm-item';
                item.innerHTML = `
                    <div class="algorithm-name">
                        <span>${alg.name}</span>
                        <span style="color: ${alg.category === 'oll' ? '#3498db' : alg.category === 'pll' ? '#9b59b6' : '#2ecc71'}; 
                              font-size: 0.8rem; text-transform: uppercase;">
                            ${alg.category}
                        </span>
                    </div>
                    <div class="algorithm-moves">${alg.moves}</div>
                `;
                item.onclick = () => {
                    document.getElementById('notation-input').value = alg.moves;
                };
                algorithmList.appendChild(item);
            });
        }
        
        // Perform a move with animation
        async function performMove(notation) {
            if (isAnimating || cubeState.isSolving) return;
            
            const move = parseNotation(notation);
            if (!move) {
                console.error('Invalid move:', notation);
                return;
            }
            
            isAnimating = true;
            
            if (move.rotation) {
                // Cube rotation
                await rotateCube(move);
            } else {
                // Face/slice rotation
                await rotateFace(move);
            }
            
            // Update move history
            cubeState.history.push(notation);
            
            // Update display
            updateDisplay();
            
            isAnimating = false;
        }
        
        // Parse WCA notation
        function parseNotation(notation) {
            notation = notation.trim();
            return WCA_MOVES[notation];
        }
        
        // Rotate a face or slice
        async function rotateFace(move) {
            const { axis, layer, direction, slices } = move;
            const wide = move.wide || false;
            
            // Get pieces to rotate
            const pieces = getPiecesForMove(axis, layer, wide);
            
            // Create animation group
            const animationGroup = new THREE.Group();
            pieces.forEach(piece => {
                const clone = piece.mesh.clone();
                clone.position.copy(piece.mesh.position);
                clone.rotation.copy(piece.mesh.rotation);
                clone.userData = JSON.parse(JSON.stringify(piece.mesh.userData));
                animationGroup.add(clone);
                piece.mesh.visible = false;
            });
            
            scene.add(animationGroup);
            
            // Animate rotation
            const axisVector = getAxisVector(axis);
            const totalAngle = direction * (Math.PI / 2) * slices;
            
            await animateRotation(animationGroup, axisVector, totalAngle, 300);
            
            // Update piece positions and orientations
            updatePiecePositions(axis, layer, direction, slices, wide);
            
            // Update cube state
            updateCubeStateAfterMove();
            
            // Clean up animation
            scene.remove(animationGroup);
            pieces.forEach(piece => {
                piece.mesh.visible = true;
                // Update piece mesh rotation
                piece.mesh.rotateOnWorldAxis(axisVector, totalAngle);
            });
        }
        
        // Get pieces affected by a move
        function getPiecesForMove(axis, layer, wide) {
            const pieces = [];
            
            for (let x = 0; x < CUBE_SIZE; x++) {
                for (let y = 0; y < CUBE_SIZE; y++) {
                    for (let z = 0; z < CUBE_SIZE; z++) {
                        if (isPieceInMove(x, y, z, axis, layer, wide)) {
                            const piece = getPieceAt(x, y, z);
                            if (piece) pieces.push(piece);
                        }
                    }
                }
            }
            
            return pieces;
        }
        
        // Check if piece is in move
        function isPieceInMove(x, y, z, axis, layer, wide) {
            switch(axis) {
                case 'x':
                    if (wide) return x >= layer;
                    return x === layer;
                case 'y':
                    if (wide) return y >= layer;
                    return y === layer;
                case 'z':
                    if (wide) return z >= layer;
                    return z === layer;
                default:
                    return false;
            }
        }
        
        // Get piece at coordinates
        function getPieceAt(x, y, z) {
            if (x === 1 && y === 1 && z === 1) return null; // Center core
            const pieceObj = cubeState.pieces[x][y][z];
            return pieceObj ? { mesh: pieceObj.mesh, data: pieceObj.data } : null;
        }
        
        // Get axis vector
        function getAxisVector(axis) {
            switch(axis) {
                case 'x': return new THREE.Vector3(1, 0, 0);
                case 'y': return new THREE.Vector3(0, 1, 0);
                case 'z': return new THREE.Vector3(0, 0, 1);
                default: return new THREE.Vector3(0, 1, 0);
            }
        }
        
        // Animate rotation with easing
        function animateRotation(group, axis, angle, duration) {
            return new Promise(resolve => {
                const steps = 60;
                const stepAngle = angle / steps;
                const stepDuration = duration / steps;
                
                let step = 0;
                
                function animateStep() {
                    if (step < steps) {
                        group.rotateOnWorldAxis(axis, stepAngle);
                        step++;
                        setTimeout(animateStep, stepDuration);
                    } else {
                        resolve();
                    }
                }
                
                animateStep();
            });
        }
        
        // Update piece positions after move (mathematical permutation)
        function updatePiecePositions(axis, layer, direction, slices, wide) {
            // This is a simplified implementation
            // In a complete system, you would implement full permutation logic
            
            console.log(`Updating positions for ${axis}${layer}${direction > 0 ? '' : "'"}${slices > 1 ? '2' : ''}`);
            
            // For now, we'll just rotate the pieces in the cubeState array
            // This is where you would implement the actual Rubik's Cube permutation mathematics
        }
        
        // Update cube state after move
        function updateCubeStateAfterMove() {
            // Update cube state tracking
            // This would include updating the 3D array representation
        }
        
        // Rotate entire cube
        async function rotateCube(move) {
            const { rotation, direction } = move;
            const axis = getAxisVector(rotation);
            const angle = direction * (Math.PI / 2);
            
            await animateRotation(cubeGroup, axis, angle, 400);
            
            // Update cube orientation
            updateCubeOrientation(rotation, direction);
        }
        
        // Update cube orientation
        function updateCubeOrientation(axis, direction) {
            // Track cube orientation for solving algorithms
            cubeState.orientation[axis] = (cubeState.orientation[axis] + direction + 4) % 4;
        }
        
        // Execute algorithm
        async function executeAlgorithm(algorithm) {
            const moves = algorithm.trim().split(/\s+/);
            
            for (const move of moves) {
                await performMove(move);
                await sleep(150); // Delay between moves
            }
        }
        
        // Sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // Scramble the cube
        async function scrambleCube() {
            if (isAnimating || cubeState.isSolving) return;
            
            const moves = [
                'R', 'L', 'U', 'D', 'F', 'B',
                'R\'', 'L\'', 'U\'', 'D\'', 'F\'', 'B\'',
                'R2', 'L2', 'U2', 'D2', 'F2', 'B2'
            ];
            
            const scramble = [];
            const length = 25;
            
            // Generate scramble
            for (let i = 0; i < length; i++) {
                let move;
                do {
                    move = moves[Math.floor(Math.random() * moves.length)];
                } while (i > 0 && isRedundant(scramble[i-1], move));
                
                scramble.push(move);
            }
            
            // Execute scramble
            for (const move of scramble) {
                await performMove(move);
                await sleep(100);
            }
        }
        
        // Check for redundant moves
        function isRedundant(prev, curr) {
            if (!prev || !curr) return false;
            return prev[0] === curr[0];
        }
        
        // Start auto-solving
        async function startSolving(method = 'cfop') {
            if (isAnimating || cubeState.isSolving) return;
            
            cubeState.isSolving = true;
            cubeState.solvingStep = 0;
            cubeState.totalSteps = 0;
            cubeState.solution = [];
            
            // Show progress
            document.getElementById('solving-progress').style.display = 'block';
            
            // Generate solution based on method
            switch(method) {
                case 'cfop':
                    cubeState.solution = generateCFOPSolution();
                    break;
                case 'beginner':
                    cubeState.solution = generateBeginnerSolution();
                    break;
                case 'optimal':
                    cubeState.solution = generateOptimalSolution();
                    break;
            }
            
            cubeState.totalSteps = cubeState.solution.length;
            
            // Execute solution
            for (let i = 0; i < cubeState.solution.length; i++) {
                if (!cubeState.isSolving) break;
                
                const move = cubeState.solution[i];
                await performMove(move);
                
                // Update progress
                cubeState.solvingStep = i + 1;
                updateSolvingProgress();
                
                await sleep(200);
            }
            
            cubeState.isSolving = false;
            document.getElementById('solving-progress').style.display = 'none';
        }
        
        // Generate CFOP solution
        function generateCFOPSolution() {
            // Simplified CFOP solution
            // In a real implementation, this would analyze the cube state
            return [
                "R", "U", "R'", "U'", "R'", "F", "R", "F'", // OLL
                "R", "U", "R'", "U'", "R'", "F", "R2", "U'", "R'", "U'", "R", "U", "R'", "F'" // PLL
            ];
        }
        
        // Generate beginner solution
        function generateBeginnerSolution() {
            return [
                "R", "U", "R'", "U'",
                "F'", "U'", "F", "U",
                "R", "U2", "R'", "U'",
                "R", "U", "R'"
            ];
        }
        
        // Generate optimal solution
        function generateOptimalSolution() {
            // Thistlethwaite's algorithm or Kociemba's algorithm would go here
            return [
                "R", "U2", "R'", "F'", "U'", "F",
                "R", "U", "R'", "U'", "R'", "F", "R", "F'"
            ];
        }
        
        // Update solving progress display
        function updateSolvingProgress() {
            const progress = (cubeState.solvingStep / cubeState.totalSteps) * 100;
            document.getElementById('progress-fill').style.width = `${progress}%`;
            document.getElementById('progress-step').textContent = 
                `Step ${cubeState.solvingStep} of ${cubeState.totalSteps}`;
            document.getElementById('progress-percent').textContent = 
                `${Math.round(progress)}%`;
        }
        
        // Update display elements
        function updateDisplay() {
            document.getElementById('move-count').textContent = cubeState.history.length;
            document.getElementById('cube-state').textContent = 
                cubeState.history.length === 0 ? 'SOLVED' : 'SCRAMBLED';
        }
        
        // Start timer
        function startTimer() {
            cubeState.startTime = Date.now();
            
            cubeState.timer = setInterval(() => {
                const elapsed = Date.now() - cubeState.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                const milliseconds = Math.floor((elapsed % 1000) / 10);
                
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;
            }, 10);
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Mode selector
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    // Update controls based on mode
                    updateControlsForMode(btn.dataset.mode);
                });
            });
            
            // Control buttons
            document.getElementById('scramble-btn').addEventListener('click', scrambleCube);
            document.getElementById('solve-btn').addEventListener('click', () => startSolving('cfop'));
            document.getElementById('reset-btn').addEventListener('click', initializeCube);
            
            // Solve method buttons
            document.getElementById('cfop-btn').addEventListener('click', () => startSolving('cfop'));
            document.getElementById('beginner-btn').addEventListener('click', () => startSolving('beginner'));
            document.getElementById('optimal-btn').addEventListener('click', () => startSolving('optimal'));
            
            // Notation execution
            document.getElementById('execute-btn').addEventListener('click', async () => {
                const notation = document.getElementById('notation-input').value;
                if (notation) {
                    await executeAlgorithm(notation);
                }
            });
            
            document.getElementById('reverse-btn').addEventListener('click', async () => {
                const notation = document.getElementById('notation-input').value;
                if (notation) {
                    // Reverse the algorithm
                    const moves = notation.trim().split(/\s+/).reverse();
                    const reversed = moves.map(move => {
                        if (move.endsWith("'")) return move.slice(0, -1);
                        if (move.endsWith("2")) return move;
                        return move + "'";
                    }).join(' ');
                    
                    await executeAlgorithm(reversed);
                }
            });
            
            // Enter key for notation input
            document.getElementById('notation-input').addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const notation = document.getElementById('notation-input').value;
                    if (notation) {
                        await executeAlgorithm(notation);
                    }
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                const canvas = document.getElementById('cube-canvas');
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            });
        }
        
        // Update controls based on mode
        function updateControlsForMode(mode) {
            // This would change which controls are visible based on mode
            console.log('Switched to mode:', mode);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>