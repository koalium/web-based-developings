<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Geometric Objects Falling Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #1a2980, #26d0ce);
            font-family: Arial, sans-serif;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .control-panel label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
        <div id="info">
            <div>Objects: <span id="objectCount">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
        <div class="control-panel">
            <label>
                <input type="range" id="creationRate" min="0.8" max="1.25" step="0.05" value="1.0">
                Creation Rate
            </label>
            <label>
                <input type="range" id="gravity" min="0.1" max="2.0" step="0.1" value="0.5">
                Gravity
            </label>
            <label>
                <input type="range" id="forceRadius" min="100" max="500" step="10" value="250">
                Force Radius
            </label>
        </div>
    </div>

    <script>
        // Main canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Performance tracking
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        // Control elements
        const objectCountElement = document.getElementById('objectCount');
        const fpsElement = document.getElementById('fps');
        const creationRateSlider = document.getElementById('creationRate');
        const gravitySlider = document.getElementById('gravity');
        const forceRadiusSlider = document.getElementById('forceRadius');

        // Physics constants
        const GRAVITY_BASE = 0.5;
        let gravity = GRAVITY_BASE;
        let creationRate = 1.0;
        let forceRadius = 250;

        // Object management
        let objects = [];
        let objectIdCounter = 0;

        // Force center management
        let forceCenter = { x: 0, y: 0 };
        let lastForceCenterTime = 0;

        // Object types
        const OBJECT_TYPES = {
            PYRAMID: 'pyramid',
            CUBE: 'cube',
            PENTAHEDRON: 'pentahedron',
            SPHERE: 'sphere'
        };

        // Color palettes for objects
        const COLOR_PALETTES = [
            ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A'],
            ['#6A0572', '#AB83A1', '#3C3B6E', '#B22234'],
            ['#2A9D8F', '#E9C46A', '#F4A261', '#E76F51'],
            ['#264653', '#2A9D8F', '#E9C46A', '#F4A261']
        ];

        // 3D Geometry class
        class Geometry3D {
            constructor(type, size, color, opacity) {
                this.type = type;
                this.size = size;
                this.color = color;
                this.opacity = opacity;
                this.vertices = [];
                this.edges = [];
                this.faces = [];
                
                this.generateGeometry();
            }
            
            generateGeometry() {
                switch(this.type) {
                    case OBJECT_TYPES.PYRAMID:
                        this.generatePyramid();
                        break;
                    case OBJECT_TYPES.CUBE:
                        this.generateCube();
                        break;
                    case OBJECT_TYPES.PENTAHEDRON:
                        this.generatePentahedron();
                        break;
                    case OBJECT_TYPES.SPHERE:
                        this.generateSphere();
                        break;
                }
            }
            
            generatePyramid() {
                // Square pyramid
                const h = this.size * 1.5;
                const s = this.size;
                
                this.vertices = [
                    { x: 0, y: -h/2, z: 0 },  // Apex
                    { x: -s, y: h/2, z: -s }, // Base vertices
                    { x: s, y: h/2, z: -s },
                    { x: s, y: h/2, z: s },
                    { x: -s, y: h/2, z: s }
                ];
                
                this.edges = [
                    [0, 1], [0, 2], [0, 3], [0, 4], // Apex to base
                    [1, 2], [2, 3], [3, 4], [4, 1]  // Base edges
                ];
                
                this.faces = [
                    { vertices: [0, 1, 2], color: this.color },
                    { vertices: [0, 2, 3], color: this.color },
                    { vertices: [0, 3, 4], color: this.color },
                    { vertices: [0, 4, 1], color: this.color },
                    { vertices: [1, 2, 3, 4], color: this.color }
                ];
            }
            
            generateCube() {
                const s = this.size;
                
                this.vertices = [
                    { x: -s, y: -s, z: -s },
                    { x: s, y: -s, z: -s },
                    { x: s, y: s, z: -s },
                    { x: -s, y: s, z: -s },
                    { x: -s, y: -s, z: s },
                    { x: s, y: -s, z: s },
                    { x: s, y: s, z: s },
                    { x: -s, y: s, z: s }
                ];
                
                this.edges = [
                    [0, 1], [1, 2], [2, 3], [3, 0], // Front face
                    [4, 5], [5, 6], [6, 7], [7, 4], // Back face
                    [0, 4], [1, 5], [2, 6], [3, 7]  // Connecting edges
                ];
                
                this.faces = [
                    { vertices: [0, 1, 2, 3], color: this.color },
                    { vertices: [4, 5, 6, 7], color: this.color },
                    { vertices: [0, 1, 5, 4], color: this.color },
                    { vertices: [2, 3, 7, 6], color: this.color },
                    { vertices: [0, 3, 7, 4], color: this.color },
                    { vertices: [1, 2, 6, 5], color: this.color }
                ];
            }
            
            generatePentahedron() {
                // Triangular prism (simplified pentahedron)
                const w = this.size;
                const h = this.size * 1.5;
                
                this.vertices = [
                    { x: 0, y: -h/2, z: w },     // Top triangle
                    { x: -w, y: -h/2, z: -w/2 },
                    { x: w, y: -h/2, z: -w/2 },
                    { x: 0, y: h/2, z: w },      // Bottom triangle
                    { x: -w, y: h/2, z: -w/2 },
                    { x: w, y: h/2, z: -w/2 }
                ];
                
                this.edges = [
                    [0, 1], [1, 2], [2, 0], // Top triangle
                    [3, 4], [4, 5], [5, 3], // Bottom triangle
                    [0, 3], [1, 4], [2, 5]  // Connecting edges
                ];
                
                this.faces = [
                    { vertices: [0, 1, 2], color: this.color },
                    { vertices: [3, 4, 5], color: this.color },
                    { vertices: [0, 1, 4, 3], color: this.color },
                    { vertices: [1, 2, 5, 4], color: this.color },
                    { vertices: [2, 0, 3, 5], color: this.color }
                ];
            }
            
            generateSphere() {
                // Create a sphere using recursive subdivision of an icosahedron
                const radius = this.size;
                const subdivisions = 2;
                
                // Icosahedron vertices (12 vertices)
                const t = (1.0 + Math.sqrt(5.0)) / 2.0;
                
                this.vertices = [
                    { x: -1, y: t, z: 0 }, { x: 1, y: t, z: 0 },
                    { x: -1, y: -t, z: 0 }, { x: 1, y: -t, z: 0 },
                    { x: 0, y: -1, z: t }, { x: 0, y: 1, z: t },
                    { x: 0, y: -1, z: -t }, { x: 0, y: 1, z: -t },
                    { x: t, y: 0, z: -1 }, { x: t, y: 0, z: 1 },
                    { x: -t, y: 0, z: -1 }, { x: -t, y: 0, z: 1 }
                ];
                
                // Normalize vertices to unit sphere
                this.vertices.forEach(v => {
                    const length = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
                    v.x /= length;
                    v.y /= length;
                    v.z /= length;
                });
                
                // Icosahedron faces (20 faces)
                const faces = [
                    [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                    [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                    [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                    [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
                ];
                
                // Subdivide faces
                for (let i = 0; i < subdivisions; i++) {
                    const newFaces = [];
                    
                    faces.forEach(face => {
                        const v0 = this.vertices[face[0]];
                        const v1 = this.vertices[face[1]];
                        const v2 = this.vertices[face[2]];
                        
                        // Calculate midpoints
                        const m01 = {
                            x: (v0.x + v1.x) / 2,
                            y: (v0.y + v1.y) / 2,
                            z: (v0.z + v1.z) / 2
                        };
                        
                        const m12 = {
                            x: (v1.x + v2.x) / 2,
                            y: (v1.y + v2.y) / 2,
                            z: (v1.z + v2.z) / 2
                        };
                        
                        const m20 = {
                            x: (v2.x + v0.x) / 2,
                            y: (v2.y + v0.y) / 2,
                            z: (v2.z + v0.z) / 2
                        };
                        
                        // Normalize midpoints to unit sphere
                        [m01, m12, m20].forEach(v => {
                            const length = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
                            v.x /= length;
                            v.y /= length;
                            v.z /= length;
                        });
                        
                        // Add new vertices
                        const i01 = this.vertices.length;
                        this.vertices.push(m01);
                        const i12 = this.vertices.length;
                        this.vertices.push(m12);
                        const i20 = this.vertices.length;
                        this.vertices.push(m20);
                        
                        // Create 4 new faces
                        newFaces.push([face[0], i01, i20]);
                        newFaces.push([face[1], i12, i01]);
                        newFaces.push([face[2], i20, i12]);
                        newFaces.push([i01, i12, i20]);
                    });
                    
                    faces.length = 0;
                    faces.push(...newFaces);
                }
                
                // Scale vertices to desired size
                this.vertices.forEach(v => {
                    v.x *= radius;
                    v.y *= radius;
                    v.z *= radius;
                });
                
                // Create edges from faces
                const edgeSet = new Set();
                faces.forEach(face => {
                    for (let i = 0; i < face.length; i++) {
                        const a = face[i];
                        const b = face[(i + 1) % face.length];
                        const edge = [Math.min(a, b), Math.max(a, b)];
                        edgeSet.add(edge.join(','));
                    }
                });
                
                this.edges = Array.from(edgeSet).map(edgeStr => 
                    edgeStr.split(',').map(Number)
                );
                
                // Create faces for rendering
                this.faces = faces.map(face => ({
                    vertices: face,
                    color: this.color
                }));
            }
        }

        // FallingObject class
        class FallingObject {
            constructor() {
                this.id = objectIdCounter++;
                this.type = this.getRandomType();
                this.size = Math.random() * 20 + 10;
                this.color = this.getRandomColor();
                this.opacity = Math.random() * 0.7 + 0.3;
                
                // Position and velocity
                this.x = Math.random() * canvas.width;
                this.y = -this.size;
                this.z = Math.random() * 1000 - 500; // Depth for 3D effect
                this.vx = 0;
                this.vy = Math.random() * 2 + 1;
                this.vz = 0;
                
                // Rotation
                this.rotation = {
                    x: Math.random() * Math.PI * 2,
                    y: Math.random() * Math.PI * 2,
                    z: Math.random() * Math.PI * 2
                };
                
                this.rotationSpeed = {
                    x: (Math.random() - 0.5) * 0.05,
                    y: (Math.random() - 0.5) * 0.05,
                    z: (Math.random() - 0.5) * 0.05
                };
                
                this.rotationCenter = {
                    x: (Math.random() - 0.5) * this.size,
                    y: (Math.random() - 0.5) * this.size,
                    z: (Math.random() - 0.5) * this.size
                };
                
                this.lastRotationChange = 0;
                
                // Create 3D geometry
                this.geometry = new Geometry3D(this.type, this.size, this.color, this.opacity);
                
                // Collision properties
                this.collided = false;
                this.collisionTime = 0;
                this.collisionEffect = null;
                
                // Force effect
                this.forceApplied = false;
            }
            
            getRandomType() {
                const types = Object.values(OBJECT_TYPES);
                return types[Math.floor(Math.random() * types.length)];
            }
            
            getRandomColor() {
                const palette = COLOR_PALETTES[Math.floor(Math.random() * COLOR_PALETTES.length)];
                return palette[Math.floor(Math.random() * palette.length)];
            }
            
            updateRotation() {
                // Change rotation speed smoothly (max 10% change)
                const now = performance.now();
                if (now - this.lastRotationChange > 1000) { // Change every second
                    this.rotationSpeed.x += (Math.random() - 0.5) * this.rotationSpeed.x * 0.2;
                    this.rotationSpeed.y += (Math.random() - 0.5) * this.rotationSpeed.y * 0.2;
                    this.rotationSpeed.z += (Math.random() - 0.5) * this.rotationSpeed.z * 0.2;
                    
                    // Change rotation center smoothly
                    this.rotationCenter.x += (Math.random() - 0.5) * this.size * 0.1;
                    this.rotationCenter.y += (Math.random() - 0.5) * this.size * 0.1;
                    this.rotationCenter.z += (Math.random() - 0.5) * this.size * 0.1;
                    
                    this.lastRotationChange = now;
                }
                
                // Apply rotation
                this.rotation.x += this.rotationSpeed.x;
                this.rotation.y += this.rotationSpeed.y;
                this.rotation.z += this.rotationSpeed.z;
            }
            
            applyForce(centerX, centerY) {
                if (this.forceApplied) return;
                
                const dx = this.x - centerX;
                const dy = this.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < forceRadius) {
                    // Apply force away from center
                    const force = 0.5;
                    const angle = Math.atan2(dy, dx);
                    
                    this.vx += Math.cos(angle) * force;
                    this.vy += Math.sin(angle) * force;
                    
                    this.forceApplied = true;
                }
            }
            
            update() {
                // Apply gravity
                this.vy += gravity;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;
                
                // Update rotation
                this.updateRotation();
                
                // Reset force applied flag after some time
                if (this.forceApplied && Math.random() < 0.01) {
                    this.forceApplied = false;
                }
                
                // Check if object is out of bounds
                return this.y < canvas.height + this.size * 2;
            }
            
            draw() {
                // Don't draw if object is too far behind
                if (this.z < -1000) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Apply perspective
                const scale = 1000 / (1000 + this.z);
                ctx.scale(scale, scale);
                
                // Apply rotation
                ctx.translate(this.rotationCenter.x, this.rotationCenter.y);
                ctx.rotate(this.rotation.z);
                ctx.translate(-this.rotationCenter.x, -this.rotationCenter.y);
                
                // Set opacity
                ctx.globalAlpha = this.opacity;
                
                // Draw faces with gradient for 3D effect
                this.geometry.faces.forEach(face => {
                    ctx.beginPath();
                    
                    // Get vertices for this face
                    const vertices = face.vertices.map(idx => this.geometry.vertices[idx]);
                    
                    // Calculate face normal for lighting
                    const v0 = vertices[0];
                    const v1 = vertices[1];
                    const v2 = vertices[2];
                    
                    const ux = v1.x - v0.x;
                    const uy = v1.y - v0.y;
                    const uz = v1.z - v0.z;
                    
                    const vx = v2.x - v0.x;
                    const vy = v2.y - v0.y;
                    const vz = v2.z - v0.z;
                    
                    const nx = uy * vz - uz * vy;
                    const ny = uz * vx - ux * vz;
                    const nz = ux * vy - uy * vx;
                    
                    // Normalize normal vector
                    const length = Math.sqrt(nx*nx + ny*ny + nz*nz);
                    const normalX = nx / length;
                    const normalY = ny / length;
                    const normalZ = nz / length;
                    
                    // Calculate lighting (simple directional light from top-left)
                    const lightX = -0.5;
                    const lightY = -0.5;
                    const lightZ = -0.5;
                    
                    const dot = normalX * lightX + normalY * lightY + normalZ * lightZ;
                    const intensity = Math.max(0.2, dot);
                    
                    // Create gradient based on lighting
                    const gradient = ctx.createLinearGradient(
                        -this.size, -this.size, this.size, this.size
                    );
                    
                    const baseColor = face.color;
                    gradient.addColorStop(0, this.adjustColorBrightness(baseColor, intensity * 1.5));
                    gradient.addColorStop(1, this.adjustColorBrightness(baseColor, intensity * 0.7));
                    
                    ctx.fillStyle = gradient;
                    
                    // Draw face
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                });
                
                // Draw shiny edges
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                
                this.geometry.edges.forEach(edge => {
                    const v1 = this.geometry.vertices[edge[0]];
                    const v2 = this.geometry.vertices[edge[1]];
                    
                    ctx.beginPath();
                    ctx.moveTo(v1.x, v1.y);
                    ctx.lineTo(v2.x, v2.y);
                    ctx.stroke();
                });
                
                // Draw collision effects
                if (this.collided) {
                    this.drawCollisionEffect();
                }
                
                ctx.restore();
            }
            
            adjustColorBrightness(color, factor) {
                // Convert hex to RGB
                const r = parseInt(color.substr(1, 2), 16);
                const g = parseInt(color.substr(3, 2), 16);
                const b = parseInt(color.substr(5, 2), 16);
                
                // Adjust brightness
                const newR = Math.min(255, Math.floor(r * factor));
                const newG = Math.min(255, Math.floor(g * factor));
                const newB = Math.min(255, Math.floor(b * factor));
                
                // Convert back to hex
                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }
            
            drawCollisionEffect() {
                const now = performance.now();
                const elapsed = now - this.collisionTime;
                const duration = 1000; // 1 second effect
                
                if (elapsed > duration) {
                    this.collided = false;
                    return;
                }
                
                const progress = elapsed / duration;
                const radius = this.size * (1 + progress * 2);
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                switch(this.collisionEffect) {
                    case 'fireball':
                        // Draw fireball explosion
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                        gradient.addColorStop(0, 'rgba(255, 255, 0, 1)');
                        gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'tron':
                        // Draw Tron-like disc
                        ctx.strokeStyle = '#00FFFF';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Draw inner circle
                        ctx.beginPath();
                        ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Draw cross lines
                        ctx.beginPath();
                        ctx.moveTo(-radius, 0);
                        ctx.lineTo(radius, 0);
                        ctx.moveTo(0, -radius);
                        ctx.lineTo(0, radius);
                        ctx.stroke();
                        break;
                        
                    case 'ethereum':
                        // Draw Ethereum logo
                        ctx.strokeStyle = '#627EEA';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        
                        // Draw hexagon
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI / 3) - Math.PI / 6;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Draw inner lines
                        ctx.beginPath();
                        ctx.moveTo(0, -radius * 0.7);
                        ctx.lineTo(0, radius * 0.7);
                        ctx.moveTo(-radius * 0.5, -radius * 0.35);
                        ctx.lineTo(radius * 0.5, radius * 0.35);
                        ctx.moveTo(-radius * 0.5, radius * 0.35);
                        ctx.lineTo(radius * 0.5, -radius * 0.35);
                        ctx.stroke();
                        break;
                        
                    case 'bitcoin':
                        // Draw Bitcoin logo
                        ctx.strokeStyle = '#F7931A';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        
                        // Draw circle
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Draw B symbol
                        ctx.font = `${radius * 0.8}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#F7931A';
                        ctx.fillText('B', 0, 0);
                        break;
                        
                    default:
                        // Draw sparkles
                        for (let i = 0; i < 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const sparkleRadius = radius * (0.5 + Math.random() * 0.5);
                            const x = Math.cos(angle) * sparkleRadius;
                            const y = Math.sin(angle) * sparkleRadius;
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                }
                
                ctx.restore();
            }
            
            checkCollision(other) {
                if (this === other || this.collided || other.collided) return false;
                
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.size + other.size) {
                    // Collision detected
                    this.collided = true;
                    other.collided = true;
                    this.collisionTime = performance.now();
                    other.collisionTime = performance.now();
                    
                    // Determine collision effect
                    const rand = Math.random();
                    if (rand < 0.2) {
                        this.collisionEffect = 'fireball';
                        other.collisionEffect = 'fireball';
                    } else if (rand < 0.52) {
                        this.collisionEffect = 'tron';
                        other.collisionEffect = 'tron';
                    } else if (rand < 0.55) {
                        this.collisionEffect = 'ethereum';
                        other.collisionEffect = 'ethereum';
                    } else if (rand < 0.555) {
                        this.collisionEffect = 'bitcoin';
                        other.collisionEffect = 'bitcoin';
                    } else {
                        this.collisionEffect = 'sparkles';
                        other.collisionEffect = 'sparkles';
                    }
                    
                    // Deflection
                    const angle = Math.atan2(dy, dx);
                    const force = 2;
                    
                    this.vx += Math.cos(angle) * force;
                    this.vy += Math.sin(angle) * force;
                    
                    other.vx -= Math.cos(angle) * force;
                    other.vy -= Math.sin(angle) * force;
                    
                    return true;
                }
                
                return false;
            }
        }

        // Create objects at a controlled rate
        function createObjects() {
            const targetCount = 50 * creationRate;
            
            if (objects.length < targetCount) {
                const toCreate = Math.min(5, targetCount - objects.length);
                
                for (let i = 0; i < toCreate; i++) {
                    objects.push(new FallingObject());
                }
            }
        }

        // Update force center every 2 seconds
        function updateForceCenter() {
            const now = performance.now();
            
            if (now - lastForceCenterTime > 2000) {
                forceCenter.x = Math.random() * canvas.width;
                forceCenter.y = Math.random() * canvas.height;
                lastForceCenterTime = now;
                
                // Apply force to objects near the center
                objects.forEach(obj => {
                    obj.applyForce(forceCenter.x, forceCenter.y);
                });
            }
        }

        // Check for collisions between objects
        function checkCollisions() {
            for (let i = 0; i < objects.length; i++) {
                for (let j = i + 1; j < objects.length; j++) {
                    objects[i].checkCollision(objects[j]);
                }
            }
        }

        // Update and draw all objects
        function updateObjects() {
            // Remove objects that are out of bounds
            objects = objects.filter(obj => obj.update());
            
            // Update object count display
            objectCountElement.textContent = objects.length;
        }

        // Draw force center indicator
        function drawForceCenter() {
            const now = performance.now();
            const elapsed = now - lastForceCenterTime;
            const pulse = Math.sin(elapsed / 200) * 0.5 + 0.5;
            
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
            ctx.beginPath();
            ctx.arc(forceCenter.x, forceCenter.y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = `rgba(255, 255, 0, ${pulse * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(forceCenter.x, forceCenter.y, forceRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        // Main animation loop
        function animate() {
            // Clear canvas with fade effect for motion blur
            ctx.fillStyle = 'rgba(26, 41, 128, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update physics
            updateForceCenter();
            createObjects();
            checkCollisions();
            updateObjects();
            
            // Draw objects
            objects.forEach(obj => obj.draw());
            
            // Draw force center
            drawForceCenter();
            
            // Calculate FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                fpsElement.textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Update settings from sliders
        creationRateSlider.addEventListener('input', () => {
            creationRate = parseFloat(creationRateSlider.value);
        });

        gravitySlider.addEventListener('input', () => {
            gravity = parseFloat(gravitySlider.value);
        });

        forceRadiusSlider.addEventListener('input', () => {
            forceRadius = parseFloat(forceRadiusSlider.value);
        });

        // Start animation
        animate();
    </script>
</body>
</html>