<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Advanced 3-Stage Rocket Simulator</title>
    <style>
        * { 
            margin: 0; padding: 0; box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none; user-select: none;
        }
        
        body { 
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            touch-action: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        /* UI Elements */
        .ui-panel {
            position: absolute;
            background: rgba(0, 15, 30, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid;
            border-radius: 12px;
            padding: 15px;
            z-index: 100;
            transition: all 0.3s;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 280px;
            max-width: 95vw;
        }
        
        .ui-panel.collapsed {
            opacity: 0.3;
            transform: scale(0.9);
            pointer-events: none;
        }
        
        .panel-toggle {
            position: absolute;
            background: rgba(0, 30, 60, 0.9);
            border: 2px solid;
            color: white;
            padding: 10px 15px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 101;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .panel-toggle:hover {
            transform: scale(1.05);
        }
        
        /* Specific Panels */
        #stagePanel {
            top: 80px;
            left: 20px;
            border-color: #ff5500;
            width: 320px;
        }
        
        #controlPanel {
            bottom: 20px;
            left: 20px;
            border-color: #00aaff;
            width: 300px;
        }
        
        #telemetryPanel {
            top: 20px;
            right: 20px;
            border-color: #00ffaa;
            width: 300px;
        }
        
        #fuelPanel {
            bottom: 20px;
            right: 20px;
            border-color: #aa00ff;
            width: 280px;
        }
        
        #rcsPanel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-color: #ffff00;
            display: none;
            padding: 20px;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-around;
            padding: 0 20px;
            z-index: 99;
        }
        
        .mobile-button {
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, rgba(0,100,200,0.9) 0%, rgba(0,50,100,0.9) 100%);
            border: 3px solid #00aaff;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
            box-shadow: 0 5px 15px rgba(0, 100, 200, 0.3);
        }
        
        .mobile-button:active {
            background: radial-gradient(circle, rgba(0,150,255,0.9) 0%, rgba(0,100,200,0.9) 100%);
            transform: scale(0.9);
        }
        
        /* Stage Details */
        .stage-detail {
            margin: 10px 0;
            padding: 12px;
            background: rgba(30, 30, 40, 0.7);
            border-radius: 8px;
            border-left: 4px solid;
            transition: all 0.3s;
        }
        
        .stage-detail.active {
            background: rgba(40, 60, 30, 0.8);
            border-left-color: #00ff00;
            animation: pulse 2s infinite;
        }
        
        .stage-detail.separated {
            opacity: 0.5;
            background: rgba(60, 30, 30, 0.7);
            border-left-color: #ff0000;
        }
        
        .stage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .fuel-indicator {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
            position: relative;
        }
        
        .fuel-fill {
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transition: width 0.3s;
        }
        
        /* Telemetry Display */
        .telemetry-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .telemetry-item {
            background: rgba(20, 40, 20, 0.7);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #00aa88;
        }
        
        .telemetry-label {
            font-size: 0.85em;
            color: #88ff88;
            margin-bottom: 4px;
        }
        
        .telemetry-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffaa;
            font-family: 'Courier New', monospace;
        }
        
        /* Fuel Mix */
        .fuel-mix {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        .fuel-type {
            flex: 1;
            padding: 10px;
            background: rgba(30, 30, 50, 0.7);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .fuel-type.selected {
            background: rgba(0, 50, 100, 0.9);
            border: 2px solid #00ffff;
        }
        
        /* RCS Controls */
        .rcs-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        
        .rcs-button {
            background: radial-gradient(circle, rgba(255,150,0,0.7) 0%, rgba(200,100,0,0.7) 100%);
            border: 2px solid #ffaa00;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .rcs-button:active {
            background: radial-gradient(circle, rgba(255,200,50,0.9) 0%, rgba(255,150,0,0.9) 100%);
            transform: scale(0.9);
        }
        
        /* Animations */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 170, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 170, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 170, 0); }
        }
        
        @keyframes vibration {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        
        .vibrate {
            animation: vibration 0.1s infinite;
        }
        
        /* Performance Indicator */
        #performance {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 10px;
            font-family: 'Courier New';
            font-size: 11px;
            z-index: 102;
        }
        
        /* Stage Separation Effects */
        .separation-effect {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .ui-panel {
                width: 95vw;
                max-height: 80vh;
                overflow-y: auto;
                left: 2.5vw;
                right: 2.5vw;
            }
            
            #stagePanel { top: 60px; }
            #controlPanel { bottom: 160px; }
            #telemetryPanel { top: 60px; right: 2.5vw; }
            #fuelPanel { bottom: 160px; right: 2.5vw; }
            
            .panel-toggle {
                padding: 8px 12px;
                font-size: 0.9em;
            }
            
            .mobile-controls {
                display: flex;
            }
            
            .telemetry-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Custom Elements */
        .button {
            background: linear-gradient(45deg, #0066cc, #00aaff);
            border: none;
            color: white;
            padding: 10px 15px;
            margin: 5px 0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            width: 100%;
        }
        
        .button:hover {
            background: linear-gradient(45deg, #0077dd, #00bbff);
            transform: translateY(-2px);
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #003366, #00aaff);
            border-radius: 3px;
            outline: none;
        }
        
        h3 {
            color: inherit;
            margin-bottom: 15px;
            border-bottom: 2px solid;
            padding-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .warning {
            color: #ff4444;
            animation: pulse 1s infinite;
        }
        
        .success {
            color: #44ff44;
        }
        
        .critical {
            color: #ff0000;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Panel Toggles -->
        <div class="panel-toggle" style="top: 20px; left: 20px; border-color: #ff5500;" id="toggleStagePanel">
            üöÄ STAGES
        </div>
        <div class="panel-toggle" style="bottom: 20px; left: 20px; border-color: #00aaff;" id="toggleControlPanel">
            üéÆ CONTROLS
        </div>
        <div class="panel-toggle" style="top: 20px; right: 20px; border-color: #00ffaa;" id="toggleTelemetryPanel">
            üì° TELEMETRY
        </div>
        <div class="panel-toggle" style="bottom: 20px; right: 20px; border-color: #aa00ff;" id="toggleFuelPanel">
            ‚õΩ FUEL
        </div>
        
        <!-- Stage Panel -->
        <div class="ui-panel" id="stagePanel">
            <h3 style="color: #ff5500;">üöÄ STAGE MANAGEMENT</h3>
            
            <div class="stage-detail" id="stage1Detail">
                <div class="stage-header">
                    <strong>FIRST STAGE</strong>
                    <span class="stage-status success">ACTIVE</span>
                </div>
                <div>Engines: 9 √ó Merlin 1D</div>
                <div>Thrust: <span id="stage1Thrust">7,607 kN</span></div>
                <div>ISP: <span id="stage1ISP">282s</span></div>
                <div class="fuel-indicator">
                    <div class="fuel-fill" style="background: #ff5500; width: 100%;"></div>
                </div>
                <div>Fuel: <span id="stage1Fuel">100.0%</span> | Mass: <span id="stage1Mass">85,000 kg</span></div>
                <div class="stage-props">
                    <div>Type: RP-1/LOX</div>
                    <div>Burn Time: 162s</div>
                </div>
            </div>
            
            <div class="stage-detail" id="stage2Detail">
                <div class="stage-header">
                    <strong>SECOND STAGE</strong>
                    <span class="stage-status">INACTIVE</span>
                </div>
                <div>Engine: 1 √ó Merlin Vacuum</div>
                <div>Thrust: <span id="stage2Thrust">934 kN</span></div>
                <div>ISP: <span id="stage2ISP">348s</span></div>
                <div class="fuel-indicator">
                    <div class="fuel-fill" style="background: #00aaff; width: 100%;"></div>
                </div>
                <div>Fuel: <span id="stage2Fuel">100.0%</span> | Mass: <span id="stage2Mass">12,000 kg</span></div>
                <div class="stage-props">
                    <div>Type: RP-1/LOX</div>
                    <div>Burn Time: 397s</div>
                </div>
            </div>
            
            <div class="stage-detail" id="stage3Detail">
                <div class="stage-header">
                    <strong>THIRD STAGE</strong>
                    <span class="stage-status">INACTIVE</span>
                </div>
                <div>Engine: 1 √ó RL-10B-2</div>
                <div>Thrust: <span id="stage3Thrust">110 kN</span></div>
                <div>ISP: <span id="stage3ISP">462s</span></div>
                <div class="fuel-indicator">
                    <div class="fuel-fill" style="background: #aa00ff; width: 100%;"></div>
                </div>
                <div>Fuel: <span id="stage3Fuel">100.0%</span> | Mass: <span id="stage3Mass">3,000 kg</span></div>
                <div class="stage-props">
                    <div>Type: LH‚ÇÇ/LOX</div>
                    <div>Burn Time: 500s</div>
                </div>
            </div>
            
            <div class="stage-detail" id="payloadDetail">
                <div class="stage-header">
                    <strong>PAYLOAD</strong>
                    <span class="stage-status success">ACTIVE</span>
                </div>
                <div>Mass: 2,000 kg</div>
                <div>Type: Communications Satellite</div>
                <div>Fairing: <span id="fairingStatus">ATTACHED</span></div>
            </div>
            
            <div style="margin-top: 15px;">
                <button class="button" id="separateStageBtn">SEPARATE STAGE (S)</button>
                <button class="button" id="jettisonFairing">JETTISON FAIRING</button>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="ui-panel" id="controlPanel">
            <h3 style="color: #00aaff;">üéÆ FLIGHT CONTROLS</h3>
            
            <div class="slider-container">
                <div>Throttle: <span id="throttleValue">100</span>%</div>
                <input type="range" id="throttleSlider" min="0" max="100" value="100">
            </div>
            
            <div class="slider-container">
                <div>Pitch: <span id="pitchValue">0.0</span>¬∞</div>
                <input type="range" id="pitchSlider" min="-90" max="90" value="0" step="0.1">
            </div>
            
            <div style="margin: 15px 0;">
                <select id="controlMode" style="width: 100%; padding: 8px; background: rgba(0,30,60,0.8); border: 2px solid #00aaff; color: white; border-radius: 6px;">
                    <option value="keyboard">Keyboard Controls</option>
                    <option value="gyro">Gyroscope (Mobile)</option>
                    <option value="auto">Autopilot</option>
                </select>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                <button class="button" id="toggleRCS">RCS: <span id="rcsStatus">ON</span></button>
                <button class="button" id="toggleAutopilot">AUTOPILOT: OFF</button>
                <button class="button" id="rcsModeBtn">RCS MODE: ATT</button>
                <button class="button" id="stabilityBtn">STABILITY: ON</button>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(0,40,80,0.7); border-radius: 6px;">
                <div>Active Stage: <span id="currentStageDisplay">1</span></div>
                <div>Control Mode: <span id="controlModeDisplay">Keyboard</span></div>
                <div>RCS Fuel: <span id="rcsFuelDisplay">100%</span></div>
            </div>
        </div>
        
        <!-- Telemetry Panel -->
        <div class="ui-panel" id="telemetryPanel">
            <h3 style="color: #00ffaa;">üì° FLIGHT TELEMETRY</h3>
            
            <div class="telemetry-grid">
                <div class="telemetry-item">
                    <div class="telemetry-label">ALTITUDE</div>
                    <div class="telemetry-value" id="altitude">0.0 km</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">VELOCITY</div>
                    <div class="telemetry-value" id="velocity">0.0 m/s</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">VERTICAL VEL.</div>
                    <div class="telemetry-value" id="verticalVelocity">0.0 m/s</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">HORIZONTAL VEL.</div>
                    <div class="telemetry-value" id="horizontalVelocity">0.0 m/s</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">ACCELERATION</div>
                    <div class="telemetry-value" id="acceleration">0.00 g</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">APOGEE</div>
                    <div class="telemetry-value" id="apogee">0.0 km</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">ŒîV REMAINING</div>
                    <div class="telemetry-value" id="deltaV">9,800 m/s</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">MACH NUMBER</div>
                    <div class="telemetry-value" id="machNumber">0.00</div>
                </div>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(20,40,20,0.7); border-radius: 6px;">
                <div>Orbit: <span id="orbitStatus" class="critical">SUBORBITAL</span></div>
                <div>Inclination: <span id="inclination">0.0¬∞</span></div>
                <div>Apoapsis: <span id="apoapsis">- km</span></div>
                <div>Periapsis: <span id="periapsis">- km</span></div>
            </div>
        </div>
        
        <!-- Fuel Panel -->
        <div class="ui-panel" id="fuelPanel">
            <h3 style="color: #aa00ff;">‚õΩ PROPULSION SYSTEM</h3>
            
            <div class="fuel-mix">
                <div class="fuel-type" data-fuel="kerosene">
                    <div>RP-1/LOX</div>
                    <div style="font-size: 0.8em;">ISP: 350s</div>
                </div>
                <div class="fuel-type" data-fuel="hydrogen">
                    <div>LH‚ÇÇ/LOX</div>
                    <div style="font-size: 0.8em;">ISP: 450s</div>
                </div>
                <div class="fuel-type" data-fuel="methane">
                    <div>CH‚ÇÑ/LOX</div>
                    <div style="font-size: 0.8em;">ISP: 380s</div>
                </div>
            </div>
            
            <div class="slider-container">
                <div>Mixture Ratio: <span id="mixtureValue">2.56</span></div>
                <input type="range" id="mixtureSlider" min="1" max="8" step="0.1" value="2.56">
            </div>
            
            <div style="height: 20px; background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); border-radius: 10px; margin: 15px 0; position: relative;">
                <div id="efficiencyMarker" style="position: absolute; top: 0; bottom: 0; width: 3px; background: white; left: 70%;"></div>
            </div>
            <div style="text-align: center;">Efficiency: <span id="efficiencyValue">85%</span></div>
            
            <div style="margin-top: 15px;">
                <button class="button" id="applyFuelBtn">APPLY FUEL MIX</button>
                <div style="margin-top: 10px; padding: 8px; background: rgba(40,0,60,0.7); border-radius: 6px;">
                    <div>Total Mass: <span id="totalMass">102,000 kg</span></div>
                    <div>Fuel Mass: <span id="fuelMass">80,000 kg</span></div>
                    <div>Payload Mass: <span id="payloadMass">2,000 kg</span></div>
                </div>
            </div>
        </div>
        
        <!-- RCS Panel -->
        <div class="ui-panel" id="rcsPanel">
            <h3 style="color: #ffff00;">üîÑ RCS CONTROL</h3>
            
            <div class="rcs-grid">
                <div></div>
                <div class="rcs-button" id="rcsPitchUp">‚Üë</div>
                <div></div>
                <div class="rcs-button" id="rcsYawLeft">‚Üê</div>
                <div class="rcs-button" id="rcsCenter">‚óè</div>
                <div class="rcs-button" id="rcsYawRight">‚Üí</div>
                <div></div>
                <div class="rcs-button" id="rcsPitchDown">‚Üì</div>
                <div></div>
            </div>
            
            <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                <div class="rcs-button" id="rcsRollLeft">‚Ü∂</div>
                <div class="rcs-button" id="rcsRollRight">‚Ü∑</div>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(60,40,0,0.7); border-radius: 6px;">
                <div>RCS Fuel: <span id="rcsFuelLevel">100%</span></div>
                <div>Impulse: <span id="rcsImpulse">100 N¬∑s</span></div>
                <div>Mode: <span id="rcsModeDisplay">ATTITUDE</span></div>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div class="mobile-button" id="mobileThrust">üî•</div>
            <div class="mobile-button" id="mobileStage">üõ∞Ô∏è</div>
            <div class="mobile-button" id="mobileRCS">üîÑ</div>
            <div class="mobile-button" id="mobileBrake">üõë</div>
        </div>
        
        <!-- Performance Indicator -->
        <div id="performance">
            FPS: <span id="fpsCounter">60</span> | OBJ: <span id="objectCount">0</span>
        </div>
        
        <!-- Separation Effect Container -->
        <div id="separationEffects"></div>
    </div>

    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

    <script>
        // ============================================================================
        // ADVANCED 3-STAGE ROCKET SIMULATOR
        // ============================================================================
        
        class AdvancedRocketSimulator {
            constructor() {
                // Core Three.js setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.00001);
                
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000000);
                this.camera.position.set(0, 50, 200);
                
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                
                // Time management
                this.clock = new THREE.Clock();
                this.deltaTime = 0;
                this.simulationSpeed = 1.0;
                this.timeScale = 1.0;
                this.fps = 60;
                this.lastFpsUpdate = 0;
                this.frameCount = 0;
                
                // Physics constants
                this.EARTH_RADIUS = 6371000; // meters
                this.EARTH_MASS = 5.972e24; // kg
                this.GRAVITY_CONSTANT = 6.67430e-11;
                this.STANDARD_GRAVITY = 9.80665;
                
                // Rocket state
                this.position = new THREE.Vector3(0, this.EARTH_RADIUS, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.acceleration = new THREE.Vector3(0, 0, 0);
                this.rotation = new THREE.Euler(0, 0, 0, 'YXZ');
                this.angularVelocity = new THREE.Vector3(0, 0, 0);
                this.throttle = 1.0;
                this.pitchAngle = 0;
                this.mixtureRatio = 2.56;
                
                // Advanced stage system with realistic properties
                this.stages = [
                    {
                        id: 1,
                        name: "First Stage",
                        active: true,
                        separated: false,
                        fuel: 100,
                        dryMass: 25000,
                        fuelMass: 60000,
                        engines: 9,
                        thrustVac: 845 * 1000 * 9,
                        thrustSL: 7607 * 1000,
                        ispVac: 282,
                        ispSL: 267,
                        burnTime: 162,
                        fuelConsumption: 60000 / 162,
                        fuelType: 'kerosene',
                        interstageHeight: 5,
                        separationForce: 50000,
                        visualObject: null,
                        exhaustSystems: [],
                        engineObjects: [],
                        gridFins: null,
                        landingLegs: null,
                        properties: {
                            diameter: 3.7,
                            length: 40,
                            engineType: "Merlin 1D",
                            propellant: "RP-1/LOX",
                            throttleRange: [0.4, 1.0],
                            restartCapable: false
                        }
                    },
                    {
                        id: 2,
                        name: "Second Stage",
                        active: false,
                        separated: false,
                        fuel: 100,
                        dryMass: 4000,
                        fuelMass: 8000,
                        engines: 1,
                        thrustVac: 934 * 1000,
                        ispVac: 348,
                        burnTime: 397,
                        fuelConsumption: 8000 / 397,
                        fuelType: 'kerosene',
                        interstageHeight: 3,
                        separationForce: 30000,
                        visualObject: null,
                        exhaustSystems: [],
                        engineObjects: [],
                        properties: {
                            diameter: 3.7,
                            length: 25,
                            engineType: "Merlin Vacuum",
                            propellant: "RP-1/LOX",
                            throttleRange: [0.5, 1.0],
                            restartCapable: true
                        }
                    },
                    {
                        id: 3,
                        name: "Third Stage",
                        active: false,
                        separated: false,
                        fuel: 100,
                        dryMass: 1000,
                        fuelMass: 2000,
                        engines: 1,
                        thrustVac: 110 * 1000,
                        ispVac: 462,
                        burnTime: 500,
                        fuelConsumption: 2000 / 500,
                        fuelType: 'hydrogen',
                        separationForce: 10000,
                        visualObject: null,
                        exhaustSystems: [],
                        engineObjects: [],
                        properties: {
                            diameter: 3.0,
                            length: 15,
                            engineType: "RL-10B-2",
                            propellant: "LH‚ÇÇ/LOX",
                            throttleRange: [0.2, 1.0],
                            restartCapable: true
                        }
                    }
                ];
                
                this.currentStageIndex = 0;
                this.payloadMass = 2000;
                this.fairingAttached = true;
                this.fairingObjects = [];
                
                // Fuel database with advanced properties
                this.fuelDatabase = {
                    kerosene: {
                        name: "RP-1/LOX",
                        formula: "C‚ÇÅ‚ÇÇH‚ÇÇ‚ÇÜ + 18.5O‚ÇÇ ‚Üí 12CO‚ÇÇ + 13H‚ÇÇO",
                        density: 810,
                        ispVac: 350,
                        ispSL: 300,
                        mixtureOptimal: 2.56,
                        energyDensity: 43.1,
                        exhaustVelocity: 3500,
                        specificHeatRatio: 1.22,
                        chamberTemp: 3670,
                        color: 0xaaaaaa,
                        exhaustColor: 0xff5500,
                        properties: ["Storable", "High density", "Medium efficiency"]
                    },
                    hydrogen: {
                        name: "LH‚ÇÇ/LOX",
                        formula: "2H‚ÇÇ + O‚ÇÇ ‚Üí 2H‚ÇÇO",
                        density: 71,
                        ispVac: 450,
                        ispSL: 360,
                        mixtureOptimal: 5.5,
                        energyDensity: 13.4,
                        exhaustVelocity: 4400,
                        specificHeatRatio: 1.40,
                        chamberTemp: 3500,
                        color: 0x88ffff,
                        exhaustColor: 0xffffff,
                        properties: ["Cryogenic", "High efficiency", "Low density"]
                    },
                    methane: {
                        name: "CH‚ÇÑ/LOX",
                        formula: "CH‚ÇÑ + 2O‚ÇÇ ‚Üí CO‚ÇÇ + 2H‚ÇÇO",
                        density: 423,
                        ispVac: 380,
                        ispSL: 330,
                        mixtureOptimal: 3.6,
                        energyDensity: 55.6,
                        exhaustVelocity: 3800,
                        specificHeatRatio: 1.32,
                        chamberTemp: 3600,
                        color: 0xff8844,
                        exhaustColor: 0xffaa44,
                        properties: ["Cryogenic", "Reusable", "Medium density"]
                    }
                };
                
                this.selectedFuel = 'kerosene';
                
                // RCS system
                this.rcsActive = true;
                this.rcsFuel = 100;
                this.rcsImpulse = 100;
                this.rcsThrust = 1000;
                this.rcsMode = 'attitude'; // 'attitude' or 'translation'
                this.rcsThrusters = {
                    pitchUp: false,
                    pitchDown: false,
                    yawLeft: false,
                    yawRight: false,
                    rollLeft: false,
                    rollRight: false,
                    translateUp: false,
                    translateDown: false,
                    translateLeft: false,
                    translateRight: false
                };
                
                // Control system
                this.controlMode = 'keyboard';
                this.gyroAvailable = false;
                this.gyroData = { alpha: 0, beta: 0, gamma: 0 };
                this.autopilotActive = false;
                this.autopilotTarget = { altitude: 200000, velocity: 7800, pitch: 0 };
                this.stabilityAssist = true;
                
                // Flight data
                this.altitude = 0;
                this.apogee = 0;
                this.perigee = 0;
                this.orbitalVelocity = 0;
                this.inclination = 0;
                this.orbitPeriod = 0;
                this.atmosphericPressure = 101.325;
                this.dragForce = new THREE.Vector3();
                this.machNumber = 0;
                this.dynamicPressure = 0;
                this.maxQ = 0;
                
                // Visual objects
                this.rocket = null;
                this.earth = null;
                this.stars = null;
                this.exhaustParticles = [];
                this.rcsParticles = [];
                this.separationEffects = [];
                this.stageDebris = [];
                this.clouds = null;
                
                // UI references
                this.ui = {};
                
                // Initialize
                this.initUI();
                this.initScene();
                this.initPhysics();
                this.initControls();
                this.initEventListeners();
                this.updateAllUI();
                
                // Start animation loop
                this.animate();
            }
            
            // ============================================================================
            // INITIALIZATION METHODS
            // ============================================================================
            
            initUI() {
                // Store all UI elements
                this.ui = {
                    // Panel toggles
                    toggleStagePanel: document.getElementById('toggleStagePanel'),
                    toggleControlPanel: document.getElementById('toggleControlPanel'),
                    toggleTelemetryPanel: document.getElementById('toggleTelemetryPanel'),
                    toggleFuelPanel: document.getElementById('toggleFuelPanel'),
                    
                    // Panels
                    stagePanel: document.getElementById('stagePanel'),
                    controlPanel: document.getElementById('controlPanel'),
                    telemetryPanel: document.getElementById('telemetryPanel'),
                    fuelPanel: document.getElementById('fuelPanel'),
                    rcsPanel: document.getElementById('rcsPanel'),
                    
                    // Stage panel elements
                    stage1Detail: document.getElementById('stage1Detail'),
                    stage2Detail: document.getElementById('stage2Detail'),
                    stage3Detail: document.getElementById('stage3Detail'),
                    payloadDetail: document.getElementById('payloadDetail'),
                    
                    stage1Fuel: document.getElementById('stage1Fuel'),
                    stage2Fuel: document.getElementById('stage2Fuel'),
                    stage3Fuel: document.getElementById('stage3Fuel'),
                    
                    stage1Mass: document.getElementById('stage1Mass'),
                    stage2Mass: document.getElementById('stage2Mass'),
                    stage3Mass: document.getElementById('stage3Mass'),
                    
                    stage1Thrust: document.getElementById('stage1Thrust'),
                    stage2Thrust: document.getElementById('stage2Thrust'),
                    stage3Thrust: document.getElementById('stage3Thrust'),
                    
                    stage1ISP: document.getElementById('stage1ISP'),
                    stage2ISP: document.getElementById('stage2ISP'),
                    stage3ISP: document.getElementById('stage3ISP'),
                    
                    fairingStatus: document.getElementById('fairingStatus'),
                    separateStageBtn: document.getElementById('separateStageBtn'),
                    jettisonFairing: document.getElementById('jettisonFairing'),
                    
                    // Control panel elements
                    throttleSlider: document.getElementById('throttleSlider'),
                    throttleValue: document.getElementById('throttleValue'),
                    pitchSlider: document.getElementById('pitchSlider'),
                    pitchValue: document.getElementById('pitchValue'),
                    controlMode: document.getElementById('controlMode'),
                    controlModeDisplay: document.getElementById('controlModeDisplay'),
                    toggleRCS: document.getElementById('toggleRCS'),
                    rcsStatus: document.getElementById('rcsStatus'),
                    toggleAutopilot: document.getElementById('toggleAutopilot'),
                    rcsModeBtn: document.getElementById('rcsModeBtn'),
                    stabilityBtn: document.getElementById('stabilityBtn'),
                    currentStageDisplay: document.getElementById('currentStageDisplay'),
                    rcsFuelDisplay: document.getElementById('rcsFuelDisplay'),
                    
                    // Telemetry panel elements
                    altitude: document.getElementById('altitude'),
                    velocity: document.getElementById('velocity'),
                    verticalVelocity: document.getElementById('verticalVelocity'),
                    horizontalVelocity: document.getElementById('horizontalVelocity'),
                    acceleration: document.getElementById('acceleration'),
                    apogee: document.getElementById('apogee'),
                    deltaV: document.getElementById('deltaV'),
                    machNumber: document.getElementById('machNumber'),
                    orbitStatus: document.getElementById('orbitStatus'),
                    inclination: document.getElementById('inclination'),
                    apoapsis: document.getElementById('apoapsis'),
                    periapsis: document.getElementById('periapsis'),
                    
                    // Fuel panel elements
                    fuelTypes: document.querySelectorAll('.fuel-type'),
                    mixtureSlider: document.getElementById('mixtureSlider'),
                    mixtureValue: document.getElementById('mixtureValue'),
                    efficiencyMarker: document.getElementById('efficiencyMarker'),
                    efficiencyValue: document.getElementById('efficiencyValue'),
                    applyFuelBtn: document.getElementById('applyFuelBtn'),
                    totalMass: document.getElementById('totalMass'),
                    fuelMass: document.getElementById('fuelMass'),
                    payloadMass: document.getElementById('payloadMass'),
                    
                    // RCS panel elements
                    rcsButtons: document.querySelectorAll('.rcs-button'),
                    rcsFuelLevel: document.getElementById('rcsFuelLevel'),
                    rcsImpulse: document.getElementById('rcsImpulse'),
                    rcsModeDisplay: document.getElementById('rcsModeDisplay'),
                    
                    // Mobile controls
                    mobileControls: document.querySelector('.mobile-controls'),
                    mobileThrust: document.getElementById('mobileThrust'),
                    mobileStage: document.getElementById('mobileStage'),
                    mobileRCS: document.getElementById('mobileRCS'),
                    mobileBrake: document.getElementById('mobileBrake'),
                    
                    // Performance
                    performance: document.getElementById('performance'),
                    fpsCounter: document.getElementById('fpsCounter'),
                    objectCount: document.getElementById('objectCount')
                };
                
                // Initialize fuel selection
                this.ui.fuelTypes.forEach(type => {
                    if (type.dataset.fuel === this.selectedFuel) {
                        type.classList.add('selected');
                    }
                });
                
                // Set initial values
                this.ui.mixtureValue.textContent = this.mixtureRatio.toFixed(2);
                this.ui.mixtureSlider.value = this.mixtureRatio;
            }
            
            initScene() {
                // Enhanced lighting
                const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
                this.scene.add(ambientLight);
                
                const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
                sunLight.position.set(1000, 1000, 500);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.far = 100000;
                this.scene.add(sunLight);
                
                // Create detailed Earth
                this.createEarth();
                
                // Create stars
                this.createStars();
                
                // Create clouds layer
                this.createClouds();
                
                // Create detailed rocket
                this.createRocket();
                
                // Add some satellites in orbit for reference
                this.createSatellites();
            }
            
            createEarth() {
                // Earth sphere with multiple layers
                const earthGroup = new THREE.Group();
                
                // Solid Earth
                const earthGeometry = new THREE.SphereGeometry(this.EARTH_RADIUS / 1000, 64, 64);
                const earthMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2233ff,
                    shininess: 100,
                    specular: 0x222222,
                    emissive: 0x001122,
                    transparent: true,
                    opacity: 0.95
                });
                
                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earthGroup.add(earth);
                
                // Crust layer (slightly larger)
                const crustGeometry = new THREE.SphereGeometry(this.EARTH_RADIUS / 1000 * 1.001, 64, 64);
                const crustMaterial = new THREE.MeshPhongMaterial({
                    color: 0x3355aa,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const crust = new THREE.Mesh(crustGeometry, crustMaterial);
                earthGroup.add(crust);
                
                this.earth = earthGroup;
                this.scene.add(earthGroup);
            }
            
            createClouds() {
                // Create cloud layer around Earth
                const cloudGeometry = new THREE.SphereGeometry(this.EARTH_RADIUS / 1000 * 1.02, 64, 64);
                const cloudMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    alphaMap: this.createCloudTexture()
                });
                
                this.clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                this.earth.add(this.clouds);
            }
            
            createCloudTexture() {
                // Create procedural cloud texture
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Create cloud-like pattern
                ctx.fillStyle = 'rgba(255, 255, 255, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw cloud patterns
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const radius = 20 + Math.random() * 40;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Blur the clouds
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                this.blurImageData(imageData, 2);
                ctx.putImageData(imageData, 0, 0);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                return texture;
            }
            
            blurImageData(imageData, radius) {
                // Simple blur implementation
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0, a = 0, count = 0;
                        
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const idx = (ny * width + nx) * 4;
                                    r += pixels[idx];
                                    g += pixels[idx + 1];
                                    b += pixels[idx + 2];
                                    a += pixels[idx + 3];
                                    count++;
                                }
                            }
                        }
                        
                        const idx = (y * width + x) * 4;
                        pixels[idx] = r / count;
                        pixels[idx + 1] = g / count;
                        pixels[idx + 2] = b / count;
                        pixels[idx + 3] = a / count;
                    }
                }
            }
            
            createStars() {
                const starCount = 10000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(starCount * 3);
                const colors = new Float32Array(starCount * 3);
                const sizes = new Float32Array(starCount);
                
                for (let i = 0; i < starCount; i++) {
                    // Spherical distribution
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const radius = 50000 + Math.random() * 50000;
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    // Star colors based on temperature
                    const temp = Math.random();
                    let color;
                    if (temp < 0.7) color = new THREE.Color(0xffffff); // White
                    else if (temp < 0.85) color = new THREE.Color(0xffeedd); // Yellow-white
                    else if (temp < 0.95) color = new THREE.Color(0xffddbb); // Orange
                    else color = new THREE.Color(0xddbbff); // Blue-white
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = 0.5 + Math.random() * 2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    transparent: true,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.stars = new THREE.Points(geometry, material);
                this.scene.add(this.stars);
            }
            
            createRocket() {
                // Create main rocket group
                this.rocket = new THREE.Group();
                
                // Create each stage with detailed geometry
                this.stages.forEach((stage, index) => {
                    const stageGroup = this.createDetailedStage(stage, index);
                    this.rocket.add(stageGroup);
                    stage.visualObject = stageGroup;
                    
                    // Position stages vertically
                    let yOffset = 0;
                    for (let i = 0; i < index; i++) {
                        yOffset += this.stages[i].properties.length + this.stages[i].interstageHeight;
                    }
                    stageGroup.position.y = yOffset;
                });
                
                // Create payload fairing
                this.createPayloadFairing();
                
                // Create RCS thrusters
                this.createRCSThrusters();
                
                this.scene.add(this.rocket);
            }
            
            createDetailedStage(stage, stageIndex) {
                const stageGroup = new THREE.Group();
                
                const radius = stage.properties.diameter / 2;
                const height = stage.properties.length;
                const fuelColor = this.fuelDatabase[stage.fuelType]?.color || 0x888888;
                
                // Main body cylinder with smooth shading
                const bodyGeometry = new THREE.CylinderGeometry(radius, radius, height, 32);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: stageIndex === 0 ? 0xffffff : 0xf0f0f0,
                    shininess: 60,
                    specular: 0x444444
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                stageGroup.add(body);
                
                // Fuel tank section (visible through cutaway)
                const fuelHeight = height * 0.8;
                const fuelGeometry = new THREE.CylinderGeometry(radius * 0.95, radius * 0.95, fuelHeight, 24);
                const fuelMaterial = new THREE.MeshPhongMaterial({
                    color: fuelColor,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const fuelTank = new THREE.Mesh(fuelGeometry, fuelMaterial);
                fuelTank.position.y = -height * 0.1;
                stageGroup.add(fuelTank);
                
                // Engine section
                this.createEngineCluster(stageGroup, stage, radius, height);
                
                // Interstage (except for top stage)
                if (stageIndex < 2) {
                    this.createInterstage(stageGroup, stage, radius, height);
                }
                
                // Grid fins for first stage
                if (stageIndex === 0) {
                    this.createGridFins(stageGroup, radius, height);
                }
                
                // Landing legs for first stage (folded)
                if (stageIndex === 0) {
                    this.createLandingLegs(stageGroup, radius, height);
                }
                
                return stageGroup;
            }
            
            createEngineCluster(stageGroup, stage, radius, height) {
                const engineCount = stage.engines;
                const engineGeometry = new THREE.ConeGeometry(0.4, 2, 8);
                const engineMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    shininess: 30
                });
                
                // Create detailed engine nozzles
                for (let i = 0; i < engineCount; i++) {
                    const engineGroup = new THREE.Group();
                    
                    // Engine nozzle
                    const nozzle = new THREE.Mesh(engineGeometry, engineMaterial);
                    nozzle.position.y = -height / 2 - 1;
                    nozzle.rotation.x = Math.PI;
                    nozzle.castShadow = true;
                    engineGroup.add(nozzle);
                    
                    // Engine bell extension
                    const bellGeometry = new THREE.ConeGeometry(0.6, 1, 8);
                    const bell = new THREE.Mesh(bellGeometry, engineMaterial);
                    bell.position.y = -height / 2 - 2;
                    bell.rotation.x = Math.PI;
                    engineGroup.add(bell);
                    
                    // Position engines in circle
                    const angle = (i / engineCount) * Math.PI * 2;
                    const distance = stage.id === 1 ? 2 : 1.5;
                    engineGroup.position.x = Math.cos(angle) * distance;
                    engineGroup.position.z = Math.sin(angle) * distance;
                    
                    stageGroup.add(engineGroup);
                    stage.engineObjects.push(engineGroup);
                    
                    // Create exhaust particle system for each engine
                    const exhaustSystem = this.createExhaustSystem(stage.fuelType);
                    exhaustSystem.position.copy(engineGroup.position);
                    exhaustSystem.position.y = -height / 2 - 2.5;
                    stageGroup.add(exhaustSystem);
                    stage.exhaustSystems.push(exhaustSystem);
                }
            }
            
            createInterstage(stageGroup, stage, radius, height) {
                const interstageGeometry = new THREE.CylinderGeometry(radius, radius, stage.interstageHeight, 16);
                const interstageMaterial = new THREE.MeshPhongMaterial({
                    color: 0x888888,
                    shininess: 40
                });
                const interstage = new THREE.Mesh(interstageGeometry, interstageMaterial);
                interstage.position.y = height / 2 + stage.interstageHeight / 2;
                interstage.castShadow = true;
                stageGroup.add(interstage);
                
                // Separation plane indicator
                const separationGeometry = new THREE.RingGeometry(radius * 0.9, radius, 16);
                const separationMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const separationRing = new THREE.Mesh(separationGeometry, separationMaterial);
                separationRing.position.y = height / 2;
                separationRing.rotation.x = Math.PI / 2;
                stageGroup.add(separationRing);
            }
            
            createGridFins(stageGroup, radius, height) {
                const finGeometry = new THREE.BoxGeometry(0.2, 3, 2);
                const finMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    shininess: 50
                });
                
                // Create grid pattern on fins
                const gridGeometry = new THREE.BoxGeometry(0.21, 2.8, 1.9);
                const gridMaterial = new THREE.MeshLambertMaterial({
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                
                for (let i = 0; i < 4; i++) {
                    const fin = new THREE.Mesh(finGeometry, finMaterial);
                    const angle = (i / 4) * Math.PI * 2;
                    
                    fin.position.x = Math.cos(angle) * (radius + 1);
                    fin.position.z = Math.sin(angle) * (radius + 1);
                    fin.position.y = -height / 2 + 1.5;
                    fin.rotation.y = angle + Math.PI / 2;
                    fin.castShadow = true;
                    
                    const grid = new THREE.Mesh(gridGeometry, gridMaterial);
                    grid.position.copy(fin.position);
                    grid.rotation.copy(fin.rotation);
                    
                    stageGroup.add(fin);
                    stageGroup.add(grid);
                    
                    if (!this.stages[0].gridFins) this.stages[0].gridFins = [];
                    this.stages[0].gridFins.push({ fin, grid });
                }
            }
            
            createLandingLegs(stageGroup, radius, height) {
                const legGeometry = new THREE.BoxGeometry(0.3, 8, 0.3);
                const legMaterial = new THREE.MeshPhongMaterial({
                    color: 0x888888,
                    shininess: 30
                });
                
                const footGeometry = new THREE.BoxGeometry(1, 0.2, 1);
                
                for (let i = 0; i < 4; i++) {
                    const legGroup = new THREE.Group();
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                    
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.x = Math.cos(angle) * 1;
                    leg.position.z = Math.sin(angle) * 1;
                    leg.position.y = -height / 2 - 4;
                    leg.rotation.z = Math.PI / 6 * Math.cos(angle);
                    leg.rotation.x = Math.PI / 6 * Math.sin(angle);
                    
                    const foot = new THREE.Mesh(footGeometry, legMaterial);
                    foot.position.x = leg.position.x * 2;
                    foot.position.z = leg.position.z * 2;
                    foot.position.y = -height / 2 - 8.1;
                    
                    legGroup.add(leg);
                    legGroup.add(foot);
                    stageGroup.add(legGroup);
                    
                    if (!this.stages[0].landingLegs) this.stages[0].landingLegs = [];
                    this.stages[0].landingLegs.push(legGroup);
                }
            }
            
            createExhaustSystem(fuelType) {
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                
                const fuelData = this.fuelDatabase[fuelType] || this.fuelDatabase.kerosene;
                const baseColor = new THREE.Color(fuelData.exhaustColor);
                
                for (let i = 0; i < particleCount; i++) {
                    // Start all particles at origin
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    // Color based on fuel type
                    const hueShift = (Math.random() - 0.5) * 0.2;
                    const color = baseColor.clone().offsetHSL(hueShift, 0, 0);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    // Size variation
                    sizes[i] = 0.3 + Math.random() * 0.7;
                    
                    // Initial velocities (will be set when spawned)
                    velocities[i * 3] = 0;
                    velocities[i * 3 + 1] = 0;
                    velocities[i * 3 + 2] = 0;
                    
                    // Start with zero lifetime (inactive)
                    lifetimes[i] = 0;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const particleSystem = new THREE.Points(geometry, material);
                particleSystem.userData = {
                    velocities: velocities,
                    lifetimes: lifetimes,
                    nextParticle: 0
                };
                
                return particleSystem;
            }
            
            createPayloadFairing() {
                const fairingGroup = new THREE.Group();
                
                // Fairing halves
                const fairingGeometry = new THREE.ConeGeometry(2, 20, 16);
                const fairingMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.8
                });
                
                const fairing1 = new THREE.Mesh(fairingGeometry, fairingMaterial);
                fairing1.castShadow = true;
                
                const fairing2 = fairing1.clone();
                fairing2.rotation.y = Math.PI;
                
                fairingGroup.add(fairing1);
                fairingGroup.add(fairing2);
                
                // Position above third stage
                let totalHeight = 0;
                this.stages.forEach(stage => {
                    totalHeight += stage.properties.length + (stage.interstageHeight || 0);
                });
                fairingGroup.position.y = totalHeight + 10;
                
                this.rocket.add(fairingGroup);
                this.fairingObjects = [fairing1, fairing2];
                
                // Satellite inside
                this.createSatellite(fairingGroup);
            }
            
            createSatellite(parent) {
                const satelliteGroup = new THREE.Group();
                
                // Main bus
                const busGeometry = new THREE.BoxGeometry(1, 2, 1);
                const busMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    emissive: 0x444400
                });
                const bus = new THREE.Mesh(busGeometry, busMaterial);
                satelliteGroup.add(bus);
                
                // Solar panels
                const panelGeometry = new THREE.BoxGeometry(3, 0.1, 1);
                const panelMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00aaff,
                    emissive: 0x002244
                });
                
                const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                leftPanel.position.x = -2;
                satelliteGroup.add(leftPanel);
                
                const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                rightPanel.position.x = 2;
                satelliteGroup.add(rightPanel);
                
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1);
                const antenna = new THREE.Mesh(antennaGeometry, busMaterial);
                antenna.position.y = 1.5;
                satelliteGroup.add(antenna);
                
                parent.add(satelliteGroup);
                this.payloadObject = satelliteGroup;
            }
            
            createRCSThrusters() {
                // Create RCS thruster blocks at strategic locations
                const rcsPositions = [
                    { x: 2, y: 35, z: 0 },    // Top, right
                    { x: -2, y: 35, z: 0 },   // Top, left
                    { x: 0, y: 35, z: 2 },    // Top, forward
                    { x: 0, y: 35, z: -2 },   // Top, backward
                    { x: 2, y: -15, z: 0 },   // Bottom, right
                    { x: -2, y: -15, z: 0 },  // Bottom, left
                    { x: 0, y: -15, z: 2 },   // Bottom, forward
                    { x: 0, y: -15, z: -2 }   // Bottom, backward
                ];
                
                rcsPositions.forEach(pos => {
                    const rcsGroup = this.createRCSThruster();
                    rcsGroup.position.set(pos.x, pos.y, pos.z);
                    this.rocket.add(rcsGroup);
                    this.rcsParticles.push(rcsGroup);
                });
            }
            
            createRCSThruster() {
                const thrusterGroup = new THREE.Group();
                
                // Thruster block
                const blockGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const blockMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffaa00,
                    emissive: 0x442200
                });
                const block = new THREE.Mesh(blockGeometry, blockMaterial);
                thrusterGroup.add(block);
                
                // Nozzle
                const nozzleGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
                const nozzleMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333
                });
                const nozzle = new THREE.Mesh(nozzleGeometry, nozzleMaterial);
                nozzle.position.z = 0.2;
                nozzle.rotation.x = Math.PI / 2;
                thrusterGroup.add(nozzle);
                
                // Particle system
                const particleSystem = this.createRCSParticleSystem();
                particleSystem.position.z = 0.5;
                thrusterGroup.add(particleSystem);
                
                thrusterGroup.userData = {
                    particleSystem: particleSystem,
                    active: false
                };
                
                return thrusterGroup;
            }
            
            createRCSParticleSystem() {
                const particleCount = 50;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = 0;
                    positions[i + 1] = 0;
                    positions[i + 2] = 0;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0x00ffff,
                    size: 0.2,
                    transparent: true,
                    opacity: 0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const particleSystem = new THREE.Points(geometry, material);
                particleSystem.userData = {
                    velocities: new Float32Array(particleCount * 3),
                    lifetimes: new Float32Array(particleCount),
                    nextParticle: 0
                };
                
                return particleSystem;
            }
            
            createSatellites() {
                // Create some satellites in orbit for reference
                const orbitRadius = this.EARTH_RADIUS + 35786000; // GEO orbit
                
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const x = Math.cos(angle) * orbitRadius / 1000;
                    const z = Math.sin(angle) * orbitRadius / 1000;
                    
                    const satellite = this.createSatelliteModel();
                    satellite.position.set(x, 0, z);
                    this.scene.add(satellite);
                }
            }
            
            createSatelliteModel() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.5, 0.5, 1);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaaaaaa,
                    emissive: 0x222222
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Solar panels
                const panelGeometry = new THREE.BoxGeometry(2, 0.05, 1);
                const panelMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00aaff,
                    emissive: 0x002244
                });
                
                const panel1 = new THREE.Mesh(panelGeometry, panelMaterial);
                panel1.position.y = 0.3;
                group.add(panel1);
                
                const panel2 = panel1.clone();
                panel2.position.y = -0.3;
                group.add(panel2);
                
                // Antennas
                const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1);
                const antenna = new THREE.Mesh(antennaGeometry, bodyMaterial);
                antenna.position.z = 0.8;
                group.add(antenna);
                
                return group;
            }
            
            initPhysics() {
                // Initialize advanced physics models
                this.initAtmosphericModel();
                this.initAerodynamicModel();
            }
            
            initAtmosphericModel() {
                // US Standard Atmosphere 1976 data (simplified)
                this.atmosphereLayers = [
                    { height: 0, pressure: 101.325, temperature: 288.15, density: 1.225 },
                    { height: 11000, pressure: 22.632, temperature: 216.65, density: 0.3639 },
                    { height: 20000, pressure: 5.4749, temperature: 216.65, density: 0.0880 },
                    { height: 32000, pressure: 0.8680, temperature: 228.65, density: 0.0132 },
                    { height: 47000, pressure: 0.1109, temperature: 270.65, density: 0.0014 },
                    { height: 51000, pressure: 0.0669, temperature: 270.65, density: 0.00086 },
                    { height: 71000, pressure: 0.00396, temperature: 214.65, density: 0.000064 },
                    { height: 84852, pressure: 0.000373, temperature: 186.87, density: 0.000006 },
                    { height: 100000, pressure: 0.000026, temperature: 210.02, density: 0.0000004 }
                ];
            }
            
            initAerodynamicModel() {
                // Simplified aerodynamic coefficients
                this.dragCoefficient = {
                    subsonic: 0.3,
                    transonic: 0.8,
                    supersonic: 0.4,
                    hypersonic: 0.2
                };
                
                this.liftCoefficient = 0.1;
                this.crossSectionalArea = 10.75; // m¬≤ for Falcon 9
            }
            
            initControls() {
                // Check for device orientation support
                if (window.DeviceOrientationEvent) {
                    this.gyroAvailable = true;
                    window.addEventListener('deviceorientation', this.handleGyro.bind(this), true);
                }
                
                // Setup mobile controls
                this.setupMobileControls();
            }
            
            setupMobileControls() {
                let thrustActive = false;
                
                this.ui.mobileThrust.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    thrustActive = true;
                    this.throttle = 1.0;
                    this.ui.mobileThrust.style.background = 'radial-gradient(circle, rgba(255,50,0,0.9) 0%, rgba(200,25,0,0.9) 100%)';
                });
                
                this.ui.mobileThrust.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    thrustActive = false;
                    this.throttle = 0;
                    this.ui.mobileThrust.style.background = 'radial-gradient(circle, rgba(0,100,200,0.9) 0%, rgba(0,50,100,0.9) 100%)';
                });
                
                this.ui.mobileStage.addEventListener('click', () => {
                    this.separateCurrentStage();
                });
                
                this.ui.mobileRCS.addEventListener('click', () => {
                    this.rcsActive = !this.rcsActive;
                    this.ui.rcsStatus.textContent = this.rcsActive ? 'ON' : 'OFF';
                });
            }
            
            initEventListeners() {
                // Window resize
                window.addEventListener('resize', this.onWindowResize.bind(this));
                
                // Keyboard controls
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
                document.addEventListener('keyup', this.handleKeyUp.bind(this));
                
                // Panel toggles
                this.ui.toggleStagePanel.addEventListener('click', () => this.togglePanel('stage'));
                this.ui.toggleControlPanel.addEventListener('click', () => this.togglePanel('control'));
                this.ui.toggleTelemetryPanel.addEventListener('click', () => this.togglePanel('telemetry'));
                this.ui.toggleFuelPanel.addEventListener('click', () => this.togglePanel('fuel'));
                
                // Stage separation
                this.ui.separateStageBtn.addEventListener('click', () => {
                    this.separateCurrentStage();
                });
                
                // Fairing jettison
                this.ui.jettisonFairing.addEventListener('click', () => {
                    this.jettisonFairing();
                });
                
                // Throttle control
                this.ui.throttleSlider.addEventListener('input', (e) => {
                    this.throttle = parseFloat(e.target.value) / 100;
                    this.ui.throttleValue.textContent = e.target.value;
                });
                
                // Pitch control
                this.ui.pitchSlider.addEventListener('input', (e) => {
                    this.pitchAngle = parseFloat(e.target.value);
                    this.ui.pitchValue.textContent = this.pitchAngle.toFixed(1);
                });
                
                // Control mode
                this.ui.controlMode.addEventListener('change', (e) => {
                    this.controlMode = e.target.value;
                    this.ui.controlModeDisplay.textContent = e.target.selectedOptions[0].text;
                    this.updateControlMode();
                });
                
                // RCS toggle
                this.ui.toggleRCS.addEventListener('click', () => {
                    this.rcsActive = !this.rcsActive;
                    this.ui.rcsStatus.textContent = this.rcsActive ? 'ON' : 'OFF';
                });
                
                // Autopilot toggle
                this.ui.toggleAutopilot.addEventListener('click', () => {
                    this.autopilotActive = !this.autopilotActive;
                    this.ui.toggleAutopilot.textContent = `AUTOPILOT: ${this.autopilotActive ? 'ON' : 'OFF'}`;
                });
                
                // RCS mode toggle
                this.ui.rcsModeBtn.addEventListener('click', () => {
                    this.rcsMode = this.rcsMode === 'attitude' ? 'translation' : 'attitude';
                    this.ui.rcsModeDisplay.textContent = this.rcsMode === 'attitude' ? 'ATTITUDE' : 'TRANSLATION';
                    this.ui.rcsModeBtn.textContent = `RCS MODE: ${this.rcsMode === 'attitude' ? 'ATT' : 'TRANS'}`;
                });
                
                // Stability assist toggle
                this.ui.stabilityBtn.addEventListener('click', () => {
                    this.stabilityAssist = !this.stabilityAssist;
                    this.ui.stabilityBtn.textContent = `STABILITY: ${this.stabilityAssist ? 'ON' : 'OFF'}`;
                });
                
                // Fuel selection
                this.ui.fuelTypes.forEach(type => {
                    type.addEventListener('click', () => {
                        this.selectFuel(type.dataset.fuel);
                    });
                });
                
                // Mixture ratio
                this.ui.mixtureSlider.addEventListener('input', (e) => {
                    this.mixtureRatio = parseFloat(e.target.value);
                    this.ui.mixtureValue.textContent = this.mixtureRatio.toFixed(2);
                    this.updateEfficiency();
                });
                
                // Apply fuel mix
                this.ui.applyFuelBtn.addEventListener('click', () => {
                    this.applyFuelConfiguration();
                });
                
                // Performance monitoring
                document.addEventListener('visibilitychange', () => {
                    this.simulationSpeed = document.hidden ? 0.1 : 1.0;
                });
            }
            
            // ============================================================================
            // ADVANCED PHYSICS SIMULATION
            // ============================================================================
            
            updatePhysics(deltaTime) {
                // Apply simulation speed
                deltaTime *= this.simulationSpeed;
                
                // Get current stage
                const currentStage = this.stages[this.currentStageIndex];
                if (!currentStage) return;
                
                // Calculate altitude and atmospheric conditions
                this.calculateAltitude();
                this.updateAtmosphericConditions();
                
                // Calculate gravity force (inverse square law)
                const distanceToCenter = this.position.length();
                const gravityMagnitude = this.GRAVITY_CONSTANT * this.EARTH_MASS / 
                    Math.pow(distanceToCenter, 2);
                const gravityVector = this.position.clone().normalize().multiplyScalar(-gravityMagnitude);
                
                // Calculate thrust
                let thrustVector = new THREE.Vector3();
                if (currentStage.active && !currentStage.separated && currentStage.fuel > 0) {
                    // Calculate thrust based on atmospheric pressure and mixture ratio
                    const thrust = this.calculateStageThrust(currentStage);
                    const thrustDirection = new THREE.Vector3(0, 1, 0)
                        .applyEuler(this.rotation);
                    
                    thrustVector = thrustDirection.multiplyScalar(thrust * this.throttle);
                    
                    // Fuel consumption
                    const fuelConsumed = currentStage.fuelConsumption * this.throttle * deltaTime;
                    currentStage.fuel = Math.max(0, currentStage.fuel - (fuelConsumed / currentStage.fuelMass * 100));
                    
                    // Auto-stage on fuel depletion
                    if (currentStage.fuel <= 0.1 && this.currentStageIndex < 2) {
                        this.separateCurrentStage();
                    }
                }
                
                // Calculate RCS forces
                const rcsForce = this.calculateRCSForce(deltaTime);
                
                // Calculate aerodynamic forces
                const aerodynamicForces = this.calculateAerodynamicForces();
                
                // Calculate total acceleration
                this.calculateTotalMass();
                const totalForce = thrustVector
                    .add(gravityVector)
                    .add(rcsForce)
                    .add(aerodynamicForces.drag)
                    .add(aerodynamicForces.lift);
                
                this.acceleration = totalForce.divideScalar(this.totalMass);
                
                // Update velocity and position
                this.velocity.add(this.acceleration.clone().multiplyScalar(deltaTime));
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Update rotation
                this.updateRotation(deltaTime);
                
                // Update orbital parameters
                this.updateOrbitalParameters();
                
                // Update separated stages and debris
                this.updateSeparatedObjects(deltaTime);
                
                // Update autopilot
                if (this.autopilotActive) {
                    this.updateAutopilot(deltaTime);
                }
            }
            
            calculateAltitude() {
                // Calculate altitude above Earth's surface
                const distanceToCenter = this.position.length();
                this.altitude = Math.max(0, distanceToCenter - this.EARTH_RADIUS);
                this.apogee = Math.max(this.apogee, this.altitude);
            }
            
            updateAtmosphericConditions() {
                if (this.altitude >= 100000) {
                    this.atmosphericPressure = 0;
                    return;
                }
                
                // Find appropriate atmospheric layer
                let layer = this.atmosphereLayers[0];
                for (let i = 1; i < this.atmosphereLayers.length; i++) {
                    if (this.altitude >= this.atmosphereLayers[i].height) {
                        layer = this.atmosphereLayers[i];
                    } else {
                        // Interpolate between layers
                        const prevLayer = this.atmosphereLayers[i - 1];
                        const ratio = (this.altitude - prevLayer.height) / 
                                     (this.atmosphereLayers[i].height - prevLayer.height);
                        
                        this.atmosphericPressure = prevLayer.pressure + 
                            (layer.pressure - prevLayer.pressure) * ratio;
                        return;
                    }
                }
                
                this.atmosphericPressure = layer.pressure;
            }
            
            calculateStageThrust(stage) {
                // Calculate thrust based on atmospheric pressure
                const thrustVac = stage.thrustVac;
                const thrustSL = stage.thrustSL;
                const pressureRatio = this.atmosphericPressure / 101.325;
                
                // Linear interpolation between sea level and vacuum thrust
                let thrust = thrustSL + (thrustVac - thrustSL) * (1 - pressureRatio);
                
                // Apply mixture ratio efficiency
                const fuelData = this.fuelDatabase[stage.fuelType];
                if (fuelData) {
                    const optimalRatio = fuelData.mixtureOptimal;
                    const ratioEfficiency = 1 - Math.abs(this.mixtureRatio - optimalRatio) / optimalRatio;
                    thrust *= Math.min(1, ratioEfficiency);
                }
                
                return thrust;
            }
            
            calculateRCSForce(deltaTime) {
                const force = new THREE.Vector3();
                const torque = new THREE.Vector3();
                
                if (this.rcsActive && this.rcsFuel > 0) {
                    const rcsStrength = this.rcsThrust * this.rcsImpulse / 100;
                    
                    if (this.rcsMode === 'attitude') {
                        // Attitude control
                        if (this.rcsThrusters.pitchUp) {
                            torque.x += rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.pitchDown) {
                            torque.x -= rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.yawLeft) {
                            torque.z += rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.yawRight) {
                            torque.z -= rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.rollLeft) {
                            torque.y -= rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.rollRight) {
                            torque.y += rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                    } else {
                        // Translation control
                        if (this.rcsThrusters.translateUp) {
                            force.y += rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.translateDown) {
                            force.y -= rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.translateLeft) {
                            force.x -= rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                        if (this.rcsThrusters.translateRight) {
                            force.x += rcsStrength;
                            this.consumeRCSFuel(deltaTime);
                        }
                    }
                    
                    // Apply torque to angular velocity
                    const momentOfInertia = this.calculateMomentOfInertia();
                    const angularAcceleration = torque.divideScalar(momentOfInertia);
                    this.angularVelocity.add(angularAcceleration.multiplyScalar(deltaTime));
                }
                
                return force;
            }
            
            calculateAerodynamicForces() {
                if (this.altitude > 100000) {
                    return { drag: new THREE.Vector3(), lift: new THREE.Vector3() };
                }
                
                // Calculate air density
                const airDensity = this.getAirDensity(this.altitude);
                
                // Calculate velocity magnitude and direction
                const velocityMagnitude = this.velocity.length();
                const velocityDirection = this.velocity.clone().normalize();
                
                // Calculate Mach number
                const speedOfSound = 340.29 * Math.sqrt(this.getTemperature(this.altitude) / 288.15);
                this.machNumber = velocityMagnitude / speedOfSound;
                
                // Select drag coefficient based on Mach number
                let Cd;
                if (this.machNumber < 0.8) Cd = this.dragCoefficient.subsonic;
                else if (this.machNumber < 1.2) Cd = this.dragCoefficient.transonic;
                else if (this.machNumber < 5) Cd = this.dragCoefficient.supersonic;
                else Cd = this.dragCoefficient.hypersonic;
                
                // Calculate dynamic pressure (q = 0.5 * œÅ * v¬≤)
                this.dynamicPressure = 0.5 * airDensity * Math.pow(velocityMagnitude, 2);
                this.maxQ = Math.max(this.maxQ, this.dynamicPressure);
                
                // Calculate drag force (Fd = 0.5 * œÅ * v¬≤ * Cd * A)
                const dragMagnitude = this.dynamicPressure * Cd * this.crossSectionalArea;
                const dragForce = velocityDirection.clone().multiplyScalar(-dragMagnitude);
                
                // Calculate lift force (simplified)
                const angleOfAttack = this.calculateAngleOfAttack();
                const liftMagnitude = this.dynamicPressure * this.liftCoefficient * 
                                     this.crossSectionalArea * Math.sin(angleOfAttack);
                const liftDirection = this.calculateLiftDirection();
                const liftForce = liftDirection.multiplyScalar(liftMagnitude);
                
                return { drag: dragForce, lift: liftForce };
            }
            
            calculateMomentOfInertia() {
                // Simplified moment of inertia calculation
                const mass = this.totalMass;
                const radius = 2; // Approximate radius
                const height = 50; // Approximate height
                
                // Cylinder moment of inertia
                const Ixx = (1/12) * mass * (3 * radius * radius + height * height);
                const Iyy = (1/2) * mass * radius * radius;
                
                return (Ixx + Iyy) / 2;
            }
            
            calculateAngleOfAttack() {
                // Calculate angle between velocity vector and rocket orientation
                const rocketDirection = new THREE.Vector3(0, 1, 0).applyEuler(this.rotation);
                const velocityDirection = this.velocity.clone().normalize();
                
                return Math.acos(rocketDirection.dot(velocityDirection));
            }
            
            calculateLiftDirection() {
                // Calculate lift direction (perpendicular to velocity and aligned with rocket)
                const rocketDirection = new THREE.Vector3(0, 1, 0).applyEuler(this.rotation);
                const velocityDirection = this.velocity.clone().normalize();
                
                return rocketDirection.cross(velocityDirection).cross(velocityDirection).normalize();
            }
            
            getAirDensity(altitude) {
                if (altitude >= 100000) return 0;
                
                // Exponential atmosphere model
                const scaleHeight = 8500; // meters
                return 1.225 * Math.exp(-altitude / scaleHeight);
            }
            
            getTemperature(altitude) {
                // Simplified temperature model
                if (altitude < 11000) return 288.15 - 0.0065 * altitude;
                else if (altitude < 20000) return 216.65;
                else if (altitude < 32000) return 216.65 + 0.001 * (altitude - 20000);
                else if (altitude < 47000) return 228.65 + 0.0028 * (altitude - 32000);
                else return 270.65;
            }
            
            updateRotation(deltaTime) {
                // Apply stability assist
                if (this.stabilityAssist && !this.autopilotActive) {
                    this.applyStabilityAssist(deltaTime);
                }
                
                // Apply autopilot pitch control
                if (this.autopilotActive) {
                    this.applyAutopilotPitch(deltaTime);
                }
                
                // Update rotation from angular velocity
                this.rotation.x += this.angularVelocity.x * deltaTime;
                this.rotation.y += this.angularVelocity.y * deltaTime;
                this.rotation.z += this.angularVelocity.z * deltaTime;
                
                // Apply damping
                const damping = this.altitude < 100000 ? 0.99 : 0.999;
                this.angularVelocity.multiplyScalar(damping);
                
                // Clamp rotation for stability
                this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
            }
            
            applyStabilityAssist(deltaTime) {
                // Dampen unwanted rotations
                const dampingStrength = 0.1;
                
                // Reduce roll
                if (Math.abs(this.angularVelocity.y) > 0.01) {
                    this.angularVelocity.y *= (1 - dampingStrength * deltaTime * 60);
                }
                
                // Keep rocket aligned with velocity vector at high speeds
                if (this.velocity.length() > 100) {
                    const velocityDirection = this.velocity.clone().normalize();
                    const rocketDirection = new THREE.Vector3(0, 1, 0).applyEuler(this.rotation);
                    const angleError = Math.acos(velocityDirection.dot(rocketDirection));
                    
                    if (angleError > 0.1) {
                        const correctionTorque = angleError * 0.1;
                        this.angularVelocity.x += correctionTorque * deltaTime;
                    }
                }
            }
            
            applyAutopilotPitch(deltaTime) {
                // Calculate target pitch based on altitude
                let targetPitch;
                if (this.altitude < 10000) {
                    targetPitch = 90; // Vertical ascent
                } else if (this.altitude < 70000) {
                    targetPitch = 90 - (this.altitude / 10000) * 60; // Gravity turn
                } else {
                    targetPitch = 0; // Horizontal for orbit
                }
                
                // Convert to radians
                targetPitch = targetPitch * (Math.PI / 180);
                
                // Calculate error
                const pitchError = targetPitch - this.rotation.x;
                
                // Apply correction
                if (Math.abs(pitchError) > 0.01) {
                    const correction = pitchError * 0.5;
                    this.angularVelocity.x += correction * deltaTime;
                }
            }
            
            calculateTotalMass() {
                let mass = this.payloadMass;
                
                this.stages.forEach(stage => {
                    if (!stage.separated) {
                        mass += stage.dryMass;
                        if (stage.active) {
                            mass += stage.fuelMass * (stage.fuel / 100);
                        }
                    }
                });
                
                this.totalMass = mass;
                return mass;
            }
            
            updateOrbitalParameters() {
                // Calculate orbital velocity
                const distance = this.position.length();
                const orbitalVelocity = Math.sqrt(this.GRAVITY_CONSTANT * this.EARTH_MASS / distance);
                this.orbitalVelocity = orbitalVelocity;
                
                // Calculate current velocity components
                const verticalVelocity = this.velocity.dot(this.position.clone().normalize());
                const horizontalVelocity = Math.sqrt(Math.pow(this.velocity.length(), 2) - Math.pow(verticalVelocity, 2));
                
                // Update UI
                this.ui.verticalVelocity.textContent = verticalVelocity.toFixed(1) + " m/s";
                this.ui.horizontalVelocity.textContent = horizontalVelocity.toFixed(1) + " m/s";
                
                // Calculate orbital elements (simplified)
                if (horizontalVelocity > orbitalVelocity * 0.9) {
                    // Calculate semi-major axis
                    const specificEnergy = Math.pow(this.velocity.length(), 2) / 2 - 
                                         (this.GRAVITY_CONSTANT * this.EARTH_MASS) / distance;
                    const semiMajorAxis = -(this.GRAVITY_CONSTANT * this.EARTH_MASS) / (2 * specificEnergy);
                    
                    // Calculate apoapsis and periapsis
                    const eccentricity = Math.sqrt(1 - (Math.pow(horizontalVelocity * distance, 2) / 
                                                     (this.GRAVITY_CONSTANT * this.EARTH_MASS * semiMajorAxis)));
                    
                    const apoapsis = semiMajorAxis * (1 + eccentricity) - this.EARTH_RADIUS;
                    const periapsis = semiMajorAxis * (1 - eccentricity) - this.EARTH_RADIUS;
                    
                    this.ui.apoapsis.textContent = (apoapsis / 1000).toFixed(1) + " km";
                    this.ui.periapsis.textContent = (periapsis / 1000).toFixed(1) + " km";
                    
                    // Calculate orbital period
                    this.orbitPeriod = 2 * Math.PI * Math.sqrt(Math.pow(semiMajorAxis, 3) / 
                                                             (this.GRAVITY_CONSTANT * this.EARTH_MASS));
                }
                
                // Update orbit status
                const currentVelocity = this.velocity.length();
                const escapeVelocity = Math.sqrt(2) * orbitalVelocity;
                
                if (currentVelocity > escapeVelocity) {
                    this.ui.orbitStatus.textContent = "ESCAPE";
                    this.ui.orbitStatus.className = "critical";
                } else if (currentVelocity > orbitalVelocity * 0.95 && this.altitude > 100000) {
                    this.ui.orbitStatus.textContent = "ORBITAL";
                    this.ui.orbitStatus.className = "success";
                } else if (this.altitude > 100000) {
                    this.ui.orbitStatus.textContent = "SUBORBITAL";
                    this.ui.orbitStatus.className = "";
                } else {
                    this.ui.orbitStatus.textContent = "ASCENDING";
                    this.ui.orbitStatus.className = "";
                }
            }
            
            updateSeparatedObjects(deltaTime) {
                // Update separated stages
                this.stages.forEach(stage => {
                    if (stage.separated && stage.visualObject) {
                        // Apply gravity
                        const distance = stage.visualObject.position.length();
                        const gravityMagnitude = this.GRAVITY_CONSTANT * this.EARTH_MASS / Math.pow(distance, 2);
                        const gravityVector = stage.visualObject.position.clone().normalize().multiplyScalar(-gravityMagnitude);
                        
                        // Update stored velocity if not exists
                        if (!stage.separationVelocity) {
                            stage.separationVelocity = new THREE.Vector3(
                                (Math.random() - 0.5) * 10,
                                -5,
                                (Math.random() - 0.5) * 10
                            );
                        }
                        
                        // Update velocity and position
                        stage.separationVelocity.add(gravityVector.multiplyScalar(deltaTime));
                        stage.visualObject.position.add(stage.separationVelocity.clone().multiplyScalar(deltaTime));
                        
                        // Add rotation
                        stage.visualObject.rotation.x += 0.5 * deltaTime;
                        stage.visualObject.rotation.y += 0.3 * deltaTime;
                        
                        // Atmospheric drag for lower stages
                        if (distance - this.EARTH_RADIUS < 100000) {
                            const airDensity = this.getAirDensity(distance - this.EARTH_RADIUS);
                            const dragMagnitude = 0.5 * airDensity * Math.pow(stage.separationVelocity.length(), 2) * 
                                                 this.dragCoefficient.subsonic * 5;
                            const dragForce = stage.separationVelocity.clone().normalize().multiplyScalar(-dragMagnitude);
                            stage.separationVelocity.add(dragForce.divideScalar(stage.dryMass).multiplyScalar(deltaTime));
                        }
                    }
                });
            }
            
            // ============================================================================
            // STAGE SEPARATION SYSTEM
            // ============================================================================
            
            separateCurrentStage() {
                if (this.currentStageIndex >= this.stages.length - 1) {
                    console.log("Cannot separate last stage");
                    return;
                }
                
                const currentStage = this.stages[this.currentStageIndex];
                if (currentStage.separated || !currentStage.active) return;
                
                console.log(`Separating stage ${currentStage.id}`);
                
                // Mark current stage as separated
                currentStage.separated = true;
                currentStage.active = false;
                
                // Activate next stage
                this.currentStageIndex++;
                const nextStage = this.stages[this.currentStageIndex];
                nextStage.active = true;
                
                // Create separation effect
                this.createStageSeparationEffect(currentStage);
                
                // Remove lower part from rocket assembly
                this.removeSeparatedStage(currentStage);
                
                // Update UI
                this.updateStageUI();
                this.updateAllUI();
                
                // Play separation effects
                this.playSeparationEffects(currentStage);
            }
            
            removeSeparatedStage(stage) {
                if (!stage.visualObject || !this.rocket) return;
                
                // Calculate the position where separation occurs
                let separationY = 0;
                for (let i = 0; i < this.currentStageIndex; i++) {
                    separationY += this.stages[i].properties.length + (this.stages[i].interstageHeight || 0);
                }
                
                // Create a new group for the separated stage
                const separatedGroup = stage.visualObject.clone();
                
                // Position it at current rocket position
                separatedGroup.position.copy(this.position);
                separatedGroup.rotation.copy(this.rotation);
                
                // Adjust vertical position to match separation point
                const localSeparationPoint = new THREE.Vector3(0, -separationY, 0);
                localSeparationPoint.applyEuler(this.rotation);
                separatedGroup.position.add(localSeparationPoint);
                
                // Add to scene
                this.scene.add(separatedGroup);
                
                // Store reference
                stage.separatedObject = separatedGroup;
                
                // Remove from rocket (make invisible instead of removing)
                stage.visualObject.visible = false;
                
                // Disable exhaust systems
                stage.exhaustSystems.forEach(system => {
                    system.visible = false;
                });
                
                console.log(`Stage ${stage.id} separated and removed from rocket`);
            }
            
            createStageSeparationEffect(stage) {
                // Create explosion particles at separation plane
                const separationPoint = this.calculateSeparationPoint(stage);
                
                // Create multiple explosion effects
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        this.createExplosionEffect(
                            separationPoint.clone().add(new THREE.Vector3(
                                (Math.random() - 0.5) * 5,
                                (Math.random() - 0.5) * 5,
                                (Math.random() - 0.5) * 5
                            )),
                            0xff5500,
                            50
                        );
                    }, i * 100);
                }
                
                // Create debris particles
                this.createSeparationDebris(separationPoint, stage);
            }
            
            calculateSeparationPoint(stage) {
                // Calculate separation point in world coordinates
                let offsetY = 0;
                for (let i = 0; i < stage.id - 1; i++) {
                    offsetY += this.stages[i].properties.length + (this.stages[i].interstageHeight || 0);
                }
                offsetY += stage.properties.length;
                
                const localPoint = new THREE.Vector3(0, -offsetY, 0);
                localPoint.applyEuler(this.rotation);
                
                return this.position.clone().add(localPoint);
            }
            
            createExplosionEffect(position, color, particleCount = 100) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                
                const baseColor = new THREE.Color(color);
                
                for (let i = 0; i < particleCount; i++) {
                    // Start at explosion center
                    positions[i * 3] = position.x;
                    positions[i * 3 + 1] = position.y;
                    positions[i * 3 + 2] = position.z;
                    
                    // Color with variation
                    const hueShift = (Math.random() - 0.5) * 0.3;
                    const particleColor = baseColor.clone().offsetHSL(hueShift, 0.2, 0.1);
                    colors[i * 3] = particleColor.r;
                    colors[i * 3 + 1] = particleColor.g;
                    colors[i * 3 + 2] = particleColor.b;
                    
                    // Random outward velocity
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    );
                    velocities[i * 3] = velocity.x;
                    velocities[i * 3 + 1] = velocity.y;
                    velocities[i * 3 + 2] = velocity.z;
                    
                    lifetimes[i] = 1.0 + Math.random() * 0.5;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const particles = new THREE.Points(geometry, material);
                particles.userData = {
                    velocities: velocities,
                    lifetimes: lifetimes,
                    type: 'explosion'
                };
                
                this.scene.add(particles);
                this.separationEffects.push(particles);
            }
            
            createSeparationDebris(position, stage) {
                // Create debris pieces from separated stage
                const debrisCount = 10;
                
                for (let i = 0; i < debrisCount; i++) {
                    const debrisGeometry = new THREE.BoxGeometry(
                        0.5 + Math.random() * 2,
                        0.5 + Math.random() * 2,
                        0.5 + Math.random() * 2
                    );
                    const debrisMaterial = new THREE.MeshPhongMaterial({
                        color: 0x888888,
                        shininess: 30
                    });
                    
                    const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                    debris.position.copy(position);
                    debris.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    ));
                    
                    // Random rotation
                    debris.rotation.x = Math.random() * Math.PI;
                    debris.rotation.y = Math.random() * Math.PI;
                    debris.rotation.z = Math.random() * Math.PI;
                    
                    // Random velocity
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 15
                    );
                    
                    debris.userData = {
                        velocity: velocity,
                        angularVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        ),
                        lifetime: 10 + Math.random() * 20
                    };
                    
                    this.scene.add(debris);
                    this.stageDebris.push(debris);
                }
            }
            
            playSeparationEffects(stage) {
                // Visual feedback
                document.body.classList.add('vibrate');
                setTimeout(() => {
                    document.body.classList.remove('vibrate');
                }, 300);
                
                // Update stage status
                const stageElement = document.getElementById(`stage${stage.id}Detail`);
                if (stageElement) {
                    stageElement.classList.remove('active');
                    stageElement.classList.add('separated');
                    
                    const statusElement = stageElement.querySelector('.stage-status');
                    if (statusElement) {
                        statusElement.textContent = "SEPARATED";
                        statusElement.className = "stage-status critical";
                    }
                }
            }
            
            jettisonFairing() {
                if (!this.fairingAttached) return;
                
                this.fairingAttached = false;
                this.ui.fairingStatus.textContent = "JETTISONED";
                
                // Animate fairing separation
                this.fairingObjects.forEach((fairing, index) => {
                    const direction = index === 0 ? 1 : -1;
                    const velocity = new THREE.Vector3(
                        direction * 2,
                        Math.random() * 0.5,
                        0
                    );
                    
                    fairing.userData = {
                        velocity: velocity,
                        angularVelocity: new THREE.Vector3(0, direction * 0.5, 0),
                        separated: true
                    };
                });
                
                // Show satellite
                if (this.payloadObject) {
                    this.payloadObject.visible = true;
                }
            }
            
            // ============================================================================
            // FUEL AND PROPULSION SYSTEM
            // ============================================================================
            
            selectFuel(fuelType) {
                this.selectedFuel = fuelType;
                
                // Update UI
                this.ui.fuelTypes.forEach(type => {
                    type.classList.toggle('selected', type.dataset.fuel === fuelType);
                });
                
                this.updateEfficiency();
            }
            
            updateEfficiency() {
                const fuelData = this.fuelDatabase[this.selectedFuel];
                if (!fuelData) return;
                
                const optimalRatio = fuelData.mixtureOptimal;
                const efficiency = 1 - Math.abs(this.mixtureRatio - optimalRatio) / optimalRatio;
                const efficiencyPercent = Math.max(0, Math.min(100, efficiency * 100));
                
                // Update marker position
                const markerPos = (this.mixtureRatio - 1) / 7 * 100;
                this.ui.efficiencyMarker.style.left = `${markerPos}%`;
                
                // Update efficiency value
                this.ui.efficiencyValue.textContent = `${efficiencyPercent.toFixed(1)}%`;
                
                // Update color based on efficiency
                let color;
                if (efficiencyPercent > 85) color = '#00ff00';
                else if (efficiencyPercent > 70) color = '#ffff00';
                else color = '#ff0000';
                
                this.ui.efficiencyValue.style.color = color;
            }
            
            applyFuelConfiguration() {
                // Apply selected fuel to current stage
                const currentStage = this.stages[this.currentStageIndex];
                if (currentStage) {
                    currentStage.fuelType = this.selectedFuel;
                    
                    // Update visual appearance
                    this.updateStageAppearance(currentStage);
                    
                    // Show confirmation
                    const button = this.ui.applyFuelBtn;
                    const originalText = button.textContent;
                    button.textContent = "‚úì APPLIED";
                    button.style.background = 'linear-gradient(45deg, #00aa00, #00ff00)';
                    
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = 'linear-gradient(45deg, #0066cc, #00aaff)';
                    }, 2000);
                }
            }
            
            updateStageAppearance(stage) {
                if (!stage.visualObject) return;
                
                const fuelData = this.fuelDatabase[stage.fuelType];
                const fuelColor = fuelData ? fuelData.color : 0x888888;
                
                // Update fuel tank color
                stage.visualObject.traverse(child => {
                    if (child.isMesh && child.material.opacity === 0.7) {
                        child.material.color.setHex(fuelColor);
                    }
                });
            }
            
            consumeRCSFuel(amount) {
                this.rcsFuel = Math.max(0, this.rcsFuel - amount * 10);
                if (this.rcsFuel <= 0) {
                    this.rcsActive = false;
                    this.ui.rcsStatus.textContent = 'OFF';
                }
            }
            
            // ============================================================================
            // VISUAL UPDATES
            // ============================================================================
            
            updateVisuals(deltaTime) {
                // Update rocket position and rotation
                if (this.rocket) {
                    this.rocket.position.copy(this.position);
                    this.rocket.rotation.copy(this.rotation);
                    
                    // Scale based on distance
                    const cameraDistance = this.camera.position.distanceTo(this.position);
                    const scale = Math.min(1, 1000 / cameraDistance);
                    this.rocket.scale.setScalar(scale);
                }
                
                // Update exhaust particles
                this.updateExhaustParticles(deltaTime);
                
                // Update RCS particles
                this.updateRCSParticles(deltaTime);
                
                // Update separation effects
                this.updateSeparationEffects(deltaTime);
                
                // Update debris
                this.updateDebris(deltaTime);
                
                // Update fairing separation
                this.updateFairingSeparation(deltaTime);
                
                // Update camera
                this.updateCamera(deltaTime);
                
                // Rotate Earth and clouds
                if (this.earth) {
                    this.earth.rotation.y += 0.1 * deltaTime;
                }
                if (this.clouds) {
                    this.clouds.rotation.y += 0.15 * deltaTime;
                }
            }
            
            updateExhaustParticles(deltaTime) {
                const currentStage = this.stages[this.currentStageIndex];
                if (!currentStage || !currentStage.exhaustSystems) return;
                
                const isActive = currentStage.active && !currentStage.separated && 
                               currentStage.fuel > 0 && this.throttle > 0;
                
                currentStage.exhaustSystems.forEach((particleSystem, engineIndex) => {
                    const positions = particleSystem.geometry.attributes.position.array;
                    const velocities = particleSystem.userData.velocities;
                    const lifetimes = particleSystem.userData.lifetimes;
                    
                    const spawnRate = isActive ? this.throttle * 0.8 : 0;
                    const fuelData = this.fuelDatabase[currentStage.fuelType];
                    const exhaustVelocity = fuelData ? fuelData.exhaustVelocity * 0.001 : 3;
                    
                    for (let i = 0; i < positions.length / 3; i++) {
                        if (isActive && Math.random() < spawnRate * deltaTime * 60 && lifetimes[i] <= 0) {
                            // Spawn new particle
                            const angle = (engineIndex / currentStage.engines) * Math.PI * 2;
                            const distance = currentStage.id === 1 ? 2 : 1.5;
                            
                            positions[i * 3] = Math.cos(angle) * distance;
                            positions[i * 3 + 1] = 0;
                            positions[i * 3 + 2] = Math.sin(angle) * distance;
                            
                            // Initial velocity (downward with some spread)
                            velocities[i * 3] = (Math.random() - 0.5) * 0.3;
                            velocities[i * 3 + 1] = -exhaustVelocity - Math.random() * 2;
                            velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.3;
                            
                            lifetimes[i] = 1.0;
                        } else if (lifetimes[i] > 0) {
                            // Update existing particle
                            positions[i * 3] += velocities[i * 3] * deltaTime * 60;
                            positions[i * 3 + 1] += velocities[i * 3 + 1] * deltaTime * 60;
                            positions[i * 3 + 2] += velocities[i * 3 + 2] * deltaTime * 60;
                            
                            lifetimes[i] -= deltaTime * 2;
                            
                            // Atmospheric effects
                            if (this.altitude < 50000) {
                                velocities[i * 3 + 1] += 9.81 * deltaTime;
                                // Drag
                                const drag = 0.1;
                                velocities[i * 3] *= (1 - drag * deltaTime);
                                velocities[i * 3 + 1] *= (1 - drag * deltaTime);
                                velocities[i * 3 + 2] *= (1 - drag * deltaTime);
                            }
                        }
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                    
                    // Update particle appearance
                    particleSystem.material.opacity = isActive ? 0.3 + this.throttle * 0.7 : 0;
                    particleSystem.material.size = 0.5 + this.throttle * 1.5;
                });
            }
            
            updateRCSParticles(deltaTime) {
                // Update RCS thruster particles
                this.rcsParticles.forEach(rcsGroup => {
                    const particleSystem = rcsGroup.userData.particleSystem;
                    if (!particleSystem) return;
                    
                    const positions = particleSystem.geometry.attributes.position.array;
                    const velocities = particleSystem.userData.velocities;
                    const lifetimes = particleSystem.userData.lifetimes;
                    
                    // Check if this thruster should be active
                    const isActive = this.checkRCSActive(rcsGroup);
                    
                    if (isActive && this.rcsFuel > 0) {
                        // Spawn particles
                        for (let i = 0; i < positions.length / 3; i++) {
                            if (Math.random() < 0.5 * deltaTime * 60 && lifetimes[i] <= 0) {
                                // Spawn at nozzle
                                positions[i * 3] = 0;
                                positions[i * 3 + 1] = 0;
                                positions[i * 3 + 2] = 0;
                                
                                // Velocity in thrust direction
                                const direction = this.getRCSDirection(rcsGroup);
                                velocities[i * 3] = direction.x * 10;
                                velocities[i * 3 + 1] = direction.y * 10;
                                velocities[i * 3 + 2] = direction.z * 10;
                                
                                lifetimes[i] = 0.5 + Math.random() * 0.5;
                            } else if (lifetimes[i] > 0) {
                                // Update particle
                                positions[i * 3] += velocities[i * 3] * deltaTime * 60;
                                positions[i * 3 + 1] += velocities[i * 3 + 1] * deltaTime * 60;
                                positions[i * 3 + 2] += velocities[i * 3 + 2] * deltaTime * 60;
                                
                                lifetimes[i] -= deltaTime * 2;
                            }
                        }
                        
                        particleSystem.geometry.attributes.position.needsUpdate = true;
                        particleSystem.material.opacity = 0.7;
                    } else {
                        particleSystem.material.opacity = 0;
                    }
                });
            }
            
            checkRCSActive(rcsGroup) {
                // Simplified: check if any RCS thrusters are active
                return Object.values(this.rcsThrusters).some(active => active);
            }
            
            getRCSDirection(rcsGroup) {
                // Get thrust direction based on RCS position
                const position = rcsGroup.position;
                
                // Simple direction calculation based on position
                if (position.y > 0) {
                    // Upper thrusters point down
                    return new THREE.Vector3(0, -1, 0);
                } else {
                    // Lower thrusters point up
                    return new THREE.Vector3(0, 1, 0);
                }
            }
            
            updateSeparationEffects(deltaTime) {
                // Update explosion particles
                for (let i = this.separationEffects.length - 1; i >= 0; i--) {
                    const particles = this.separationEffects[i];
                    const positions = particles.geometry.attributes.position.array;
                    const velocities = particles.userData.velocities;
                    const lifetimes = particles.userData.lifetimes;
                    
                    let allDead = true;
                    
                    for (let j = 0; j < positions.length / 3; j++) {
                        if (lifetimes[j] > 0) {
                            allDead = false;
                            
                            // Update position
                            positions[j * 3] += velocities[j * 3] * deltaTime * 60;
                            positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime * 60;
                            positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime * 60;
                            
                            // Apply gravity
                            velocities[j * 3 + 1] -= 9.81 * deltaTime;
                            
                            lifetimes[j] -= deltaTime;
                            
                            // Fade out
                            particles.material.opacity = Math.min(1, lifetimes[j]);
                        }
                    }
                    
                    particles.geometry.attributes.position.needsUpdate = true;
                    
                    if (allDead) {
                        this.scene.remove(particles);
                        this.separationEffects.splice(i, 1);
                    }
                }
            }
            
            updateDebris(deltaTime) {
                // Update stage debris
                for (let i = this.stageDebris.length - 1; i >= 0; i--) {
                    const debris = this.stageDebris[i];
                    
                    if (debris.userData.lifetime <= 0) {
                        this.scene.remove(debris);
                        this.stageDebris.splice(i, 1);
                        continue;
                    }
                    
                    // Apply gravity
                    const distance = debris.position.length();
                    const gravityMagnitude = this.GRAVITY_CONSTANT * this.EARTH_MASS / Math.pow(distance, 2);
                    const gravityVector = debris.position.clone().normalize().multiplyScalar(-gravityMagnitude);
                    
                    // Update velocity and position
                    debris.userData.velocity.add(gravityVector.multiplyScalar(deltaTime));
                    debris.position.add(debris.userData.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Update rotation
                    debris.rotation.x += debris.userData.angularVelocity.x * deltaTime;
                    debris.rotation.y += debris.userData.angularVelocity.y * deltaTime;
                    debris.rotation.z += debris.userData.angularVelocity.z * deltaTime;
                    
                    debris.userData.lifetime -= deltaTime;
                    
                    // Atmospheric drag
                    if (distance - this.EARTH_RADIUS < 100000) {
                        const airDensity = this.getAirDensity(distance - this.EARTH_RADIUS);
                        const dragMagnitude = 0.5 * airDensity * Math.pow(debris.userData.velocity.length(), 2) * 0.5;
                        const dragForce = debris.userData.velocity.clone().normalize().multiplyScalar(-dragMagnitude);
                        debris.userData.velocity.add(dragForce.multiplyScalar(deltaTime));
                    }
                }
            }
            
            updateFairingSeparation(deltaTime) {
                if (!this.fairingAttached) {
                    this.fairingObjects.forEach(fairing => {
                        if (fairing.userData.separated) {
                            // Update position
                            fairing.position.add(fairing.userData.velocity.clone().multiplyScalar(deltaTime));
                            
                            // Update rotation
                            fairing.rotation.x += fairing.userData.angularVelocity.x * deltaTime;
                            fairing.rotation.y += fairing.userData.angularVelocity.y * deltaTime;
                            fairing.rotation.z += fairing.userData.angularVelocity.z * deltaTime;
                            
                            // Apply gravity
                            const distance = fairing.position.length();
                            const gravityMagnitude = this.GRAVITY_CONSTANT * this.EARTH_MASS / Math.pow(distance, 2);
                            const gravityVector = fairing.position.clone().normalize().multiplyScalar(-gravityMagnitude);
                            fairing.userData.velocity.add(gravityVector.multiplyScalar(deltaTime));
                        }
                    });
                }
            }
            
            updateCamera(deltaTime) {
                // Smooth camera following
                const cameraDistance = 200 + this.altitude * 0.0005;
                const cameraHeight = 50 + this.altitude * 0.001;
                
                const targetPosition = new THREE.Vector3(
                    this.position.x + Math.sin(this.rotation.y) * cameraDistance,
                    this.position.y + cameraHeight,
                    this.position.z + Math.cos(this.rotation.y) * cameraDistance
                );
                
                // Smooth interpolation
                this.camera.position.lerp(targetPosition, 0.05);
                this.camera.lookAt(this.position);
                
                // Dynamic FOV based on speed
                const speedFactor = Math.min(1, this.velocity.length() / 1000);
                this.camera.fov = 60 + speedFactor * 20;
                this.camera.updateProjectionMatrix();
            }
            
            // ============================================================================
            // UI UPDATES
            // ============================================================================
            
            updateAllUI() {
                // Update telemetry
                this.ui.altitude.textContent = (this.altitude / 1000).toFixed(1) + " km";
                this.ui.velocity.textContent = this.velocity.length().toFixed(1) + " m/s";
                this.ui.acceleration.textContent = (this.acceleration.length() / 9.81).toFixed(2) + " g";
                this.ui.apogee.textContent = (this.apogee / 1000).toFixed(1) + " km";
                this.ui.machNumber.textContent = this.machNumber.toFixed(2);
                
                // Calculate Delta-V remaining
                let deltaVRemaining = 0;
                this.stages.forEach((stage, index) => {
                    if (!stage.separated && (stage.active || index >= this.currentStageIndex)) {
                        const isp = stage.ispVac;
                        const g0 = 9.81;
                        const massWithFuel = this.totalMass;
                        const massWithoutFuel = massWithFuel - (stage.fuelMass * stage.fuel / 100);
                        if (massWithoutFuel > 0) {
                            deltaVRemaining += isp * g0 * Math.log(massWithFuel / massWithoutFuel);
                        }
                    }
                });
                this.ui.deltaV.textContent = deltaVRemaining.toFixed(0) + " m/s";
                
                // Update thrust display
                const currentStage = this.stages[this.currentStageIndex];
                const thrust = currentStage ? this.calculateStageThrust(currentStage) * this.throttle : 0;
                this.ui.thrust.textContent = (thrust / 1000).toFixed(0) + " kN";
                
                // Update stage UI
                this.updateStageUI();
                
                // Update RCS display
                this.ui.rcsFuelLevel.textContent = this.rcsFuel.toFixed(1) + "%";
                this.ui.rcsFuelDisplay.textContent = this.rcsFuel.toFixed(1) + "%";
                
                // Update total mass
                this.ui.totalMass.textContent = this.totalMass.toFixed(0) + " kg";
                this.ui.fuelMass.textContent = this.calculateFuelMass().toFixed(0) + " kg";
                this.ui.payloadMass.textContent = this.payloadMass + " kg";
                
                // Update current stage
                this.ui.currentStageDisplay.textContent = this.currentStageIndex + 1;
                
                // Update performance
                this.ui.objectCount.textContent = this.scene.children.length;
            }
            
            updateStageUI() {
                this.stages.forEach((stage, index) => {
                    const stageElement = document.getElementById(`stage${index + 1}Detail`);
                    const fuelElement = document.getElementById(`stage${index + 1}Fuel`);
                    const massElement = document.getElementById(`stage${index + 1}Mass`);
                    const thrustElement = document.getElementById(`stage${index + 1}Thrust`);
                    const ispElement = document.getElementById(`stage${index + 1}ISP`);
                    
                    if (stageElement) {
                        stageElement.classList.toggle('active', stage.active && !stage.separated);
                        stageElement.classList.toggle('separated', stage.separated);
                        
                        const statusElement = stageElement.querySelector('.stage-status');
                        if (statusElement) {
                            if (stage.separated) {
                                statusElement.textContent = "SEPARATED";
                                statusElement.className = "stage-status critical";
                            } else if (stage.active) {
                                statusElement.textContent = "ACTIVE";
                                statusElement.className = "stage-status success";
                            } else {
                                statusElement.textContent = "INACTIVE";
                                statusElement.className = "stage-status";
                            }
                        }
                    }
                    
                    if (fuelElement) {
                        fuelElement.textContent = stage.fuel.toFixed(1) + "%";
                        // Update fuel bar
                        const fuelBar = stageElement?.querySelector('.fuel-fill');
                        if (fuelBar) {
                            fuelBar.style.width = stage.fuel + "%";
                            // Change color based on fuel level
                            if (stage.fuel < 10) {
                                fuelBar.style.background = "#ff0000";
                            } else if (stage.fuel < 30) {
                                fuelBar.style.background = "#ffaa00";
                            }
                        }
                    }
                    
                    if (massElement) {
                        const mass = stage.dryMass + (stage.fuelMass * stage.fuel / 100);
                        massElement.textContent = mass.toFixed(0) + " kg";
                    }
                    
                    if (thrustElement) {
                        const thrust = this.calculateStageThrust(stage) / 1000;
                        thrustElement.textContent = thrust.toFixed(0) + " kN";
                    }
                    
                    if (ispElement) {
                        ispElement.textContent = stage.ispVac + "s";
                    }
                });
            }
            
            calculateFuelMass() {
                let totalFuel = 0;
                this.stages.forEach(stage => {
                    if (!stage.separated) {
                        totalFuel += stage.fuelMass * (stage.fuel / 100);
                    }
                });
                return totalFuel;
            }
            
            togglePanel(panelName) {
                const panel = this.ui[`${panelName}Panel`];
                if (panel) {
                    panel.classList.toggle('collapsed');
                }
            }
            
            updateControlMode() {
                // Show/hide mobile controls based on mode
                const isMobile = window.innerWidth < 768;
                
                switch(this.controlMode) {
                    case 'keyboard':
                    case 'auto':
                        this.ui.mobileControls.style.display = 'none';
                        break;
                    case 'gyro':
                        if (isMobile && this.gyroAvailable) {
                            this.ui.mobileControls.style.display = 'flex';
                        }
                        break;
                }
            }
            
            // ============================================================================
            // EVENT HANDLERS
            // ============================================================================
            
            handleGyro(event) {
                this.gyroData.alpha = event.alpha || 0;
                this.gyroData.beta = event.beta || 0;
                this.gyroData.gamma = event.gamma || 0;
                
                if (this.controlMode === 'gyro') {
                    // Map gyro data to rocket rotation
                    const sensitivity = 0.005;
                    this.angularVelocity.x = this.gyroData.beta * sensitivity;
                    this.angularVelocity.z = -this.gyroData.gamma * sensitivity;
                }
            }
            
            handleKeyDown(event) {
                switch(event.key) {
                    case ' ':
                        this.throttle = 1.0;
                        this.ui.throttleSlider.value = 100;
                        this.ui.throttleValue.textContent = "100";
                        break;
                    case 's':
                    case 'S':
                        this.separateCurrentStage();
                        break;
                    case 'r':
                    case 'R':
                        this.rcsActive = !this.rcsActive;
                        this.ui.rcsStatus.textContent = this.rcsActive ? 'ON' : 'OFF';
                        break;
                    case 'ArrowUp':
                        this.rcsThrusters.pitchDown = true;
                        break;
                    case 'ArrowDown':
                        this.rcsThrusters.pitchUp = true;
                        break;
                    case 'ArrowLeft':
                        this.rcsThrusters.yawRight = true;
                        break;
                    case 'ArrowRight':
                        this.rcsThrusters.yawLeft = true;
                        break;
                    case 'q':
                    case 'Q':
                        this.rcsThrusters.rollLeft = true;
                        break;
                    case 'e':
                    case 'E':
                        this.rcsThrusters.rollRight = true;
                        break;
                    case 'w':
                    case 'W':
                        this.rcsThrusters.translateUp = true;
                        break;
                    case 'a':
                    case 'A':
                        this.rcsThrusters.translateLeft = true;
                        break;
                    case 'd':
                    case 'D':
                        this.rcsThrusters.translateRight = true;
                        break;
                    case 'x':
                    case 'X':
                        this.rcsThrusters.translateDown = true;
                        break;
                    case 'f':
                    case 'F':
                        this.jettisonFairing();
                        break;
                }
            }
            
            handleKeyUp(event) {
                switch(event.key) {
                    case ' ':
                        this.throttle = 0;
                        this.ui.throttleSlider.value = 0;
                        this.ui.throttleValue.textContent = "0";
                        break;
                    case 'ArrowUp':
                        this.rcsThrusters.pitchDown = false;
                        break;
                    case 'ArrowDown':
                        this.rcsThrusters.pitchUp = false;
                        break;
                    case 'ArrowLeft':
                        this.rcsThrusters.yawRight = false;
                        break;
                    case 'ArrowRight':
                        this.rcsThrusters.yawLeft = false;
                        break;
                    case 'q':
                    case 'Q':
                        this.rcsThrusters.rollLeft = false;
                        break;
                    case 'e':
                    case 'E':
                        this.rcsThrusters.rollRight = false;
                        break;
                    case 'w':
                    case 'W':
                        this.rcsThrusters.translateUp = false;
                        break;
                    case 'a':
                    case 'A':
                        this.rcsThrusters.translateLeft = false;
                        break;
                    case 'd':
                    case 'D':
                        this.rcsThrusters.translateRight = false;
                        break;
                    case 'x':
                    case 'X':
                        this.rcsThrusters.translateDown = false;
                        break;
                }
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // ============================================================================
            // ANIMATION LOOP
            // ============================================================================
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Calculate delta time
                this.deltaTime = this.clock.getDelta();
                
                // Update FPS counter
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFpsUpdate >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
                    this.ui.fpsCounter.textContent = this.fps;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
                
                // Update physics
                this.updatePhysics(this.deltaTime);
                
                // Update visuals
                this.updateVisuals(this.deltaTime);
                
                // Update UI
                this.updateAllUI();
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize simulator when page loads
        window.addEventListener('load', () => {
            const simulator = new AdvancedRocketSimulator();
            window.simulator = simulator; // Make accessible for debugging
            
            // Prevent default touch behaviors
            document.addEventListener('touchmove', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') return;
                e.preventDefault();
            }, { passive: false });
            
            // Prevent context menu
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        });
    </script>
</body>
</html>