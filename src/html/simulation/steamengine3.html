<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-device-width, initial-scale=1.0">
    <title>Three.js Ultimate Steam Engine - Complete Mechanical System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        #engineering-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 380px;
            background: rgba(10, 10, 15, 0.97);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }
        
        .panel-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.2);
        }
        
        .section-title {
            color: #4fc3f7;
            margin-bottom: 15px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: bold;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }
        
        .control-item {
            display: flex;
            flex-direction: column;
        }
        
        .control-label {
            font-size: 0.85rem;
            color: #b0b0c0;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        
        .control-label i {
            margin-right: 8px;
            color: #4fc3f7;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #0d47a1, #1565c0, #1976d2);
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.8);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }
        
        .engine-button {
            background: linear-gradient(135deg, #1a237e 0%, #283593 100%);
            color: white;
            border: 1px solid #3949ab;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .engine-button:hover {
            background: linear-gradient(135deg, #283593 0%, #3949ab 100%);
            border-color: #4fc3f7;
            box-shadow: 0 0 15px rgba(79, 195, 247, 0.4);
            transform: translateY(-1px);
        }
        
        .engine-button.active {
            background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 100%);
            border-color: #4fc3f7;
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.6);
        }
        
        #component-inspector {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 400px;
            background: rgba(10, 10, 15, 0.97);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .inspector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.2);
        }
        
        .component-properties {
            margin-top: 15px;
        }
        
        .property-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .property-name {
            color: #b0b0c0;
            font-size: 0.85rem;
        }
        
        .property-value {
            color: #81c784;
            font-size: 0.85rem;
            font-weight: bold;
        }
        
        #telemetry-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 350px;
            background: rgba(10, 10, 15, 0.97);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        .telemetry-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .telemetry-item {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .telemetry-value {
            font-size: 1.5rem;
            color: #4fc3f7;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .telemetry-label {
            font-size: 0.8rem;
            color: #b0b0c0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .telemetry-unit {
            font-size: 0.75rem;
            color: #888;
        }
        
        #visualization-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 15, 0.97);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        .viz-button {
            background: rgba(30, 30, 45, 0.8);
            color: white;
            border: 1px solid rgba(79, 195, 247, 0.3);
            padding: 8px 12px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .viz-button:hover {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
        }
        
        .viz-button.active {
            background: rgba(79, 195, 247, 0.4);
            border-color: #4fc3f7;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.3);
        }
        
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #29b6f6);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .loading-text {
            color: #4fc3f7;
            font-size: 1.2rem;
            margin-top: 20px;
            text-align: center;
        }
        
        .loading-detail {
            color: #888;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        .component-tree {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .tree-node {
            padding: 5px 10px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85rem;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }
        
        .tree-node:hover {
            background: rgba(79, 195, 247, 0.1);
            border-left-color: #4fc3f7;
        }
        
        .tree-node.selected {
            background: rgba(79, 195, 247, 0.2);
            border-left-color: #4fc3f7;
            color: #4fc3f7;
        }
        
        .tree-children {
            padding-left: 20px;
            margin-left: 10px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .material-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="engineering-panel">
            <div class="panel-section">
                <div class="section-title">‚öô ENGINE CONTROL SYSTEM</div>
                <div class="button-group">
                    <button class="engine-button" id="btn-ignition">IGNITION</button>
                    <button class="engine-button" id="btn-start">START</button>
                    <button class="engine-button" id="btn-stop">STOP</button>
                    <button class="engine-button" id="btn-reverse">REVERSE</button>
                    <button class="engine-button" id="btn-emergency">E-STOP</button>
                    <button class="engine-button" id="btn-reset">RESET</button>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">üå° THERMODYNAMIC PARAMETERS</div>
                <div class="control-grid">
                    <div class="control-item">
                        <div class="control-label"><i>üî•</i>Boiler Pressure</div>
                        <input type="range" class="slider" id="slider-pressure" min="0" max="200" value="100">
                        <span class="telemetry-unit" id="pressure-value">100 PSI</span>
                    </div>
                    <div class="control-item">
                        <div class="control-label"><i>üå°</i>Steam Temperature</div>
                        <input type="range" class="slider" id="slider-temperature" min="100" max="400" value="212">
                        <span class="telemetry-unit" id="temperature-value">212¬∞F</span>
                    </div>
                    <div class="control-item">
                        <div class="control-label"><i>‚ö°</i>Throttle Position</div>
                        <input type="range" class="slider" id="slider-throttle" min="0" max="100" value="50">
                        <span class="telemetry-unit" id="throttle-value">50%</span>
                    </div>
                    <div class="control-item">
                        <div class="control-label"><i>‚è±</i>Cut-off Point</div>
                        <input type="range" class="slider" id="slider-cutoff" min="10" max="90" value="60">
                        <span class="telemetry-unit" id="cutoff-value">60%</span>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">üîß MECHANICAL SYSTEMS</div>
                <div class="control-grid">
                    <div class="control-item">
                        <div class="control-label"><i>‚öñ</i>Governor Speed</div>
                        <input type="range" class="slider" id="slider-governor" min="1" max="10" value="5">
                        <span class="telemetry-unit" id="governor-value">5</span>
                    </div>
                    <div class="control-item">
                        <div class="control-label"><i>üõ¢</i>Lubrication Rate</div>
                        <input type="range" class="slider" id="slider-lubrication" min="0" max="100" value="30">
                        <span class="telemetry-unit" id="lubrication-value">30%</span>
                    </div>
                    <div class="control-item">
                        <div class="control-label"><i>‚è∞</i>Valve Timing</div>
                        <input type="range" class="slider" id="slider-valve-timing" min="-20" max="20" value="0">
                        <span class="telemetry-unit" id="timing-value">0¬∞</span>
                    </div>
                    <div class="control-item">
                        <div class="control-label"><i>üî©</i>Fastener Tension</div>
                        <input type="range" class="slider" id="slider-tension" min="0" max="100" value="75">
                        <span class="telemetry-unit" id="tension-value">75%</span>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">üîç ENGINEERING ANALYSIS</div>
                <div class="button-group">
                    <button class="engine-button" id="btn-thermal">THERMAL</button>
                    <button class="engine-button" id="btn-stress">STRESS</button>
                    <button class="engine-button" id="btn-flow">FLOW</button>
                    <button class="engine-button" id="btn-vibration">VIBRATION</button>
                    <button class="engine-button" id="btn-wear">WEAR</button>
                    <button class="engine-button" id="btn-clearance">CLEARANCE</button>
                </div>
            </div>
        </div>
        
        <div id="component-inspector">
            <div class="inspector-header">
                <div class="section-title">üî¨ COMPONENT INSPECTOR</div>
                <div class="telemetry-unit" id="component-count">0 Components</div>
            </div>
            <div id="selected-component-info">
                <div class="property-row">
                    <span class="property-name">Component:</span>
                    <span class="property-value" id="info-name">None Selected</span>
                </div>
                <div class="property-row">
                    <span class="property-name">Material:</span>
                    <span class="property-value" id="info-material">-</span>
                </div>
                <div class="property-row">
                    <span class="property-name">Temperature:</span>
                    <span class="property-value" id="info-temperature">-</span>
                </div>
                <div class="property-row">
                    <span class="property-name">Stress:</span>
                    <span class="property-value" id="info-stress">-</span>
                </div>
                <div class="property-row">
                    <span class="property-name">Wear:</span>
                    <span class="property-value" id="info-wear">-</span>
                </div>
                <div class="property-row">
                    <span class="property-name">Clearance:</span>
                    <span class="property-value" id="info-clearance">-</span>
                </div>
            </div>
            
            <div class="section-title" style="margin-top: 20px;">üìë COMPONENT TREE</div>
            <div class="component-tree" id="component-tree">
                <!-- Component tree will be populated here -->
            </div>
        </div>
        
        <div id="telemetry-panel">
            <div class="section-title">üìä ENGINE TELEMETRY</div>
            <div class="telemetry-grid">
                <div class="telemetry-item">
                    <div class="telemetry-label">RPM</div>
                    <div class="telemetry-value" id="telemetry-rpm">0</div>
                    <div class="telemetry-unit">Revolutions/Min</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">Power</div>
                    <div class="telemetry-value" id="telemetry-power">0</div>
                    <div class="telemetry-unit">Horsepower</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">Torque</div>
                    <div class="telemetry-value" id="telemetry-torque">0</div>
                    <div class="telemetry-unit">lb-ft</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">Efficiency</div>
                    <div class="telemetry-value" id="telemetry-efficiency">0</div>
                    <div class="telemetry-unit">%</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">Steam Flow</div>
                    <div class="telemetry-value" id="telemetry-steam-flow">0</div>
                    <div class="telemetry-unit">lb/hr</div>
                </div>
                <div class="telemetry-item">
                    <div class="telemetry-label">Fuel Rate</div>
                    <div class="telemetry-value" id="telemetry-fuel">0</div>
                    <div class="telemetry-unit">lb/hr</div>
                </div>
            </div>
        </div>
        
        <div id="visualization-controls">
            <div class="section-title">üëÅ VISUALIZATION</div>
            <div>
                <button class="viz-button" id="viz-wireframe">Wireframe</button>
                <button class="viz-button" id="viz-xray">X-Ray</button>
                <button class="viz-button" id="viz-transparent">Transparent</button>
                <button class="viz-button" id="viz-exploded">Exploded</button>
                <button class="viz-button" id="viz-section">Section</button>
                <button class="viz-button" id="viz-normal">Normal</button>
            </div>
        </div>
        
        <div id="loading-overlay">
            <div style="font-size: 2rem; color: #4fc3f7; margin-bottom: 20px;">üè≠</div>
            <div style="font-size: 1.5rem; color: #4fc3f7; margin-bottom: 10px;">BUILDING STEAM ENGINE</div>
            <div style="font-size: 1rem; color: #888; margin-bottom: 30px;">Initializing 300+ mechanical components...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loading-bar"></div>
            </div>
            <div class="loading-text" id="loading-text">Creating base components...</div>
            <div class="loading-detail" id="loading-detail"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/stats.min.js"></script>
    <script>
        // ULTIMATE STEAM ENGINE MODEL - COMPLETE MECHANICAL SYSTEM
        
        // Global variables
        let scene, camera, renderer, controls, stats;
        let steamEngine = new THREE.Group();
        let clock = new THREE.Clock();
        
        // Engine state
        let engineState = {
            running: false,
            speed: 0,
            direction: 1,
            boilerPressure: 100,
            steamTemperature: 212,
            throttlePosition: 50,
            cutoffPoint: 60,
            governorSpeed: 5,
            lubricationRate: 30,
            valveTiming: 0,
            fastenerTension: 75
        };
        
        // Component database
        let componentsDB = new Map();
        let selectedComponent = null;
        let visualizationMode = 'normal';
        
        // Material library with enhanced properties
        const materials = {
            // Metals
            castIron: new THREE.MeshStandardMaterial({ 
                color: 0x3a3a3a, 
                metalness: 0.3, 
                roughness: 0.8,
                name: 'Cast Iron'
            }),
            
            forgedSteel: new THREE.MeshStandardMaterial({ 
                color: 0x555555, 
                metalness: 0.8, 
                roughness: 0.4,
                name: 'Forged Steel'
            }),
            
            mildSteel: new THREE.MeshStandardMaterial({ 
                color: 0x666666, 
                metalness: 0.6, 
                roughness: 0.5,
                name: 'Mild Steel'
            }),
            
            toolSteel: new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                metalness: 0.9, 
                roughness: 0.2,
                name: 'Tool Steel'
            }),
            
            stainlessSteel: new THREE.MeshStandardMaterial({ 
                color: 0xaaaaaa, 
                metalness: 0.7, 
                roughness: 0.3,
                name: 'Stainless Steel'
            }),
            
            brass: new THREE.MeshStandardMaterial({ 
                color: 0xbb9955, 
                metalness: 0.9, 
                roughness: 0.1,
                name: 'Brass'
            }),
            
            bronze: new THREE.MeshStandardMaterial({ 
                color: 0xcd7f32, 
                metalness: 0.8, 
                roughness: 0.4,
                name: 'Bronze'
            }),
            
            copper: new THREE.MeshStandardMaterial({ 
                color: 0xb87333, 
                metalness: 0.9, 
                roughness: 0.1,
                name: 'Copper'
            }),
            
            aluminum: new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, 
                metalness: 0.9, 
                roughness: 0.2,
                name: 'Aluminum'
            }),
            
            // Special materials
            babbitt: new THREE.MeshStandardMaterial({ 
                color: 0xc0c0c0, 
                metalness: 0.5, 
                roughness: 0.6,
                name: 'Babbitt Metal'
            }),
            
            whiteMetal: new THREE.MeshStandardMaterial({ 
                color: 0xeeeeee, 
                metalness: 0.3, 
                roughness: 0.7,
                name: 'White Metal'
            }),
            
            // Non-metals
            rubber: new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                metalness: 0, 
                roughness: 1,
                name: 'Rubber'
            }),
            
            leather: new THREE.MeshStandardMaterial({ 
                color: 0x8B4513, 
                metalness: 0, 
                roughness: 0.9,
                name: 'Leather'
            }),
            
            asbestos: new THREE.MeshStandardMaterial({ 
                color: 0x7f7f7f, 
                metalness: 0, 
                roughness: 0.8,
                name: 'Asbestos'
            }),
            
            cork: new THREE.MeshStandardMaterial({ 
                color: 0x8B7355, 
                metalness: 0, 
                roughness: 1,
                name: 'Cork'
            }),
            
            gasketMaterial: new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, 
                metalness: 0, 
                roughness: 0.9,
                name: 'Gasket Material'
            }),
            
            // Special finishes
            polished: new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                metalness: 1, 
                roughness: 0.1,
                name: 'Polished Steel'
            }),
            
            blued: new THREE.MeshStandardMaterial({ 
                color: 0x2a3a5a, 
                metalness: 0.8, 
                roughness: 0.3,
                name: 'Blued Steel'
            }),
            
            // Transparent materials
            glass: new THREE.MeshPhysicalMaterial({ 
                color: 0x88ccff, 
                metalness: 0, 
                roughness: 0,
                transmission: 0.9, 
                transparent: true,
                thickness: 0.5,
                name: 'Glass'
            }),
            
            oil: new THREE.MeshPhysicalMaterial({ 
                color: 0xaaaa00, 
                metalness: 0.3, 
                roughness: 0.1,
                transparent: true,
                opacity: 0.7,
                name: 'Oil'
            })
        };
        
        // Component groups
        let componentGroups = {
            foundation: new THREE.Group(),
            frame: new THREE.Group(),
            cylinder: new THREE.Group(),
            piston: new THREE.Group(),
            valveGear: new THREE.Group(),
            crankshaft: new THREE.Group(),
            flywheel: new THREE.Group(),
            governor: new THREE.Group(),
            boiler: new THREE.Group(),
            piping: new THREE.Group(),
            instrumentation: new THREE.Group(),
            safety: new THREE.Group(),
            lubrication: new THREE.Group(),
            fasteners: new THREE.Group(),
            seals: new THREE.Group(),
            bearings: new THREE.Group(),
            linkages: new THREE.Group(),
            supports: new THREE.Group(),
            auxiliary: new THREE.Group()
        };
        
        // Initialize the application
        async function init() {
            showLoadingProgress(0, "Initializing 3D Engine...");
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(60, 40, 60);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 300;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            
            // Setup lighting
            setupAdvancedLighting();
            
            // Build the ultimate steam engine
            await buildUltimateSteamEngine();
            
            // Setup UI
            setupUI();
            
            // Initialize component tree
            buildComponentTree();
            
            // Setup stats
            setupStats();
            
            // Start animation
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-overlay').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading-overlay').style.display = 'none';
                }, 500);
            }, 500);
        }
        
        // Show loading progress
        function showLoadingProgress(percent, message, detail = "") {
            document.getElementById('loading-bar').style.width = percent + '%';
            document.getElementById('loading-text').textContent = message;
            document.getElementById('loading-detail').textContent = detail;
        }
        
        // Setup advanced lighting
        function setupAdvancedLighting() {
            // Main key light
            const keyLight = new THREE.DirectionalLight(0xffffff, 1);
            keyLight.position.set(100, 150, 100);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 4096;
            keyLight.shadow.mapSize.height = 4096;
            keyLight.shadow.camera.left = -150;
            keyLight.shadow.camera.right = 150;
            keyLight.shadow.camera.top = 150;
            keyLight.shadow.camera.bottom = -150;
            keyLight.shadow.bias = -0.0001;
            scene.add(keyLight);
            
            // Fill light
            const fillLight = new THREE.DirectionalLight(0x88aaff, 0.3);
            fillLight.position.set(-100, 50, -100);
            scene.add(fillLight);
            
            // Back light
            const backLight = new THREE.DirectionalLight(0x4488ff, 0.2);
            backLight.position.set(0, 50, -150);
            scene.add(backLight);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404060, 0.3);
            scene.add(ambientLight);
            
            // Rim lights
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const rimLight = new THREE.DirectionalLight(0x4488ff, 0.1);
                rimLight.position.set(
                    Math.cos(angle) * 150,
                    50,
                    Math.sin(angle) * 150
                );
                scene.add(rimLight);
            }
            
            // Engine glow (hot parts)
            const engineGlow = new THREE.PointLight(0xff6600, 0.5, 100);
            engineGlow.position.set(0, 20, 0);
            scene.add(engineGlow);
            
            // Steam glow
            const steamGlow = new THREE.PointLight(0x88aaff, 0.3, 50);
            steamGlow.position.set(20, 15, -10);
            scene.add(steamGlow);
        }
        
        // Setup performance stats
        function setupStats() {
            stats = new Stats();
            stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
            stats.dom.style.position = 'absolute';
            stats.dom.style.left = '10px';
            stats.dom.style.top = '10px';
            document.getElementById('container').appendChild(stats.dom);
        }
        
        // Build the ultimate steam engine
        async function buildUltimateSteamEngine() {
            showLoadingProgress(10, "Creating foundation and frame...");
            await buildFoundationAndFrame();
            
            showLoadingProgress(20, "Building cylinder assembly...");
            await buildCylinderAssembly();
            
            showLoadingProgress(30, "Creating piston system...");
            await buildPistonSystem();
            
            showLoadingProgress(40, "Constructing crankshaft...");
            await buildCrankshaftSystem();
            
            showLoadingProgress(50, "Installing valve gear...");
            await buildValveGearSystem();
            
            showLoadingProgress(60, "Building boiler system...");
            await buildBoilerSystem();
            
            showLoadingProgress(70, "Adding governor system...");
            await buildGovernorSystem();
            
            showLoadingProgress(80, "Installing piping...");
            await buildPipingSystem();
            
            showLoadingProgress(90, "Adding instrumentation...");
            await buildInstrumentation();
            
            showLoadingProgress(95, "Installing fasteners...");
            await buildAllFasteners();
            
            showLoadingProgress(100, "Final assembly...");
            await finalAssembly();
        }
        
        // Build foundation and frame
        async function buildFoundationAndFrame() {
            const foundationGroup = componentGroups.foundation;
            foundationGroup.name = "Foundation";
            
            // Main foundation slab
            const slab = createComponent(
                "Foundation Slab",
                new THREE.BoxGeometry(80, 10, 40),
                materials.castIron,
                {x: 0, y: -5, z: 0}
            );
            foundationGroup.add(slab);
            
            // Mounting rails
            const railGeometry = new THREE.BoxGeometry(60, 6, 8);
            for (let z of [-12, 12]) {
                const rail = createComponent(
                    "Mounting Rail",
                    railGeometry,
                    materials.forgedSteel,
                    {x: 0, y: 2, z: z}
                );
                foundationGroup.add(rail);
            }
            
            // Foundation bolts with proper representation
            for (let x of [-30, -15, 15, 30]) {
                for (let z of [-15, 15]) {
                    const bolt = createFoundationBolt(x, 0, z);
                    foundationGroup.add(bolt);
                }
            }
            
            // Grout between foundation and engine bed
            const grout = createComponent(
                "Grout Bed",
                new THREE.BoxGeometry(62, 2, 24),
                materials.concrete || materials.castIron,
                {x: 0, y: 4, z: 0}
            );
            grout.material.color.setHex(0x5a5a5a);
            foundationGroup.add(grout);
            
            scene.add(foundationGroup);
            
            // Frame structure
            const frameGroup = componentGroups.frame;
            frameGroup.name = "Frame";
            
            // Main columns
            const columnGeometry = new THREE.BoxGeometry(4, 40, 4);
            for (let x of [-25, 25]) {
                for (let z of [-8, 8]) {
                    const column = createComponent(
                        "Frame Column",
                        columnGeometry,
                        materials.castIron,
                        {x: x, y: 20, z: z}
                    );
                    frameGroup.add(column);
                }
            }
            
            // Cross braces
            const braceGeometry = new THREE.BoxGeometry(50, 4, 4);
            for (let y of [10, 30]) {
                const brace = createComponent(
                    "Cross Brace",
                    braceGeometry,
                    materials.forgedSteel,
                    {x: 0, y: y, z: 0}
                );
                frameGroup.add(brace);
            }
            
            // Diagonal braces
            for (let i = 0; i < 4; i++) {
                const points = [
                    new THREE.Vector3(-25, 5, -8),
                    new THREE.Vector3(0, 15, 0),
                    new THREE.Vector3(25, 5, 8)
                ];
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 20, 2, 8, false);
                const diagonal = createComponent(
                    "Diagonal Brace",
                    tubeGeometry,
                    materials.forgedSteel,
                    {x: 0, y: 0, z: 0}
                );
                frameGroup.add(diagonal);
            }
            
            scene.add(frameGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create foundation bolt with details
        function createFoundationBolt(x, y, z) {
            const boltGroup = new THREE.Group();
            boltGroup.name = "Foundation Bolt";
            
            // Bolt thread section
            const thread = createComponent(
                "Bolt Thread",
                new THREE.CylinderGeometry(1, 1, 30, 32),
                materials.mildSteel,
                {x: 0, y: 15, z: 0}
            );
            
            // Add thread detail (simplified)
            for (let i = 0; i < 30; i++) {
                const threadRing = createComponent(
                    "Thread Ring",
                    new THREE.TorusGeometry(1.1, 0.05, 8, 32),
                    materials.mildSteel,
                    {x: 0, y: i - 14.5, z: 0}
                );
                threadRing.rotation.x = Math.PI / 2;
                boltGroup.add(threadRing);
            }
            
            // Bolt head
            const head = createComponent(
                "Bolt Head",
                new THREE.CylinderGeometry(2, 2, 3, 6),
                materials.forgedSteel,
                {x: 0, y: 31.5, z: 0}
            );
            boltGroup.add(head);
            
            // Nut
            const nut = createComponent(
                "Nut",
                new THREE.CylinderGeometry(2, 2, 3, 6),
                materials.forgedSteel,
                {x: 0, y: -14.5, z: 0}
            );
            boltGroup.add(nut);
            
            // Washers
            const topWasher = createComponent(
                "Washer",
                new THREE.CylinderGeometry(2.5, 2.5, 0.5, 32),
                materials.mildSteel,
                {x: 0, y: 30, z: 0}
            );
            boltGroup.add(topWasher);
            
            const bottomWasher = createComponent(
                "Washer",
                new THREE.CylinderGeometry(2.5, 2.5, 0.5, 32),
                materials.mildSteel,
                {x: 0, y: -13, z: 0}
            );
            boltGroup.add(bottomWasher);
            
            boltGroup.position.set(x, y, z);
            return boltGroup;
        }
        
        // Build cylinder assembly
        async function buildCylinderAssembly() {
            const cylinderGroup = componentGroups.cylinder;
            cylinderGroup.name = "Cylinder Assembly";
            
            // Main cylinder block
            const cylinderBlock = createComponent(
                "Cylinder Block",
                new THREE.CylinderGeometry(10, 10, 35, 64),
                materials.castIron,
                {x: 30, y: 25, z: 0}
            );
            cylinderBlock.rotation.z = Math.PI / 2;
            cylinderGroup.add(cylinderBlock);
            
            // Cylinder liner (removable sleeve)
            const liner = createComponent(
                "Cylinder Liner",
                new THREE.CylinderGeometry(8, 8, 33, 64),
                materials.toolSteel,
                {x: 30, y: 25, z: 0}
            );
            liner.rotation.z = Math.PI / 2;
            cylinderGroup.add(liner);
            
            // Steam jacket
            const jacket = createComponent(
                "Steam Jacket",
                new THREE.CylinderGeometry(12, 12, 33, 64),
                materials.castIron,
                {x: 30, y: 25, z: 0}
            );
            jacket.rotation.z = Math.PI / 2;
            cylinderGroup.add(jacket);
            
            // Cylinder head (front)
            const frontHead = createCylinderHead(30 + 17.5, 25, 0, "Front");
            cylinderGroup.add(frontHead);
            
            // Cylinder head (rear)
            const rearHead = createCylinderHead(30 - 17.5, 25, 0, "Rear");
            cylinderGroup.add(rearHead);
            
            // Steam chest
            const steamChest = createComponent(
                "Steam Chest",
                new THREE.BoxGeometry(12, 15, 12),
                materials.castIron,
                {x: 30, y: 25, z: 10}
            );
            cylinderGroup.add(steamChest);
            
            // D-slide valve
            const slideValve = createSlideValve();
            slideValve.position.set(30, 25, 14);
            cylinderGroup.add(slideValve);
            
            // Valve seat with ports
            const valveSeat = createValveSeat();
            valveSeat.position.set(30, 20, 12);
            cylinderGroup.add(valveSeat);
            
            // Stuffing box assembly
            const stuffingBox = createStuffingBox();
            stuffingBox.position.set(15, 25, 0);
            cylinderGroup.add(stuffingBox);
            
            // Drain valves
            for (let i = 0; i < 3; i++) {
                const drainValve = createDrainValve();
                drainValve.position.set(30, 15 + i * 5, -8);
                cylinderGroup.add(drainValve);
            }
            
            scene.add(cylinderGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create cylinder head with cooling fins
        function createCylinderHead(x, y, z, type) {
            const headGroup = new THREE.Group();
            headGroup.name = `${type} Cylinder Head`;
            
            // Head body
            const head = createComponent(
                "Head Body",
                new THREE.CylinderGeometry(11, 11, 4, 64),
                materials.castIron,
                {x: 0, y: 0, z: 0}
            );
            head.rotation.z = Math.PI / 2;
            headGroup.add(head);
            
            // Cooling fins
            for (let i = 0; i < 6; i++) {
                const fin = createComponent(
                    "Cooling Fin",
                    new THREE.CylinderGeometry(12, 12, 0.3, 64),
                    materials.castIron,
                    {x: i * 0.5 - 1.5, y: 0, z: 0}
                );
                fin.rotation.z = Math.PI / 2;
                headGroup.add(fin);
            }
            
            // Head studs
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI) / 6;
                const stud = createComponent(
                    "Head Stud",
                    new THREE.CylinderGeometry(0.5, 0.5, 8, 16),
                    materials.forgedSteel,
                    {
                        x: Math.cos(angle) * 9,
                        y: Math.sin(angle) * 9,
                        z: 0
                    }
                );
                headGroup.add(stud);
                
                // Nut
                const nut = createComponent(
                    "Stud Nut",
                    new THREE.CylinderGeometry(0.8, 0.8, 0.6, 6),
                    materials.forgedSteel,
                    {
                        x: Math.cos(angle) * 9,
                        y: Math.sin(angle) * 9,
                        z: 2
                    }
                );
                headGroup.add(nut);
            }
            
            headGroup.position.set(x, y, z);
            return headGroup;
        }
        
        // Create slide valve with extreme detail
        function createSlideValve() {
            const valveGroup = new THREE.Group();
            valveGroup.name = "D-Slide Valve";
            
            // Valve body
            const body = createComponent(
                "Valve Body",
                new THREE.BoxGeometry(10, 3, 8),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            valveGroup.add(body);
            
            // Valve faces with lap
            const faceGeometry = new THREE.BoxGeometry(10, 0.2, 8);
            for (let y of [-1.4, 1.4]) {
                const face = createComponent(
                    "Valve Face",
                    faceGeometry,
                    materials.bronze,
                    {x: 0, y: y, z: 0}
                );
                face.material.metalness = 0.9;
                face.material.roughness = 0.1;
                valveGroup.add(face);
            }
            
            // Valve rod connection
            const rodConnector = createComponent(
                "Rod Connector",
                new THREE.CylinderGeometry(1, 1, 3, 16),
                materials.bronze,
                {x: 0, y: 0, z: 4.5}
            );
            valveGroup.add(rodConnector);
            
            // Valve rod
            const rod = createComponent(
                "Valve Rod",
                new THREE.CylinderGeometry(0.8, 0.8, 20, 16),
                materials.mildSteel,
                {x: 0, y: 0, z: 15}
            );
            valveGroup.add(rod);
            
            // Valve nut
            const valveNut = createComponent(
                "Valve Nut",
                new THREE.CylinderGeometry(1.2, 1.2, 0.8, 6),
                materials.forgedSteel,
                {x: 0, y: 0, z: 5.5}
            );
            valveGroup.add(valveNut);
            
            // Valve packing
            const packing = createComponent(
                "Valve Packing",
                new THREE.CylinderGeometry(1.5, 1.5, 2, 16),
                materials.rubber,
                {x: 0, y: 0, z: 9}
            );
            valveGroup.add(packing);
            
            return valveGroup;
        }
        
        // Create valve seat with steam ports
        function createValveSeat() {
            const seatGroup = new THREE.Group();
            seatGroup.name = "Valve Seat";
            
            // Seat body
            const body = createComponent(
                "Seat Body",
                new THREE.BoxGeometry(12, 1, 12),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            seatGroup.add(body);
            
            // Steam ports (admission)
            const portGeometry = new THREE.BoxGeometry(2, 0.5, 3);
            for (let i = 0; i < 4; i++) {
                const port = createComponent(
                    "Steam Port",
                    portGeometry,
                    materials.bronze,
                    {x: i * 2.5 - 3.75, y: 0.3, z: 2}
                );
                seatGroup.add(port);
            }
            
            // Exhaust ports
            for (let i = 0; i < 4; i++) {
                const port = createComponent(
                    "Exhaust Port",
                    portGeometry,
                    materials.bronze,
                    {x: i * 2.5 - 3.75, y: 0.3, z: -2}
                );
                port.material.color.setHex(0x666666);
                seatGroup.add(port);
            }
            
            return seatGroup;
        }
        
        // Create stuffing box assembly
        function createStuffingBox() {
            const stuffingGroup = new THREE.Group();
            stuffingGroup.name = "Stuffing Box";
            
            // Box body
            const body = createComponent(
                "Box Body",
                new THREE.CylinderGeometry(4, 4, 6, 32),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            stuffingGroup.add(body);
            
            // Gland
            const gland = createComponent(
                "Gland",
                new THREE.CylinderGeometry(3.5, 3.5, 2, 32),
                materials.bronze,
                {x: 0, y: 0, z: 3}
            );
            stuffingGroup.add(gland);
            
            // Gland studs
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const stud = createComponent(
                    "Gland Stud",
                    new THREE.CylinderGeometry(0.3, 0.3, 4, 16),
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 3,
                        y: Math.sin(angle) * 3,
                        z: 0
                    }
                );
                stuffingGroup.add(stud);
                
                // Gland nut
                const nut = createComponent(
                    "Gland Nut",
                    new THREE.CylinderGeometry(0.6, 0.6, 0.6, 6),
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 3,
                        y: Math.sin(angle) * 3,
                        z: 2
                    }
                );
                stuffingGroup.add(nut);
            }
            
            // Packing rings
            for (let i = 0; i < 5; i++) {
                const ring = createComponent(
                    "Packing Ring",
                    new THREE.TorusGeometry(2, 0.3, 16, 32),
                    materials.rubber,
                    {x: 0, y: 0, z: i * 0.6 - 2}
                );
                ring.rotation.x = Math.PI / 2;
                stuffingGroup.add(ring);
            }
            
            return stuffingGroup;
        }
        
        // Create drain valve
        function createDrainValve() {
            const drainGroup = new THREE.Group();
            drainGroup.name = "Drain Valve";
            
            // Valve body
            const body = createComponent(
                "Valve Body",
                new THREE.CylinderGeometry(1.5, 1.5, 3, 16),
                materials.brass,
                {x: 0, y: 0, z: 0}
            );
            drainGroup.add(body);
            
            // Valve stem
            const stem = createComponent(
                "Valve Stem",
                new THREE.CylinderGeometry(0.4, 0.4, 2, 16),
                materials.brass,
                {x: 0, y: 0, z: 1.5}
            );
            drainGroup.add(stem);
            
            // Valve handle
            const handle = createComponent(
                "Valve Handle",
                new THREE.BoxGeometry(0.3, 4, 0.3),
                materials.mildSteel,
                {x: 0, y: 2, z: 1.5}
            );
            drainGroup.add(handle);
            
            // Handle knob
            const knob = createComponent(
                "Handle Knob",
                new THREE.SphereGeometry(0.5, 16, 16),
                materials.mildSteel,
                {x: 0, y: 4, z: 1.5}
            );
            drainGroup.add(knob);
            
            // Drain pipe
            const pipe = createComponent(
                "Drain Pipe",
                new THREE.CylinderGeometry(0.5, 0.5, 6, 16),
                materials.copper,
                {x: 0, y: -3, z: 0}
            );
            drainGroup.add(pipe);
            
            return drainGroup;
        }
        
        // Build piston system
        async function buildPistonSystem() {
            const pistonGroup = componentGroups.piston;
            pistonGroup.name = "Piston System";
            
            // Piston assembly
            const pistonAssembly = createPistonAssembly();
            pistonAssembly.position.set(20, 25, 0);
            pistonGroup.add(pistonAssembly);
            
            // Piston rod
            const pistonRod = createComponent(
                "Piston Rod",
                new THREE.CylinderGeometry(2, 2, 25, 32),
                materials.forgedSteel,
                {x: 10, y: 25, z: 0}
            );
            pistonGroup.add(pistonRod);
            
            // Crosshead assembly
            const crosshead = createCrossheadAssembly();
            crosshead.position.set(0, 25, 0);
            pistonGroup.add(crosshead);
            
            // Connecting rod
            const connectingRod = createConnectingRod();
            connectingRod.position.set(0, 15, 0);
            pistonGroup.add(connectingRod);
            
            scene.add(pistonGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create piston assembly with rings
        function createPistonAssembly() {
            const pistonGroup = new THREE.Group();
            pistonGroup.name = "Piston Assembly";
            
            // Piston body
            const body = createComponent(
                "Piston Body",
                new THREE.CylinderGeometry(7.9, 7.9, 8, 64),
                materials.forgedSteel,
                {x: 0, y: 0, z: 0}
            );
            body.rotation.z = Math.PI / 2;
            pistonGroup.add(body);
            
            // Piston rings (compression)
            for (let i = 0; i < 3; i++) {
                const ring = createPistonRing(7.95, i);
                ring.position.set(i * 2 - 2, 0, 0);
                pistonGroup.add(ring);
            }
            
            // Oil control ring
            const oilRing = createComponent(
                "Oil Control Ring",
                new THREE.TorusGeometry(7.95, 0.4, 16, 64),
                materials.castIron,
                {x: 4, y: 0, z: 0}
            );
            oilRing.rotation.z = Math.PI / 2;
            oilRing.material.color.setHex(0x555555);
            pistonGroup.add(oilRing);
            
            // Wrist pin bosses
            const bossGeometry = new THREE.CylinderGeometry(2, 2, 10, 32);
            for (let z of [-3, 3]) {
                const boss = createComponent(
                    "Wrist Pin Boss",
                    bossGeometry,
                    materials.forgedSteel,
                    {x: 0, y: 0, z: z}
                );
                boss.rotation.z = Math.PI / 2;
                pistonGroup.add(boss);
            }
            
            // Wrist pin
            const wristPin = createComponent(
                "Wrist Pin",
                new THREE.CylinderGeometry(1.5, 1.5, 8, 32),
                materials.toolSteel,
                {x: 0, y: 0, z: 0}
            );
            wristPin.rotation.z = Math.PI / 2;
            pistonGroup.add(wristPin);
            
            // Circlips for wrist pin retention
            for (let z of [-4.5, 4.5]) {
                const circlip = createComponent(
                    "Circlip",
                    new THREE.TorusGeometry(1.6, 0.1, 8, 32),
                    materials.stainlessSteel,
                    {x: 0, y: 0, z: z}
                );
                circlip.rotation.z = Math.PI / 2;
                pistonGroup.add(circlip);
            }
            
            return pistonGroup;
        }
        
        // Create piston ring with gap
        function createPistonRing(radius, index) {
            const ringGroup = new THREE.Group();
            ringGroup.name = `Piston Ring ${index + 1}`;
            
            // Main ring body
            const ring = createComponent(
                "Ring Body",
                new THREE.TorusGeometry(radius, 0.3, 16, 64),
                materials.castIron,
                {x: 0, y: 0, z: 0}
            );
            ring.rotation.z = Math.PI / 2;
            ringGroup.add(ring);
            
            // Ring gap
            const gap = createComponent(
                "Ring Gap",
                new THREE.BoxGeometry(0.5, 0.6, 0.3),
                materials.castIron,
                {x: 0, y: 0, z: radius}
            );
            ringGroup.add(gap);
            
            return ringGroup;
        }
        
        // Create crosshead assembly
        function createCrossheadAssembly() {
            const crossheadGroup = new THREE.Group();
            crossheadGroup.name = "Crosshead Assembly";
            
            // Crosshead body
            const body = createComponent(
                "Crosshead Body",
                new THREE.BoxGeometry(8, 10, 6),
                materials.forgedSteel,
                {x: 0, y: 0, z: 0}
            );
            crossheadGroup.add(body);
            
            // Crosshead pin
            const pin = createComponent(
                "Crosshead Pin",
                new THREE.CylinderGeometry(1.2, 1.2, 8, 32),
                materials.toolSteel,
                {x: 0, y: 0, z: 0}
            );
            pin.rotation.z = Math.PI / 2;
            crossheadGroup.add(pin);
            
            // Crosshead bush
            const bush = createComponent(
                "Crosshead Bush",
                new THREE.CylinderGeometry(1.3, 1.3, 8.2, 32, 1, true),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            bush.rotation.z = Math.PI / 2;
            crossheadGroup.add(bush);
            
            // Crosshead slippers (guides)
            for (let z of [-4, 4]) {
                const slipper = createComponent(
                    "Crosshead Slipper",
                    new THREE.BoxGeometry(10, 1, 4),
                    materials.bronze,
                    {x: 0, y: -4.5, z: z}
                );
                crossheadGroup.add(slipper);
                
                // Wear plates
                const wearPlate = createComponent(
                    "Wear Plate",
                    new THREE.BoxGeometry(9.8, 0.2, 3.8),
                    materials.toolSteel,
                    {x: 0, y: -4.4, z: z}
                );
                wearPlate.material.color.setHex(0x333333);
                crossheadGroup.add(wearPlate);
            }
            
            // Lubrication fittings
            for (let i = 0; i < 2; i++) {
                const fitting = createComponent(
                    "Lubrication Fitting",
                    new THREE.CylinderGeometry(0.3, 0.3, 1, 16),
                    materials.brass,
                    {x: i * 3 - 1.5, y: 2, z: 3}
                );
                crossheadGroup.add(fitting);
            }
            
            return crossheadGroup;
        }
        
        // Create connecting rod
        function createConnectingRod() {
            const rodGroup = new THREE.Group();
            rodGroup.name = "Connecting Rod";
            
            // Rod body (I-beam section)
            const rodGeometry = new THREE.BoxGeometry(3, 25, 2);
            const rod = createComponent(
                "Rod Body",
                rodGeometry,
                materials.forgedSteel,
                {x: 0, y: -12.5, z: 0}
            );
            rodGroup.add(rod);
            
            // Big end (crank end)
            const bigEnd = createBigEnd();
            bigEnd.position.set(0, 0, 0);
            rodGroup.add(bigEnd);
            
            // Little end (crosshead end)
            const littleEnd = createLittleEnd();
            littleEnd.position.set(0, -25, 0);
            rodGroup.add(littleEnd);
            
            // Stretch bolts for rod caps
            for (let i = 0; i < 2; i++) {
                const bolt = createComponent(
                    "Rod Bolt",
                    new THREE.CylinderGeometry(0.4, 0.4, 6, 16),
                    materials.forgedSteel,
                    {x: i * 1.5 - 0.75, y: 0, z: 1.5}
                );
                rodGroup.add(bolt);
                
                const nut = createComponent(
                    "Rod Nut",
                    new THREE.CylinderGeometry(0.7, 0.7, 0.8, 6),
                    materials.forgedSteel,
                    {x: i * 1.5 - 0.75, y: 3, z: 1.5}
                );
                rodGroup.add(nut);
            }
            
            return rodGroup;
        }
        
        // Create big end bearing
        function createBigEnd() {
            const bigEndGroup = new THREE.Group();
            bigEndGroup.name = "Big End Bearing";
            
            // Bearing cap (split)
            const cap = createComponent(
                "Bearing Cap",
                new THREE.BoxGeometry(6, 4, 3),
                materials.forgedSteel,
                {x: 0, y: 0, z: 1.5}
            );
            bigEndGroup.add(cap);
            
            // Lower bearing shell
            const lowerShell = createComponent(
                "Lower Bearing Shell",
                new THREE.CylinderGeometry(3, 3, 3, 32, 1, true, 0, Math.PI),
                materials.babbitt,
                {x: 0, y: -0.5, z: 0}
            );
            lowerShell.rotation.z = Math.PI / 2;
            bigEndGroup.add(lowerShell);
            
            // Upper bearing shell
            const upperShell = createComponent(
                "Upper Bearing Shell",
                new THREE.CylinderGeometry(3, 3, 3, 32, 1, true, 0, Math.PI),
                materials.babbitt,
                {x: 0, y: 0.5, z: 0}
            );
            upperShell.rotation.z = Math.PI / 2;
            upperShell.rotation.y = Math.PI;
            bigEndGroup.add(upperShell);
            
            // Oil grooves in bearing
            const grooveGeometry = new THREE.TorusGeometry(2.8, 0.1, 16, 32, Math.PI);
            for (let i = 0; i < 3; i++) {
                const groove = createComponent(
                    "Oil Groove",
                    grooveGeometry,
                    materials.babbitt,
                    {x: 0, y: i - 1, z: 0}
                );
                groove.rotation.z = Math.PI / 2;
                groove.material.color.setHex(0x999999);
                bigEndGroup.add(groove);
            }
            
            return bigEndGroup;
        }
        
        // Create little end bearing
        function createLittleEnd() {
            const littleEndGroup = new THREE.Group();
            littleEndGroup.name = "Little End Bearing";
            
            // Bush housing
            const housing = createComponent(
                "Bush Housing",
                new THREE.BoxGeometry(4, 4, 4),
                materials.forgedSteel,
                {x: 0, y: 0, z: 0}
            );
            littleEndGroup.add(housing);
            
            // Bronze bush
            const bush = createComponent(
                "Bronze Bush",
                new THREE.CylinderGeometry(1.2, 1.2, 4.2, 32),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            bush.rotation.z = Math.PI / 2;
            littleEndGroup.add(bush);
            
            // Oil hole
            const oilHole = createComponent(
                "Oil Hole",
                new THREE.CylinderGeometry(0.2, 0.2, 4.4, 16),
                materials.bronze,
                {x: 0, y: 1.5, z: 0}
            );
            oilHole.material.color.setHex(0x000000);
            littleEndGroup.add(oilHole);
            
            return littleEndGroup;
        }
        
        // Build crankshaft system
        async function buildCrankshaftSystem() {
            const crankshaftGroup = componentGroups.crankshaft;
            crankshaftGroup.name = "Crankshaft System";
            
            // Main crankshaft
            const crankshaft = createCrankshaft();
            crankshaft.position.set(0, 15, 0);
            crankshaftGroup.add(crankshaft);
            
            // Main bearings
            const mainBearings = createMainBearings();
            mainBearings.position.set(0, 15, 0);
            crankshaftGroup.add(mainBearings);
            
            // Thrust bearing
            const thrustBearing = createThrustBearing();
            thrustBearing.position.set(-30, 15, 0);
            crankshaftGroup.add(thrustBearing);
            
            scene.add(crankshaftGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create complete crankshaft
        function createCrankshaft() {
            const crankshaftGroup = new THREE.Group();
            crankshaftGroup.name = "Crankshaft";
            
            // Main journals
            const journalPositions = [-25, 0, 25];
            journalPositions.forEach(x => {
                const journal = createComponent(
                    "Main Journal",
                    new THREE.CylinderGeometry(3, 3, 12, 64),
                    materials.forgedSteel,
                    {x: x, y: 0, z: 0}
                );
                crankshaftGroup.add(journal);
            });
            
            // Crank webs
            const webGeometry = new THREE.BoxGeometry(10, 6, 12);
            for (let x of [-12.5, 12.5]) {
                const web = createComponent(
                    "Crank Web",
                    webGeometry,
                    materials.forgedSteel,
                    {x: x, y: 3, z: 0}
                );
                crankshaftGroup.add(web);
                
                // Lightening holes
                const hole = createComponent(
                    "Lightening Hole",
                    new THREE.CylinderGeometry(3, 3, 6.2, 32),
                    materials.forgedSteel,
                    {x: x, y: 3, z: 0}
                );
                hole.material.color.setHex(0x222222);
                crankshaftGroup.add(hole);
            }
            
            // Crank pin
            const crankPin = createComponent(
                "Crank Pin",
                new THREE.CylinderGeometry(2.5, 2.5, 10, 64),
                materials.forgedSteel,
                {x: 0, y: 9, z: 0}
            );
            crankshaftGroup.add(crankPin);
            
            // Oil passages
            createCrankshaftOilPassages(crankshaftGroup);
            
            // Balance weights
            const balanceWeight = createComponent(
                "Balance Weight",
                new THREE.BoxGeometry(8, 10, 4),
                materials.forgedSteel,
                {x: 0, y: -3, z: 6}
            );
            crankshaftGroup.add(balanceWeight);
            
            // Keyways
            for (let x of [-30, 30]) {
                const keyway = createComponent(
                    "Keyway",
                    new THREE.BoxGeometry(1, 0.5, 12),
                    materials.forgedSteel,
                    {x: x, y: 0, z: 3.1}
                );
                keyway.material.color.setHex(0x222222);
                crankshaftGroup.add(keyway);
            }
            
            return crankshaftGroup;
        }
        
        // Create oil passages in crankshaft
        function createCrankshaftOilPassages(group) {
            // Main oil gallery
            const gallery = createComponent(
                "Oil Gallery",
                new THREE.CylinderGeometry(0.4, 0.4, 50, 16),
                materials.forgedSteel,
                {x: 0, y: 0, z: 0}
            );
            gallery.rotation.z = Math.PI / 2;
            gallery.material.color.setHex(0x111111);
            group.add(gallery);
            
            // Radial holes to journals
            const journalPositions = [-25, 0, 25];
            journalPositions.forEach(x => {
                const radialHole = createComponent(
                    "Radial Oil Hole",
                    new THREE.CylinderGeometry(0.2, 0.2, 3, 16),
                    materials.forgedSteel,
                    {x: x, y: 0, z: 1.5}
                );
                radialHole.material.color.setHex(0x111111);
                group.add(radialHole);
            });
            
            // Oil hole to crank pin
            const crankPinHole = createComponent(
                "Crank Pin Oil Hole",
                new THREE.CylinderGeometry(0.2, 0.2, 12, 16),
                materials.forgedSteel,
                {x: 0, y: 4.5, z: 0}
            );
            crankPinHole.material.color.setHex(0x111111);
            group.add(crankPinHole);
        }
        
        // Create main bearings
        function createMainBearings() {
            const bearingsGroup = new THREE.Group();
            bearingsGroup.name = "Main Bearings";
            
            const positions = [-25, 0, 25];
            positions.forEach((x, index) => {
                // Bearing housing
                const housing = createComponent(
                    `Main Bearing Housing ${index + 1}`,
                    new THREE.BoxGeometry(14, 8, 14),
                    materials.castIron,
                    {x: x, y: 0, z: 0}
                );
                bearingsGroup.add(housing);
                
                // Bearing cap
                const cap = createComponent(
                    `Bearing Cap ${index + 1}`,
                    new THREE.BoxGeometry(12, 4, 8),
                    materials.forgedSteel,
                    {x: x, y: 4, z: 0}
                );
                bearingsGroup.add(cap);
                
                // Bearing shells
                const lowerShell = createComponent(
                    `Lower Bearing Shell ${index + 1}`,
                    new THREE.CylinderGeometry(3.1, 3.1, 12.2, 32, 1, true, 0, Math.PI),
                    materials.babbitt,
                    {x: x, y: -0.5, z: 0}
                );
                lowerShell.rotation.z = Math.PI / 2;
                bearingsGroup.add(lowerShell);
                
                const upperShell = createComponent(
                    `Upper Bearing Shell ${index + 1}`,
                    new THREE.CylinderGeometry(3.1, 3.1, 12.2, 32, 1, true, 0, Math.PI),
                    materials.babbitt,
                    {x: x, y: 0.5, z: 0}
                );
                upperShell.rotation.z = Math.PI / 2;
                upperShell.rotation.y = Math.PI;
                bearingsGroup.add(upperShell);
                
                // Bearing bolts
                for (let i = 0; i < 2; i++) {
                    const bolt = createComponent(
                        `Bearing Bolt ${index + 1}-${i + 1}`,
                        new THREE.CylinderGeometry(0.5, 0.5, 10, 16),
                        materials.forgedSteel,
                        {x: x + i * 4 - 2, y: 6, z: 3}
                    );
                    bearingsGroup.add(bolt);
                    
                    const nut = createComponent(
                        `Bearing Nut ${index + 1}-${i + 1}`,
                        new THREE.CylinderGeometry(0.8, 0.8, 0.8, 6),
                        materials.forgedSteel,
                        {x: x + i * 4 - 2, y: 10, z: 3}
                    );
                    bearingsGroup.add(nut);
                }
            });
            
            return bearingsGroup;
        }
        
        // Create thrust bearing
        function createThrustBearing() {
            const thrustGroup = new THREE.Group();
            thrustGroup.name = "Thrust Bearing";
            
            // Housing
            const housing = createComponent(
                "Thrust Bearing Housing",
                new THREE.BoxGeometry(12, 8, 12),
                materials.castIron,
                {x: 0, y: 0, z: 0}
            );
            thrustGroup.add(housing);
            
            // Thrust washers
            const washerGeometry = new THREE.CylinderGeometry(4, 4, 0.5, 32);
            for (let i = 0; i < 3; i++) {
                const washer = createComponent(
                    `Thrust Washer ${i + 1}`,
                    washerGeometry,
                    materials.bronze,
                    {x: 0, y: i * 0.6 - 0.6, z: 0}
                );
                thrustGroup.add(washer);
            }
            
            // Thrust collar on shaft
            const collar = createComponent(
                "Thrust Collar",
                new THREE.CylinderGeometry(3.5, 3.5, 2, 32),
                materials.forgedSteel,
                {x: 0, y: 0, z: 0}
            );
            thrustGroup.add(collar);
            
            // Thrust adjustment screws
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const screw = createComponent(
                    `Thrust Adjustment Screw ${i + 1}`,
                    new THREE.CylinderGeometry(0.3, 0.3, 4, 16),
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 5,
                        y: Math.sin(angle) * 5,
                        z: 3
                    }
                );
                thrustGroup.add(screw);
                
                const lockNut = createComponent(
                    `Lock Nut ${i + 1}`,
                    new THREE.CylinderGeometry(0.6, 0.6, 0.6, 6),
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 5,
                        y: Math.sin(angle) * 5,
                        z: 4.5
                    }
                );
                thrustGroup.add(lockNut);
            }
            
            return thrustGroup;
        }
        
        // Build valve gear system
        async function buildValveGearSystem() {
            const valveGearGroup = componentGroups.valveGear;
            valveGearGroup.name = "Valve Gear System";
            
            // Stephenson valve gear
            const stephensonGear = createStephensonValveGear();
            stephensonGear.position.set(0, 15, 15);
            valveGearGroup.add(stephensonGear);
            
            // Expansion link
            const expansionLink = createExpansionLink();
            expansionLink.position.set(15, 25, 15);
            valveGearGroup.add(expansionLink);
            
            // Reversing mechanism
            const reversingMechanism = createReversingMechanism();
            reversingMechanism.position.set(30, 30, 20);
            valveGearGroup.add(reversingMechanism);
            
            // Eccentric assembly
            const eccentricAssembly = createEccentricAssembly();
            eccentricAssembly.position.set(-10, 15, 15);
            valveGearGroup.add(eccentricAssembly);
            
            scene.add(valveGearGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create Stephenson valve gear
        function createStephensonValveGear() {
            const gearGroup = new THREE.Group();
            gearGroup.name = "Stephenson Valve Gear";
            
            // Eccentric sheaves
            for (let i = 0; i < 2; i++) {
                const eccentric = createComponent(
                    `Eccentric Sheave ${i + 1}`,
                    new THREE.TorusGeometry(4, 1.5, 32, 64),
                    materials.castIron,
                    {x: i * 8 - 4, y: 0, z: 0}
                );
                gearGroup.add(eccentric);
                
                // Eccentric straps
                const strap = createComponent(
                    `Eccentric Strap ${i + 1}`,
                    new THREE.TorusGeometry(4.2, 1.7, 32, 64),
                    materials.bronze,
                    {x: i * 8 - 4, y: 0, z: 0}
                );
                gearGroup.add(strap);
            }
            
            // Eccentric rods
            const rodGeometry = new THREE.BoxGeometry(1.5, 20, 1.5);
            for (let i = 0; i < 2; i++) {
                const rod = createComponent(
                    `Eccentric Rod ${i + 1}`,
                    rodGeometry,
                    materials.forgedSteel,
                    {x: i * 8 - 4, y: 10, z: 0}
                );
                gearGroup.add(rod);
            }
            
            // Lifting links
            const linkGeometry = new THREE.BoxGeometry(1, 15, 1);
            for (let i = 0; i < 2; i++) {
                const link = createComponent(
                    `Lifting Link ${i + 1}`,
                    linkGeometry,
                    materials.forgedSteel,
                    {x: i * 4 - 2, y: 25, z: 0}
                );
                gearGroup.add(link);
            }
            
            // Radius rod
            const radiusRod = createComponent(
                "Radius Rod",
                new THREE.BoxGeometry(30, 1.5, 1.5),
                materials.forgedSteel,
                {x: 0, y: 30, z: 0}
            );
            gearGroup.add(radiusRod);
            
            return gearGroup;
        }
        
        // Create expansion link
        function createExpansionLink() {
            const linkGroup = new THREE.Group();
            linkGroup.name = "Expansion Link";
            
            // Link body
            const body = createComponent(
                "Link Body",
                new THREE.BoxGeometry(3, 25, 1),
                materials.forgedSteel,
                {x: 0, y: 0, z: 0}
            );
            linkGroup.add(body);
            
            // Slots for die block
            const slotGeometry = new THREE.BoxGeometry(1.2, 20, 1.2);
            for (let i = 0; i < 2; i++) {
                const slot = createComponent(
                    `Link Slot ${i + 1}`,
                    slotGeometry,
                    materials.forgedSteel,
                    {x: 0, y: i * 10 - 5, z: 0}
                );
                slot.material.color.setHex(0x222222);
                linkGroup.add(slot);
            }
            
            // Die block
            const dieBlock = createComponent(
                "Die Block",
                new THREE.BoxGeometry(1, 3, 1),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            linkGroup.add(dieBlock);
            
            // Pivot pins
            const pinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 4, 16);
            for (let i = 0; i < 3; i++) {
                const pin = createComponent(
                    `Pivot Pin ${i + 1}`,
                    pinGeometry,
                    materials.toolSteel,
                    {x: 0, y: i * 10 - 10, z: 0}
                );
                pin.rotation.z = Math.PI / 2;
                linkGroup.add(pin);
            }
            
            return linkGroup;
        }
        
        // Create reversing mechanism
        function createReversingMechanism() {
            const reverseGroup = new THREE.Group();
            reverseGroup.name = "Reversing Mechanism";
            
            // Reversing lever
            const lever = createComponent(
                "Reversing Lever",
                new THREE.BoxGeometry(1, 40, 1),
                materials.forgedSteel,
                {x: 0, y: 0, z: 0}
            );
            reverseGroup.add(lever);
            
            // Quadrant plate
            const quadrant = createComponent(
                "Quadrant Plate",
                new THREE.CylinderGeometry(15, 15, 1, 64, 1, true, 0, Math.PI),
                materials.castIron,
                {x: 0, y: -20, z: 0}
            );
            reverseGroup.add(quadrant);
            
            // Notches in quadrant
            for (let i = 0; i < 5; i++) {
                const notch = createComponent(
                    `Quadrant Notch ${i + 1}`,
                    new THREE.BoxGeometry(0.5, 0.5, 1.2),
                    materials.castIron,
                    {x: Math.cos(i * Math.PI / 4 - Math.PI / 2) * 14, 
                     y: Math.sin(i * Math.PI / 4 - Math.PI / 2) * 14 - 20, 
                     z: 0}
                );
                reverseGroup.add(notch);
            }
            
            // Detent mechanism
            const detent = createComponent(
                "Detent",
                new THREE.BoxGeometry(2, 4, 1),
                materials.forgedSteel,
                {x: 0, y: -35, z: 0}
            );
            reverseGroup.add(detent);
            
            // Detent spring
            const spring = createSpring(1, 8, 0.2, 32);
            spring.position.set(0, -39, 0);
            reverseGroup.add(spring);
            
            // Lever handle
            const handle = createComponent(
                "Lever Handle",
                new THREE.CylinderGeometry(0.8, 0.8, 10, 16),
                materials.wood || materials.forgedSteel,
                {x: 0, y: 20, z: 0}
            );
            handle.rotation.z = Math.PI / 2;
            handle.material.color.setHex(0x8B4513);
            reverseGroup.add(handle);
            
            return reverseGroup;
        }
        
        // Create eccentric assembly
        function createEccentricAssembly() {
            const eccentricGroup = new THREE.Group();
            eccentricGroup.name = "Eccentric Assembly";
            
            // Eccentric sheave
            const sheave = createComponent(
                "Eccentric Sheave",
                new THREE.TorusGeometry(5, 2, 32, 64),
                materials.castIron,
                {x: 0, y: 0, z: 0}
            );
            eccentricGroup.add(sheave);
            
            // Eccentric strap
            const strap = createComponent(
                "Eccentric Strap",
                new THREE.TorusGeometry(5.2, 2.2, 32, 64),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            eccentricGroup.add(strap);
            
            // Strap bolts
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const bolt = createComponent(
                    `Strap Bolt ${i + 1}`,
                    new THREE.CylinderGeometry(0.4, 0.4, 3, 16),
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 5,
                        y: Math.sin(angle) * 5,
                        z: 0
                    }
                );
                eccentricGroup.add(bolt);
                
                const nut = createComponent(
                    `Strap Nut ${i + 1}`,
                    new THREE.CylinderGeometry(0.7, 0.7, 0.6, 6),
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 5,
                        y: Math.sin(angle) * 5,
                        z: 1.5
                    }
                );
                eccentricGroup.add(nut);
            }
            
            // Eccentric rod connection
            const rodConnection = createComponent(
                "Rod Connection",
                new THREE.BoxGeometry(2, 2, 4),
                materials.forgedSteel,
                {x: 0, y: 6, z: 0}
            );
            eccentricGroup.add(rodConnection);
            
            return eccentricGroup;
        }
        
        // Build boiler system
        async function buildBoilerSystem() {
            const boilerGroup = componentGroups.boiler;
            boilerGroup.name = "Boiler System";
            
            // Fire-tube boiler
            const boiler = createFireTubeBoiler();
            boiler.position.set(-40, 20, 0);
            boilerGroup.add(boiler);
            
            // Firebox
            const firebox = createFirebox();
            firebox.position.set(-60, 15, 0);
            boilerGroup.add(firebox);
            
            // Smokebox
            const smokebox = createSmokebox();
            smokebox.position.set(-20, 20, 0);
            boilerGroup.add(smokebox);
            
            // Boiler stays and braces
            createBoilerStays(boilerGroup);
            
            scene.add(boilerGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create fire-tube boiler
        function createFireTubeBoiler() {
            const boilerGroup = new THREE.Group();
            boilerGroup.name = "Fire-Tube Boiler";
            
            // Boiler shell
            const shell = createComponent(
                "Boiler Shell",
                new THREE.CylinderGeometry(12, 12, 40, 64),
                materials.mildSteel,
                {x: 0, y: 0, z: 0}
            );
            boilerGroup.add(shell);
            
            // Fire tubes (simplified - showing a few representative tubes)
            const tubeGeometry = new THREE.CylinderGeometry(0.2, 0.2, 38, 16);
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 10;
                const tube = createComponent(
                    `Fire Tube ${i + 1}`,
                    tubeGeometry,
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * radius,
                        y: 0,
                        z: Math.sin(angle) * radius
                    }
                );
                tube.rotation.z = Math.PI / 2;
                boilerGroup.add(tube);
            }
            
            // Boiler wrappers
            const wrapper = createComponent(
                "Boiler Wrapper",
                new THREE.CylinderGeometry(12.5, 12.5, 41, 64),
                materials.mildSteel,
                {x: 0, y: 0, z: 0}
            );
            wrapper.material.color.setHex(0x444444);
            boilerGroup.add(wrapper);
            
            // Boiler bands
            const bandGeometry = new THREE.CylinderGeometry(12.7, 12.7, 1, 64);
            for (let i = 0; i < 5; i++) {
                const band = createComponent(
                    `Boiler Band ${i + 1}`,
                    bandGeometry,
                    materials.forgedSteel,
                    {x: 0, y: i * 8 - 16, z: 0}
                );
                band.material.color.setHex(0x333333);
                boilerGroup.add(band);
            }
            
            return boilerGroup;
        }
        
        // Create firebox
        function createFirebox() {
            const fireboxGroup = new THREE.Group();
            fireboxGroup.name = "Firebox";
            
            // Firebox shell
            const shell = createComponent(
                "Firebox Shell",
                new THREE.BoxGeometry(15, 20, 15),
                materials.mildSteel,
                {x: 0, y: 0, z: 0}
            );
            fireboxGroup.add(shell);
            
            // Firebrick lining
            const lining = createComponent(
                "Firebrick Lining",
                new THREE.BoxGeometry(13, 18, 13),
                materials.firebrick || materials.castIron,
                {x: 0, y: 0, z: 0}
            );
            lining.material.color.setHex(0x8B4513);
            fireboxGroup.add(lining);
            
            // Fire door
            const door = createComponent(
                "Fire Door",
                new THREE.CylinderGeometry(6, 6, 1, 32),
                materials.castIron,
                {x: 0, y: 0, z: 8}
            );
            fireboxGroup.add(door);
            
            // Door hinges
            for (let i = 0; i < 2; i++) {
                const hinge = createComponent(
                    `Door Hinge ${i + 1}`,
                    new THREE.CylinderGeometry(0.5, 0.5, 3, 16),
                    materials.forgedSteel,
                    {x: i * 4 - 2, y: 0, z: 7.5}
                );
                hinge.rotation.y = Math.PI / 2;
                fireboxGroup.add(hinge);
            }
            
            // Door handle
            const handle = createComponent(
                "Door Handle",
                new THREE.BoxGeometry(8, 1, 0.5),
                materials.forgedSteel,
                {x: 0, y: 5, z: 8.5}
            );
            fireboxGroup.add(handle);
            
            // Ash pan
            const ashPan = createComponent(
                "Ash Pan",
                new THREE.BoxGeometry(14, 3, 14),
                materials.mildSteel,
                {x: 0, y: -11.5, z: 0}
            );
            ashPan.material.color.setHex(0x222222);
            fireboxGroup.add(ashPan);
            
            return fireboxGroup;
        }
        
        // Create smokebox
        function createSmokebox() {
            const smokeboxGroup = new THREE.Group();
            smokeboxGroup.name = "Smokebox";
            
            // Smokebox shell
            const shell = createComponent(
                "Smokebox Shell",
                new THREE.CylinderGeometry(8, 8, 10, 64),
                materials.mildSteel,
                {x: 0, y: 0, z: 0}
            );
            smokeboxGroup.add(shell);
            
            // Smokebox door
            const door = createComponent(
                "Smokebox Door",
                new THREE.CylinderGeometry(7, 7, 1, 64),
                materials.castIron,
                {x: 0, y: 0, z: 5.5}
            );
            smokeboxGroup.add(door);
            
            // Door hinges
            for (let i = 0; i < 2; i++) {
                const hinge = createComponent(
                    `Smokebox Hinge ${i + 1}`,
                    new THREE.CylinderGeometry(0.5, 0.5, 3, 16),
                    materials.forgedSteel,
                    {x: i * 3 - 1.5, y: 0, z: 5}
                );
                hinge.rotation.y = Math.PI / 2;
                smokeboxGroup.add(hinge);
            }
            
            // Door latch
            const latch = createComponent(
                "Door Latch",
                new THREE.BoxGeometry(2, 1, 1),
                materials.forgedSteel,
                {x: 0, y: 5, z: 6}
            );
            smokeboxGroup.add(latch);
            
            // Blast pipe
            const blastPipe = createComponent(
                "Blast Pipe",
                new THREE.CylinderGeometry(2, 2, 8, 32),
                materials.mildSteel,
                {x: 0, y: 0, z: -5}
            );
            blastPipe.rotation.x = Math.PI / 2;
            smokeboxGroup.add(blastPipe);
            
            // Chimney (simplified)
            const chimney = createComponent(
                "Chimney",
                new THREE.CylinderGeometry(3, 4, 15, 32),
                materials.mildSteel,
                {x: 0, y: 7.5, z: 0}
            );
            smokeboxGroup.add(chimney);
            
            return smokeboxGroup;
        }
        
        // Create boiler stays and braces
        function createBoilerStays(group) {
            // Longitudinal stays
            const stayGeometry = new THREE.CylinderGeometry(0.3, 0.3, 35, 16);
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                const stay = createComponent(
                    `Longitudinal Stay ${i + 1}`,
                    stayGeometry,
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 11,
                        y: 0,
                        z: Math.sin(angle) * 11
                    }
                );
                stay.rotation.z = Math.PI / 2;
                group.add(stay);
                
                // Stay nuts
                for (let end of [-17.5, 17.5]) {
                    const nut = createComponent(
                        `Stay Nut ${i + 1}`,
                        new THREE.CylinderGeometry(0.6, 0.6, 0.6, 6),
                        materials.mildSteel,
                        {
                            x: Math.cos(angle) * 11,
                            y: end,
                            z: Math.sin(angle) * 11
                        }
                    );
                    group.add(nut);
                }
            }
            
            // Gusset stays
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const points = [
                    new THREE.Vector3(Math.cos(angle) * 12, -15, Math.sin(angle) * 12),
                    new THREE.Vector3(Math.cos(angle) * 6, 0, Math.sin(angle) * 6),
                    new THREE.Vector3(Math.cos(angle) * 12, 15, Math.sin(angle) * 12)
                ];
                const curve = new THREE.CatmullRomCurve3(points);
                const stay = new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 20, 0.5, 8, false),
                    materials.mildSteel
                );
                stay.name = `Gusset Stay ${i + 1}`;
                group.add(stay);
            }
        }
        
        // Build governor system
        async function buildGovernorSystem() {
            const governorGroup = componentGroups.governor;
            governorGroup.name = "Governor System";
            
            // Centrifugal governor
            const centrifugalGovernor = createCentrifugalGovernor();
            centrifugalGovernor.position.set(40, 30, 0);
            governorGroup.add(centrifugalGovernor);
            
            // Governor drive
            const governorDrive = createGovernorDrive();
            governorDrive.position.set(40, 15, 0);
            governorGroup.add(governorDrive);
            
            // Throttle linkage
            const throttleLinkage = createThrottleLinkage();
            throttleLinkage.position.set(20, 25, 20);
            governorGroup.add(throttleLinkage);
            
            scene.add(governorGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create centrifugal governor
        function createCentrifugalGovernor() {
            const governorGroup = new THREE.Group();
            governorGroup.name = "Centrifugal Governor";
            
            // Governor shaft
            const shaft = createComponent(
                "Governor Shaft",
                new THREE.CylinderGeometry(0.8, 0.8, 30, 32),
                materials.mildSteel,
                {x: 0, y: 0, z: 0}
            );
            governorGroup.add(shaft);
            
            // Governor balls (4)
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const ball = createComponent(
                    `Governor Ball ${i + 1}`,
                    new THREE.SphereGeometry(3, 32, 32),
                    materials.brass,
                    {
                        x: Math.cos(angle) * 10,
                        y: Math.sin(angle) * 10,
                        z: 0
                    }
                );
                governorGroup.add(ball);
                
                // Ball arm
                const arm = createComponent(
                    `Governor Arm ${i + 1}`,
                    new THREE.BoxGeometry(0.3, 10, 0.3),
                    materials.forgedSteel,
                    {
                        x: Math.cos(angle) * 5,
                        y: Math.sin(angle) * 5,
                        z: 0
                    }
                );
                arm.rotation.z = angle;
                governorGroup.add(arm);
            }
            
            // Governor sleeve
            const sleeve = createComponent(
                "Governor Sleeve",
                new THREE.CylinderGeometry(2, 2, 4, 32),
                materials.bronze,
                {x: 0, y: 0, z: 0}
            );
            governorGroup.add(sleeve);
            
            // Sleeve arms
            const armGeometry = new THREE.BoxGeometry(0.3, 8, 0.3);
            for (let i = 0; i < 2; i++) {
                const arm = createComponent(
                    `Sleeve Arm ${i + 1}`,
                    armGeometry,
                    materials.forgedSteel,
                    {x: i * 1.5 - 0.75, y: 4, z: 0}
                );
                governorGroup.add(arm);
            }
            
            // Governor spring
            const spring = createSpring(1.5, 10, 0.2, 32);
            spring.position.set(0, -5, 0);
            governorGroup.add(spring);
            
            // Spring adjustment
            const adjuster = createComponent(
                "Spring Adjuster",
                new THREE.CylinderGeometry(1, 1, 3, 16),
                materials.mildSteel,
                {x: 0, y: -10, z: 0}
            );
            governorGroup.add(adjuster);
            
            // Adjustment lock nut
            const adjusterNut = createComponent(
                "Adjuster Lock Nut",
                new THREE.CylinderGeometry(1.5, 1.5, 0.8, 6),
                materials.mildSteel,
                {x: 0, y: -11.5, z: 0}
            );
            governorGroup.add(adjusterNut);
            
            return governorGroup;
        }
        
        // Create governor drive
        function createGovernorDrive() {
            const driveGroup = new THREE.Group();
            driveGroup.name = "Governor Drive";
            
            // Bevel gears
            const bevelGear1 = createComponent(
                "Bevel Gear (Vertical)",
                new THREE.CylinderGeometry(4, 4, 2, 32),
                materials.castIron,
                {x: 0, y: 0, z: 0}
            );
            driveGroup.add(bevelGear1);
            
            const bevelGear2 = createComponent(
                "Bevel Gear (Horizontal)",
                new THREE.CylinderGeometry(4, 4, 2, 32),
                materials.castIron,
                {x: 10, y: 0, z: 0}
            );
            bevelGear2.rotation.z = Math.PI / 2;
            driveGroup.add(bevelGear2);
            
            // Drive shaft
            const driveShaft = createComponent(
                "Drive Shaft",
                new THREE.CylinderGeometry(0.8, 0.8, 20, 32),
                materials.mildSteel,
                {x: 5, y: 0, z: 0}
            );
            driveShaft.rotation.z = Math.PI / 2;
            driveGroup.add(driveShaft);
            
            // Flexible coupling
            const coupling = createComponent(
                "Flexible Coupling",
                new THREE.CylinderGeometry(2, 2, 3, 32),
                materials.rubber,
                {x: 15, y: 0, z: 0}
            );
            coupling.rotation.z = Math.PI / 2;
            driveGroup.add(coupling);
            
            return driveGroup;
        }
        
        // Create throttle linkage
        function createThrottleLinkage() {
            const linkageGroup = new THREE.Group();
            linkageGroup.name = "Throttle Linkage";
            
            // Linkage rods
            const rodGeometry = new THREE.BoxGeometry(0.5, 20, 0.5);
            for (let i = 0; i < 3; i++) {
                const rod = createComponent(
                    `Linkage Rod ${i + 1}`,
                    rodGeometry,
                    materials.mildSteel,
                    {x: i * 2 - 2, y: 10, z: 0}
                );
                linkageGroup.add(rod);
            }
            
            // Bell cranks
            const crankGeometry = new THREE.BoxGeometry(1, 1, 4);
            for (let i = 0; i < 2; i++) {
                const crank = createComponent(
                    `Bell Crank ${i + 1}`,
                    crankGeometry,
                    materials.forgedSteel,
                    {x: i * 2 - 1, y: 5, z: 0}
                );
                crank.rotation.z = Math.PI / 4;
                linkageGroup.add(crank);
            }
            
            // Pivot pins
            const pinGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4, 16);
            for (let i = 0; i < 4; i++) {
                const pin = createComponent(
                    `Pivot Pin ${i + 1}`,
                    pinGeometry,
                    materials.toolSteel,
                    {x: i - 1.5, y: 5, z: 0}
                );
                pin.rotation.z = Math.PI / 2;
                linkageGroup.add(pin);
            }
            
            // Throttle valve
            const throttleValve = createComponent(
                "Throttle Valve",
                new THREE.CylinderGeometry(3, 3, 4, 32),
                materials.brass,
                {x: 4, y: 20, z: 0}
            );
            linkageGroup.add(throttleValve);
            
            // Butterfly valve inside
            const butterfly = createComponent(
                "Butterfly Valve",
                new THREE.BoxGeometry(0.2, 3.8, 3.8),
                materials.brass,
                {x: 4, y: 20, z: 0}
            );
            butterfly.rotation.z = Math.PI / 4;
            linkageGroup.add(butterfly);
            
            return linkageGroup;
        }
        
        // Build piping system
        async function buildPipingSystem() {
            const pipingGroup = componentGroups.piping;
            pipingGroup.name = "Piping System";
            
            // Main steam pipe
            const mainSteamPipe = createMainSteamPipe();
            mainSteamPipe.position.set(-20, 25, 0);
            pipingGroup.add(mainSteamPipe);
            
            // Branch pipes
            createBranchPipes(pipingGroup);
            
            // Flexible connections
            createFlexibleConnections(pipingGroup);
            
            // Pipe supports
            createPipeSupports(pipingGroup);
            
            scene.add(pipingGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create main steam pipe
        function createMainSteamPipe() {
            const pipeGroup = new THREE.Group();
            pipeGroup.name = "Main Steam Pipe";
            
            // Pipe sections with flanges
            const sections = [
                {length: 15, x: -7.5},
                {length: 20, x: 10},
                {length: 15, x: 27.5}
            ];
            
            sections.forEach((section, index) => {
                // Pipe section
                const pipe = createComponent(
                    `Pipe Section ${index + 1}`,
                    new THREE.CylinderGeometry(3, 3, section.length, 32),
                    materials.copper,
                    {x: section.x, y: 0, z: 0}
                );
                pipe.rotation.z = Math.PI / 2;
                pipeGroup.add(pipe);
                
                // Flanges
                if (index < sections.length - 1) {
                    const flangeX = section.x + section.length / 2;
                    const flange = createComponent(
                        `Flange ${index + 1}`,
                        new THREE.CylinderGeometry(4, 4, 1, 32),
                        materials.mildSteel,
                        {x: flangeX, y: 0, z: 0}
                    );
                    pipeGroup.add(flange);
                    
                    // Flange bolts
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI) / 4;
                        const bolt = createComponent(
                            `Flange Bolt ${index + 1}-${i + 1}`,
                            new THREE.CylinderGeometry(0.3, 0.3, 2, 16),
                            materials.mildSteel,
                            {
                                x: flangeX + Math.cos(angle) * 3.5,
                                y: Math.sin(angle) * 3.5,
                                z: 0
                            }
                        );
                        pipeGroup.add(bolt);
                    }
                }
            });
            
            // Pipe insulation
            const insulation = createComponent(
                "Pipe Insulation",
                new THREE.CylinderGeometry(3.5, 3.5, 50, 32),
                materials.asbestos,
                {x: 10, y: 0, z: 0}
            );
            insulation.rotation.z = Math.PI / 2;
            insulation.material.color.setHex(0x7f7f7f);
            pipeGroup.add(insulation);
            
            return pipeGroup;
        }
        
        // Create branch pipes
        function createBranchPipes(group) {
            // Tee connections
            const teeGeometry = new THREE.CylinderGeometry(3, 3, 6, 32);
            const tee = createComponent(
                "Tee Connection",
                teeGeometry,
                materials.copper,
                {x: 10, y: 0, z: 0}
            );
            tee.rotation.x = Math.PI / 2;
            group.add(tee);
            
            // Branch to cylinder
            const branch = createComponent(
                "Cylinder Branch",
                new THREE.CylinderGeometry(2, 2, 20, 32),
                materials.copper,
                {x: 10, y: 10, z: 0}
            );
            group.add(branch);
            
            // Elbows
            const elbow = createComponent(
                "90¬∞ Elbow",
                new THREE.TorusGeometry(3, 3, 16, 32, Math.PI / 2),
                materials.copper,
                {x: 30, y: 10, z: 0}
            );
            elbow.rotation.x = Math.PI / 2;
            group.add(elbow);
        }
        
        // Create flexible connections
        function createFlexibleConnections(group) {
            // Flexible hose
            const hose = createComponent(
                "Flexible Hose",
                new THREE.CylinderGeometry(1.5, 1.5, 10, 32),
                materials.rubber,
                {x: -10, y: 15, z: 10}
            );
            hose.rotation.z = Math.PI / 2;
            group.add(hose);
            
            // Hose clamps
            const clampGeometry = new THREE.TorusGeometry(1.6, 0.2, 16, 32);
            for (let i = 0; i < 2; i++) {
                const clamp = createComponent(
                    `Hose Clamp ${i + 1}`,
                    clampGeometry,
                    materials.stainlessSteel,
                    {x: -10 + i * 5 - 2.5, y: 15, z: 10}
                );
                clamp.rotation.z = Math.PI / 2;
                group.add(clamp);
            }
            
            // Swivel joints
            const swivel = createComponent(
                "Swivel Joint",
                new THREE.CylinderGeometry(2, 2, 3, 32),
                materials.bronze,
                {x: -15, y: 15, z: 10}
            );
            swivel.rotation.z = Math.PI / 2;
            group.add(swivel);
        }
        
        // Create pipe supports
        function createPipeSupports(group) {
            // Pipe hangers
            for (let x of [-25, 0, 25]) {
                const hanger = createComponent(
                    `Pipe Hanger`,
                    new THREE.BoxGeometry(1, 10, 1),
                    materials.mildSteel,
                    {x: x, y: 5, z: 0}
                );
                group.add(hanger);
                
                // U-bolt
                const uBolt = createComponent(
                    `U-Bolt`,
                    new THREE.TorusGeometry(2, 0.3, 16, 32, Math.PI),
                    materials.mildSteel,
                    {x: x, y: 10, z: 0}
                );
                uBolt.rotation.x = Math.PI / 2;
                group.add(uBolt);
            }
            
            // Spring hangers for expansion
            for (let x of [-15, 15]) {
                const spring = createSpring(1, 5, 0.2, 32);
                spring.position.set(x, 12, 0);
                group.add(spring);
                
                const hanger = createComponent(
                    `Spring Hanger`,
                    new THREE.BoxGeometry(1, 2, 1),
                    materials.mildSteel,
                    {x: x, y: 15, z: 0}
                );
                group.add(hanger);
            }
        }
        
        // Build instrumentation
        async function buildInstrumentation() {
            const instrumentsGroup = componentGroups.instrumentation;
            instrumentsGroup.name = "Instrumentation";
            
            // Pressure gauge
            const pressureGauge = createPressureGauge();
            pressureGauge.position.set(20, 35, 20);
            instrumentsGroup.add(pressureGauge);
            
            // Water gauge
            const waterGauge = createWaterGauge();
            waterGauge.position.set(0, 35, 20);
            instrumentsGroup.add(waterGauge);
            
            // Steam thermometer
            const thermometer = createThermometer();
            thermometer.position.set(-20, 35, 20);
            instrumentsGroup.add(thermometer);
            
            // Tachometer
            const tachometer = createTachometer();
            tachometer.position.set(40, 35, 20);
            instrumentsGroup.add(tachometer);
            
            scene.add(instrumentsGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create pressure gauge
        function createPressureGauge() {
            const gaugeGroup = new THREE.Group();
            gaugeGroup.name = "Pressure Gauge";
            
            // Case
            const caseMesh = createComponent(
                "Gauge Case",
                new THREE.CylinderGeometry(4, 4, 3, 32),
                materials.brass,
                {x: 0, y: 0, z: 0}
            );
            gaugeGroup.add(caseMesh);
            
            // Glass lens
            const lens = createComponent(
                "Gauge Lens",
                new THREE.CylinderGeometry(3.9, 3.9, 0.2, 32),
                materials.glass,
                {x: 0, y: 1.5, z: 0}
            );
            gaugeGroup.add(lens);
            
            // Dial face
            const dial = createComponent(
                "Gauge Dial",
                new THREE.CylinderGeometry(3.8, 3.8, 0.1, 32),
                materials.mildSteel,
                {x: 0, y: 1.4, z: 0}
            );
            dial.material.color.setHex(0xffffff);
            gaugeGroup.add(dial);
            
            // Pointer
            const pointer = createComponent(
                "Gauge Pointer",
                new THREE.BoxGeometry(3, 0.1, 0.05),
                materials.mildSteel,
                {x: 1.5, y: 1.45, z: 0}
            );
            pointer.material.color.setHex(0xff0000);
            gaugeGroup.add(pointer);
            
            // Bourdon tube (simplified)
            const bourdonTube = createComponent(
                "Bourdon Tube",
                new THREE.TorusGeometry(1, 0.2, 16, 32, Math.PI * 1.5),
                materials.bronze,
                {x: -2, y: 0, z: 0}
            );
            bourdonTube.rotation.y = Math.PI / 2;
            gaugeGroup.add(bourdonTube);
            
            // Connection
            const connection = createComponent(
                "Gauge Connection",
                new THREE.CylinderGeometry(0.5, 0.5, 2, 16),
                materials.brass,
                {x: -3, y: 0, z: 0}
            );
            connection.rotation.z = Math.PI / 2;
            gaugeGroup.add(connection);
            
            return gaugeGroup;
        }
        
        // Create water gauge
        function createWaterGauge() {
            const gaugeGroup = new THREE.Group();
            gaugeGroup.name = "Water Gauge";
            
            // Glass tubes
            const tubeGeometry = new THREE.CylinderGeometry(0.3, 0.3, 12, 16);
            for (let x of [-0.5, 0.5]) {
                const tube = createComponent(
                    `Glass Tube ${x < 0 ? 'Front' : 'Back'}`,
                    tubeGeometry,
                    materials.glass,
                    {x: x, y: 0, z: 0}
                );
                gaugeGroup.add(tube);
            }
            
            // End fittings
            const fittingGeometry = new THREE.CylinderGeometry(1, 1, 1, 16);
            for (let y of [-6, 6]) {
                const fitting = createComponent(
                    `Gauge Fitting ${y < 0 ? 'Lower' : 'Upper'}`,
                    fittingGeometry,
                    materials.brass,
                    {x: 0, y: y, z: 0}
                );
                gaugeGroup.add(fitting);
                
                // Valve handles
                const handle = createComponent(
                    `Valve Handle ${y < 0 ? 'Lower' : 'Upper'}`,
                    new THREE.BoxGeometry(0.3, 3, 0.3),
                    materials.brass,
                    {x: 1.5, y: y, z: 0}
                );
                gaugeGroup.add(handle);
            }
            
            // Water level indicator
            const water = createComponent(
                "Water Level",
                new THREE.BoxGeometry(1, 8, 0.1),
                materials.water || materials.glass,
                {x: 0, y: -2, z: 0}
            );
            water.material.color.setHex(0x0000ff);
            water.material.transparent = true;
            water.material.opacity = 0.7;
            gaugeGroup.add(water);
            
            return gaugeGroup;
        }
        
        // Create thermometer
        function createThermometer() {
            const thermometerGroup = new THREE.Group();
            thermometerGroup.name = "Thermometer";
            
            // Bulb
            const bulb = createComponent(
                "Thermometer Bulb",
                new THREE.SphereGeometry(1, 32, 32),
                materials.glass,
                {x: 0, y: -3, z: 0}
            );
            thermometerGroup.add(bulb);
            
            // Capillary tube
            const tube = createComponent(
                "Capillary Tube",
                new THREE.CylinderGeometry(0.1, 0.1, 6, 16),
                materials.glass,
                {x: 0, y: 0, z: 0}
            );
            thermometerGroup.add(tube);
            
            // Mercury column
            const mercury = createComponent(
                "Mercury Column",
                new THREE.CylinderGeometry(0.08, 0.08, 4, 16),
                materials.mercury || materials.mildSteel,
                {x: 0, y: -2, z: 0}
            );
            mercury.material.color.setHex(0x8888ff);
            thermometerGroup.add(mercury);
            
            // Scale
            const scale = createComponent(
                "Temperature Scale",
                new THREE.BoxGeometry(0.5, 6, 0.05),
                materials.mildSteel,
                {x: 0.3, y: 0, z: 0}
            );
            scale.material.color.setHex(0xffffff);
            thermometerGroup.add(scale);
            
            return thermometerGroup;
        }
        
        // Create tachometer
        function createTachometer() {
            const tachGroup = new THREE.Group();
            tachGroup.name = "Tachometer";
            
            // Case
            const caseMesh = createComponent(
                "Tachometer Case",
                new THREE.CylinderGeometry(3, 3, 2, 32),
                materials.brass,
                {x: 0, y: 0, z: 0}
            );
            tachGroup.add(caseMesh);
            
            // Dial
            const dial = createComponent(
                "Tachometer Dial",
                new THREE.CylinderGeometry(2.9, 2.9, 0.1, 32),
                materials.mildSteel,
                {x: 0, y: 1, z: 0}
            );
            dial.material.color.setHex(0x000000);
            tachGroup.add(dial);
            
            // Numbers
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI) / 6;
                const number = createComponent(
                    `Dial Number ${i * 100}`,
                    new THREE.BoxGeometry(0.2, 0.5, 0.05),
                    materials.mildSteel,
                    {
                        x: Math.cos(angle) * 2,
                        y: 1.05,
                        z: Math.sin(angle) * 2
                    }
                );
                number.rotation.y = -angle;
                number.material.color.setHex(0xffffff);
                tachGroup.add(number);
            }
            
            // Pointer
            const pointer = createComponent(
                "Tachometer Pointer",
                new THREE.BoxGeometry(2, 0.1, 0.05),
                materials.mildSteel,
                {x: 1, y: 1.05, z: 0}
            );
            pointer.material.color.setHex(0xff4444);
            tachGroup.add(pointer);
            
            // Drive cable
            const cable = createComponent(
                "Drive Cable",
                new THREE.CylinderGeometry(0.2, 0.2, 10, 16),
                materials.rubber,
                {x: 0, y: -5, z: 0}
            );
            cable.rotation.x = Math.PI / 2;
            tachGroup.add(cable);
            
            return tachGroup;
        }
        
        // Build all fasteners
        async function buildAllFasteners() {
            const fastenersGroup = componentGroups.fasteners;
            fastenersGroup.name = "Fasteners";
            
            // Add various fasteners throughout the engine
            createStudsAndBolts(fastenersGroup);
            createNutsAndWashers(fastenersGroup);
            createSpecialFasteners(fastenersGroup);
            
            scene.add(fastenersGroup);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create studs and bolts
        function createStudsAndBolts(group) {
            // Various sizes of studs
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 60 - 30;
                const y = Math.random() * 30 + 10;
                const z = Math.random() * 20 - 10;
                
                const stud = createComponent(
                    `Stud ${i + 1}`,
                    new THREE.CylinderGeometry(0.4, 0.4, 6, 16),
                    materials.mildSteel,
                    {x: x, y: y, z: z}
                );
                group.add(stud);
            }
            
            // Hex bolts
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 70 - 35;
                const y = Math.random() * 35 + 5;
                const z = Math.random() * 25 - 12.5;
                
                const bolt = createComponent(
                    `Hex Bolt ${i + 1}`,
                    new THREE.CylinderGeometry(0.5, 0.5, 4, 16),
                    materials.forgedSteel,
                    {x: x, y: y, z: z}
                );
                group.add(bolt);
                
                const head = createComponent(
                    `Bolt Head ${i + 1}`,
                    new THREE.CylinderGeometry(0.9, 0.9, 0.8, 6),
                    materials.forgedSteel,
                    {x: x, y: y + 2, z: z}
                );
                group.add(head);
            }
        }
        
        // Create nuts and washers
        function createNutsAndWashers(group) {
            // Hex nuts
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 80 - 40;
                const y = Math.random() * 40;
                const z = Math.random() * 30 - 15;
                
                const nut = createComponent(
                    `Hex Nut ${i + 1}`,
                    new THREE.CylinderGeometry(0.8, 0.8, 0.6, 6),
                    materials.forgedSteel,
                    {x: x, y: y, z: z}
                );
                group.add(nut);
            }
            
            // Washers
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * 80 - 40;
                const y = Math.random() * 40;
                const z = Math.random() * 30 - 15;
                
                const washer = createComponent(
                    `Washer ${i + 1}`,
                    new THREE.CylinderGeometry(1, 1, 0.2, 32),
                    materials.mildSteel,
                    {x: x, y: y, z: z}
                );
                group.add(washer);
            }
            
            // Lock washers
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 60 - 30;
                const y = Math.random() * 30 + 10;
                const z = Math.random() * 20 - 10;
                
                const lockWasher = createComponent(
                    `Lock Washer ${i + 1}`,
                    new THREE.TorusGeometry(0.6, 0.1, 16, 32, Math.PI * 1.8),
                    materials.springSteel || materials.mildSteel,
                    {x: x, y: y, z: z}
                );
                lockWasher.rotation.x = Math.PI / 2;
                group.add(lockWasher);
            }
        }
        
        // Create special fasteners
        function createSpecialFasteners(group) {
            // Cotter pins
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 40 - 20;
                const y = Math.random() * 20 + 15;
                const z = Math.random() * 15 - 7.5;
                
                const cotterPin = createComponent(
                    `Cotter Pin ${i + 1}`,
                    new THREE.BoxGeometry(0.1, 2, 0.1),
                    materials.mildSteel,
                    {x: x, y: y, z: z}
                );
                group.add(cotterPin);
            }
            
            // Split pins
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 35 - 17.5;
                const y = Math.random() * 15 + 20;
                const z = Math.random() * 10 - 5;
                
                const splitPin = createComponent(
                    `Split Pin ${i + 1}`,
                    new THREE.CylinderGeometry(0.2, 0.2, 3, 16),
                    materials.mildSteel,
                    {x: x, y: y, z: z}
                );
                group.add(splitPin);
            }
            
            // Castle nuts
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 30 - 15;
                const y = Math.random() * 10 + 25;
                const z = Math.random() * 8 - 4;
                
                const castleNut = createComponent(
                    `Castle Nut ${i + 1}`,
                    new THREE.CylinderGeometry(1, 1, 0.8, 6),
                    materials.forgedSteel,
                    {x: x, y: y, z: z}
                );
                // Add slots to castle nut
                for (let j = 0; j < 6; j++) {
                    const slot = createComponent(
                        `Castle Nut Slot ${i + 1}-${j + 1}`,
                        new THREE.BoxGeometry(0.2, 0.8, 0.5),
                        materials.forgedSteel,
                        {x: x, y: y, z: z}
                    );
                    slot.rotation.y = (j * Math.PI) / 3;
                    group.add(slot);
                }
                group.add(castleNut);
            }
        }
        
        // Final assembly
        async function finalAssembly() {
            // Add all component groups to main engine
            steamEngine.name = "Ultimate Steam Engine";
            
            for (let groupName in componentGroups) {
                steamEngine.add(componentGroups[groupName]);
            }
            
            // Position everything correctly
            steamEngine.position.set(0, 10, 0);
            
            scene.add(steamEngine);
            
            // Update component count
            updateComponentCount();
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Create a component with metadata
        function createComponent(name, geometry, material, position) {
            const mesh = new THREE.Mesh(geometry, material.clone());
            mesh.name = name;
            mesh.position.set(position.x, position.y, position.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add metadata
            mesh.userData = {
                type: name.split(' ')[0],
                material: material.name || 'Unknown',
                temperature: 20,
                stress: 0,
                wear: 0,
                clearance: 0.1
            };
            
            // Store in database
            componentsDB.set(mesh.uuid, mesh);
            
            return mesh;
        }
        
        // Create spring geometry
        function createSpring(radius, height, wireRadius, segments) {
            const points = [];
            const coils = 8;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments * coils * Math.PI * 2;
                const x = Math.cos(t) * radius;
                const y = (i / segments) * height - height / 2;
                const z = Math.sin(t) * radius;
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const path = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(path, segments, wireRadius, 8, false);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                metalness: 0.8,
                name: 'Spring Steel'
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            return mesh;
        }
        
        // Update component count
        function updateComponentCount() {
            let totalComponents = 0;
            steamEngine.traverse(() => totalComponents++);
            document.getElementById('component-count').textContent = `${totalComponents} Components`;
        }
        
        // Build component tree for UI
        function buildComponentTree() {
            const treeContainer = document.getElementById('component-tree');
            treeContainer.innerHTML = '';
            
            function addNode(parent, object) {
                if (!object.visible || object.name === '') return;
                
                const node = document.createElement('div');
                node.className = 'tree-node';
                node.textContent = object.name || 'Unnamed';
                node.dataset.uuid = object.uuid;
                
                // Add material indicator
                if (object.material && object.material.name) {
                    const indicator = document.createElement('span');
                    indicator.className = 'material-indicator';
                    indicator.style.backgroundColor = getMaterialColor(object.material.name);
                    indicator.title = object.material.name;
                    node.prepend(indicator);
                }
                
                node.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectComponent(object);
                });
                
                parent.appendChild(node);
                
                // Add children
                if (object.children && object.children.length > 0) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'tree-children';
                    node.appendChild(childrenContainer);
                    
                    object.children.forEach(child => {
                        addNode(childrenContainer, child);
                    });
                }
            }
            
            // Add main groups
            for (let groupName in componentGroups) {
                addNode(treeContainer, componentGroups[groupName]);
            }
        }
        
        // Get material color for indicator
        function getMaterialColor(materialName) {
            const colorMap = {
                'Cast Iron': '#3a3a3a',
                'Forged Steel': '#555555',
                'Mild Steel': '#666666',
                'Tool Steel': '#444444',
                'Stainless Steel': '#aaaaaa',
                'Brass': '#bb9955',
                'Bronze': '#cd7f32',
                'Copper': '#b87333',
                'Aluminum': '#cccccc',
                'Babbitt Metal': '#c0c0c0',
                'Rubber': '#333333',
                'Glass': '#88ccff',
                'Spring Steel': '#888888'
            };
            
            return colorMap[materialName] || '#ffffff';
        }
        
        // Select component
        function selectComponent(component) {
            // Remove previous selection
            if (selectedComponent) {
                selectedComponent.material.emissive?.setHex(0x000000);
            }
            
            // Set new selection
            selectedComponent = component;
            
            // Highlight component
            if (component.isMesh) {
                component.material.emissive = component.material.emissive || new THREE.Color();
                component.material.emissive.setHex(0xffaa00);
                component.material.emissiveIntensity = 0.5;
            }
            
            // Update inspector
            updateComponentInspector(component);
            
            // Update tree selection
            document.querySelectorAll('.tree-node').forEach(node => {
                node.classList.remove('selected');
                if (node.dataset.uuid === component.uuid) {
                    node.classList.add('selected');
                }
            });
        }
        
        // Update component inspector
        function updateComponentInspector(component) {
            document.getElementById('info-name').textContent = component.name;
            
            if (component.userData) {
                document.getElementById('info-material').textContent = component.userData.material;
                document.getElementById('info-temperature').textContent = `${component.userData.temperature}¬∞C`;
                document.getElementById('info-stress').textContent = `${component.userData.stress} MPa`;
                document.getElementById('info-wear').textContent = `${component.userData.wear}%`;
                document.getElementById('info-clearance').textContent = `${component.userData.clearance} mm`;
            } else {
                document.getElementById('info-material').textContent = '-';
                document.getElementById('info-temperature').textContent = '-';
                document.getElementById('info-stress').textContent = '-';
                document.getElementById('info-wear').textContent = '-';
                document.getElementById('info-clearance').textContent = '-';
            }
        }
        
        // Setup UI interactions
        function setupUI() {
            // Engine control buttons
            document.getElementById('btn-ignition').addEventListener('click', () => {
                engineState.running = true;
                engineState.speed = 0.3;
                updateTelemetry();
            });
            
            document.getElementById('btn-start').addEventListener('click', () => {
                engineState.running = true;
                engineState.speed = 1.0;
                updateTelemetry();
            });
            
            document.getElementById('btn-stop').addEventListener('click', () => {
                engineState.running = false;
                engineState.speed = 0;
                updateTelemetry();
            });
            
            document.getElementById('btn-reverse').addEventListener('click', () => {
                engineState.direction *= -1;
            });
            
            document.getElementById('btn-emergency').addEventListener('click', () => {
                engineState.running = false;
                engineState.speed = 0;
                engineState.boilerPressure = 0;
                updateTelemetry();
            });
            
            document.getElementById('btn-reset').addEventListener('click', () => {
                controls.reset();
            });
            
            // Sliders
            const sliders = ['pressure', 'temperature', 'throttle', 'cutoff', 'governor', 'lubrication', 'valve-timing', 'tension'];
            sliders.forEach(sliderId => {
                const slider = document.getElementById(`slider-${sliderId}`);
                const valueSpan = document.getElementById(`${sliderId}-value`);
                
                slider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    valueSpan.textContent = sliderId === 'temperature' ? `${value}¬∞F` : 
                                          sliderId === 'pressure' ? `${value} PSI` :
                                          sliderId === 'valve-timing' ? `${value}¬∞` :
                                          `${value}%`;
                    
                    // Update engine state
                    engineState[sliderId.replace('-', '')] = parseInt(value);
                    updateTelemetry();
                });
            });
            
            // Visualization buttons
            const vizButtons = ['wireframe', 'xray', 'transparent', 'exploded', 'section', 'normal'];
            vizButtons.forEach(vizId => {
                const button = document.getElementById(`viz-${vizId}`);
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    vizButtons.forEach(id => {
                        document.getElementById(`viz-${id}`).classList.remove('active');
                    });
                    
                    // Add active class to clicked button
                    button.classList.add('active');
                    
                    // Apply visualization mode
                    applyVisualizationMode(vizId);
                });
            });
            
            // Engineering analysis buttons
            const analysisButtons = ['thermal', 'stress', 'flow', 'vibration', 'wear', 'clearance'];
            analysisButtons.forEach(analysisId => {
                const button = document.getElementById(`btn-${analysisId}`);
                button.addEventListener('click', () => {
                    // Toggle active state
                    button.classList.toggle('active');
                    
                    // Apply analysis mode
                    applyAnalysisMode(analysisId, button.classList.contains('active'));
                });
            });
        }
        
        // Apply visualization mode
        function applyVisualizationMode(mode) {
            visualizationMode = mode;
            
            steamEngine.traverse(child => {
                if (child.isMesh) {
                    switch (mode) {
                        case 'wireframe':
                            child.material.wireframe = true;
                            child.material.transparent = false;
                            child.material.opacity = 1.0;
                            break;
                        case 'xray':
                            child.material.wireframe = false;
                            child.material.transparent = true;
                            child.material.opacity = 0.3;
                            break;
                        case 'transparent':
                            child.material.wireframe = false;
                            child.material.transparent = true;
                            child.material.opacity = 0.7;
                            break;
                        case 'exploded':
                            // This would move components apart
                            break;
                        case 'section':
                            // This would show cross-section
                            break;
                        default: // normal
                            child.material.wireframe = false;
                            child.material.transparent = false;
                            child.material.opacity = 1.0;
                            break;
                    }
                }
            });
        }
        
        // Apply analysis mode
        function applyAnalysisMode(mode, enabled) {
            // This would apply different material shaders for analysis
            // For now, we'll just change colors
            steamEngine.traverse(child => {
                if (child.isMesh && child.userData) {
                    if (enabled) {
                        switch (mode) {
                            case 'thermal':
                                const temp = child.userData.temperature || 20;
                                const heat = Math.min(temp / 300, 1);
                                child.material.emissive = child.material.emissive || new THREE.Color();
                                child.material.emissive.setRGB(heat * 2, heat * 0.5, 0);
                                child.material.emissiveIntensity = heat;
                                break;
                            case 'stress':
                                const stress = child.userData.stress || 0;
                                const stressLevel = Math.min(stress / 100, 1);
                                child.material.color.setHex(
                                    stressLevel > 0.7 ? 0xff0000 :
                                    stressLevel > 0.4 ? 0xffff00 :
                                    0x00ff00
                                );
                                break;
                            case 'wear':
                                const wear = child.userData.wear || 0;
                                child.material.color.setHex(0x888888 - wear * 0x888888);
                                break;
                        }
                    } else {
                        // Reset to original colors
                        child.material.emissive?.setHex(0x000000);
                        child.material.emissiveIntensity = 0;
                        // Note: We should store original colors to reset properly
                    }
                }
            });
        }
        
        // Update telemetry display
        function updateTelemetry() {
            const rpm = engineState.running ? Math.round(engineState.speed * engineState.throttlePosition * 2) : 0;
            const power = engineState.running ? Math.round(rpm * engineState.boilerPressure / 100) : 0;
            const torque = engineState.running ? Math.round(power * 5252 / rpm) || 0 : 0;
            const efficiency = engineState.running ? Math.round((engineState.speed * 70) + (engineState.boilerPressure / 3)) : 0;
            const steamFlow = engineState.running ? Math.round(rpm * 10 * engineState.throttlePosition / 100) : 0;
            const fuelRate = engineState.running ? Math.round(steamFlow / 10) : 0;
            
            document.getElementById('telemetry-rpm').textContent = rpm;
            document.getElementById('telemetry-power').textContent = power;
            document.getElementById('telemetry-torque').textContent = torque;
            document.getElementById('telemetry-efficiency').textContent = Math.min(efficiency, 100);
            document.getElementById('telemetry-steam-flow').textContent = steamFlow;
            document.getElementById('telemetry-fuel').textContent = fuelRate;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            // Update engine animation
            if (engineState.running) {
                updateEngineAnimation(deltaTime);
                updateTelemetry();
                
                // Update component temperatures and stresses
                updateComponentPhysics(deltaTime);
            }
            
            // Update controls
            controls.update();
            
            // Update stats
            if (stats) stats.update();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Update engine animation
        function updateEngineAnimation(deltaTime) {
            const rotationSpeed = engineState.speed * engineState.direction * deltaTime * 2;
            
            // Rotate crankshaft and connected components
            componentGroups.crankshaft.rotation.z += rotationSpeed;
            componentGroups.flywheel.rotation.z += rotationSpeed;
            
            // Calculate piston position based on crankshaft angle
            const crankAngle = componentGroups.crankshaft.rotation.z;
            const pistonX = 20 + Math.cos(crankAngle) * 10;
            componentGroups.piston.position.x = pistonX;
            
            // Update connecting rod angle
            const rodAngle = Math.asin(Math.sin(crankAngle) * 0.5);
            // Find connecting rod in piston group
            componentGroups.piston.traverse(child => {
                if (child.name && child.name.includes('Connecting Rod')) {
                    child.rotation.z = rodAngle;
                }
            });
            
            // Update valve gear
            const valvePosition = Math.sin(crankAngle * 2 + engineState.valveTiming * Math.PI / 180) * 4;
            componentGroups.valveGear.traverse(child => {
                if (child.name && child.name.includes('Valve Rod')) {
                    child.position.z = 14 + valvePosition;
                }
            });
            
            // Update governor (centrifugal force effect)
            const governorSpeed = engineState.speed * engineState.governorSpeed;
            componentGroups.governor.traverse(child => {
                if (child.name && child.name.includes('Governor Ball')) {
                    const radius = 10 + governorSpeed * 2;
                    const index = parseInt(child.name.match(/\d+/)[0]) - 1;
                    const angle = (index * Math.PI / 2) + (governorSpeed * deltaTime * 2);
                    child.position.x = Math.cos(angle) * radius;
                    child.position.y = Math.sin(angle) * radius;
                }
            });
        }
        
        // Update component physics (temperature, stress, wear)
        function updateComponentPhysics(deltaTime) {
            steamEngine.traverse(child => {
                if (child.isMesh && child.userData) {
                    // Update temperature based on proximity to heat sources
                    if (child.position.x > 20 && child.position.x < 40) { // Near cylinder
                        child.userData.temperature = 20 + engineState.steamTemperature * 0.3;
                    } else if (child.position.x < -20) { // Near boiler
                        child.userData.temperature = 20 + engineState.steamTemperature * 0.5;
                    } else {
                        child.userData.temperature = Math.max(20, child.userData.temperature - deltaTime * 10);
                    }
                    
                    // Update stress based on motion and pressure
                    if (child.name && (child.name.includes('Rod') || child.name.includes('Shaft') || child.name.includes('Pin'))) {
                        child.userData.stress = engineState.speed * engineState.boilerPressure * 0.1;
                    }
                    
                    // Update wear based on motion and time
                    if (child.name && (child.name.includes('Bearing') || child.name.includes('Bush') || child.name.includes('Ring'))) {
                        child.userData.wear = Math.min(100, child.userData.wear + deltaTime * engineState.speed * 0.01);
                    }
                }
            });
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>