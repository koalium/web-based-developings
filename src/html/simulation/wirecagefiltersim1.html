<!DOCTYPE html>
<html>
<head>
    <title>Wire Cage with Animated Shell</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #gui { position: absolute; top: 10px; right: 10px; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

<script>
let scene, camera, renderer, controls;
let verticalWires = [], spiralWire, shellMesh;
let animationState = { 
    verticalPlaced: 0,
    spiralProgress: 0,
    weldingPoints: [],
    shellPhase: 0
};
let params = {
    cylinderDiameter: 1.17,   // 117mm
    verticalCount: 22,
    verticalDiameter: 0.014,  // 1.4mm
    verticalLength: 15,       // 1500mm
    spiralDiameter: 0.006,    // 0.6mm
    spiralSpace: 0.045,       // 4.5mm
    materialType: 'inconel',
    background: '#808000',    // Olive
    animationSpeed: 1,
    
    // Shell parameters
    shellLength: 15,          // 1500mm
    shellID: 1.2,             // 120mm
    shellOD: 1.3,             // 130mm
    shellSeparation: 15        // 1500mm
};

init();
animate();

function init() {
    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(params.background);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    // Controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 7.5, 30);  // Center on 15m height
    controls.target.set(0, 7.5, 0);
    controls.update();

    // GUI
    const gui = new dat.GUI();
    gui.add(params, 'animationSpeed', 0.5, 3);
    resetAnimation();
}

function createVerticalWires() {
    verticalWires.forEach(wire => scene.remove(wire));
    verticalWires = [];

    const radius = params.cylinderDiameter / 2;
    const angleStep = (Math.PI * 2) / params.verticalCount;

    for(let i = 0; i < params.verticalCount; i++) {
        const angle = angleStep * i;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        const geometry = new THREE.CylinderGeometry(
            params.verticalDiameter/2, 
            params.verticalDiameter/2, 
            0.1
        );
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x554422,
            metalness: 0.8,
            roughness: 0.4
        });
        const wire = new THREE.Mesh(geometry, material);
        wire.position.set(x, 0.05, z);
        wire.userData = {
            targetHeight: params.verticalLength,
            targetY: params.verticalLength/2
        };
        wire.visible = false;
        verticalWires.push(wire);
        scene.add(wire);
    }
}

function createSpiral() {
    if(spiralWire) scene.remove(spiralWire);
    
    const radius = params.cylinderDiameter / 2 + params.verticalDiameter/2;
    const geometry = new THREE.BufferGeometry();
    spiralWire = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
        color: 0xaaaaaa,
        linewidth: 2
    }));
    spiralWire.visible = false;
    scene.add(spiralWire);
}

function createShell() {
    if(shellMesh) scene.remove(shellMesh);
    
    // Create hollow cylinder geometry
    const outerRadius = params.shellOD / 2;
    const innerRadius = params.shellID / 2;
    const shape = new THREE.Shape();
    shape.absarc(0, 0, outerRadius, 0, Math.PI * 2, false);
    const hole = new THREE.Path();
    hole.absarc(0, 0, innerRadius, 0, Math.PI * 2, true);
    shape.holes.push(hole);

    const extrudeSettings = {
        depth: params.shellLength,
        bevelEnabled: false
    };

    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geometry.rotateX(Math.PI / 2);
    geometry.translate(0, params.shellLength/2, 0);

    shellMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
        color: 0x777777,
        metalness: 0.3,
        roughness: 0.8
    }));
    shellMesh.position.set(0, -params.shellSeparation, 0);
    shellMesh.visible = false;
    scene.add(shellMesh);
}

function createWeldingFlash(position) {
    const flashGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 1
    });
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.userData = { lifetime: 0.3 };
    scene.add(flash);
    animationState.weldingPoints.push(flash);
}

function resetAnimation() {
    animationState = { 
        verticalPlaced: 0,
        spiralProgress: 0,
        weldingPoints: [],
        shellPhase: 0
    };
    
    createVerticalWires();
    createSpiral();
    createShell();
    
    camera.position.set(0, 7.5, 30);
    controls.target.set(0, 7.5, 0);
    controls.update();
}

function animate() {
    requestAnimationFrame(animate);
    const delta = 0.016 * params.animationSpeed;

    // Animate vertical wires
    if (animationState.verticalPlaced < params.verticalCount) {
        const wire = verticalWires[animationState.verticalPlaced];
        
        if (!wire.visible) {
            wire.visible = true;
        } else {
            const currentHeight = wire.geometry.parameters.height;
            const newHeight = Math.min(currentHeight + 0.15, wire.userData.targetHeight);
            
            wire.geometry.dispose();
            wire.geometry = new THREE.CylinderGeometry(
                params.verticalDiameter/2, 
                params.verticalDiameter/2, 
                newHeight
            );
            wire.position.y = newHeight/2;
            
            if (newHeight >= wire.userData.targetHeight) {
                createWeldingFlash(new THREE.Vector3(wire.position.x, 0, wire.position.z));
                createWeldingFlash(new THREE.Vector3(wire.position.x, params.verticalLength, wire.position.z));
                animationState.verticalPlaced++;
            }
        }
    } 
    // Animate spiral
    else if (animationState.spiralProgress < 1) {
        if (!spiralWire.visible) spiralWire.visible = true;
        
        const radius = params.cylinderDiameter / 2 + params.verticalDiameter/2;
        const segments = Math.floor(params.verticalLength / params.spiralSpace * 100);
        const points = [];
        
        animationState.spiralProgress = Math.min(animationState.spiralProgress + delta/6.6, 1);
        
        for(let i = 0; i < segments; i++) {
            const progress = Math.min(i/segments, animationState.spiralProgress);
            const angle = (i/10) * Math.PI;
            const y = progress * params.verticalLength;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            points.push(new THREE.Vector3(x, y, z));
            
            if (i % 15 === 0 && progress === animationState.spiralProgress) {
                createWeldingFlash(new THREE.Vector3(x, y, z));
            }
        }
        
        spiralWire.geometry.dispose();
        spiralWire.geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        // Initial camera movement
        if (animationState.spiralProgress < 0.2) {
            camera.position.z = 30 + 20 * (animationState.spiralProgress/0.2);
            controls.target.y = 7.5 - 5 * (animationState.spiralProgress/0.2);
        }
    }
    // Animate shell
    else if (animationState.shellPhase === 0) {
        shellMesh.visible = true;
        animationState.shellPhase = 1;
        animationState.shellProgress = 0;
    } else if (animationState.shellPhase === 1) {
        // Rise above
        animationState.shellProgress += delta;
        const progress = Math.min(animationState.shellProgress / 2, 1);
        shellMesh.position.y = -params.shellSeparation + (params.shellSeparation * 3) * progress;
        
        if (progress >= 1) {
            animationState.shellPhase = 2;
            animationState.shellProgress = 0;
        }
    } else if (animationState.shellPhase === 2) {
        // Cover cage
        animationState.shellProgress += delta;
        const progress = Math.min(animationState.shellProgress / 2, 1);
        shellMesh.position.y = params.shellSeparation * 2 - (params.shellSeparation * 1.5) * progress;
        
        // Final welding flashes
        if (progress >= 1) {
            for(let i = 0; i < 20; i++) {
                createWeldingFlash(new THREE.Vector3(
                    Math.cos(Math.PI*2*i/20) * params.shellOD/2,
                    params.verticalLength/2,
                    Math.sin(Math.PI*2*i/20) * params.shellOD/2
                ));
            }
            animationState.shellPhase = 3;
        }
    }

    // Animate welding flashes
    for (let i = animationState.weldingPoints.length - 1; i >= 0; i--) {
        const flash = animationState.weldingPoints[i];
        flash.userData.lifetime -= delta;
        
        if (flash.userData.lifetime <= 0) {
            scene.remove(flash);
            animationState.weldingPoints.splice(i, 1);
        } else {
            flash.scale.setScalar(1 + (1 - flash.userData.lifetime) * 3);
            flash.material.opacity = flash.userData.lifetime / 0.3;
        }
    }

    controls.update();
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>